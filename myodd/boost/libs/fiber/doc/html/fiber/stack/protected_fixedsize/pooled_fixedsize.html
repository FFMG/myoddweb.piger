<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Class pooled_fixedsize_stack</title>
<link rel="stylesheet" href="../../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../../index.html" title="Chapter&#160;1.&#160;Fiber">
<link rel="up" href="../protected_fixedsize.html" title="Class protected_fixedsize_stack">
<link rel="prev" href="../protected_fixedsize.html" title="Class protected_fixedsize_stack">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../protected_fixedsize.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../protected_fixedsize.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize"></a><a class="link" href="pooled_fixedsize.html" title="Class pooled_fixedsize_stack">Class
        <span class="emphasis"><em>pooled_fixedsize_stack</em></span></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize">Class
          <span class="emphasis"><em>fixedsize_stack</em></span></a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack">Class
          <span class="emphasis"><em>segmented_stack</em></span></a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization">Synchronization</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.mutex_types">Mutex
            Types</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions">Condition
            Variables</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers">Barriers</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels">Channels</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures">Futures</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future">Future</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise">Template
              <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code></a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task">Template
              <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code></a></span></dt>
</dl></dd>
</dl></dd>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fls">Fiber
          local storage</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration">Migrating
          fibers between threads</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks">Integrating
          Fibers with Asynchronous Callbacks</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking">Integrating
          Fibers with Nonblocking I/O</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any">when_any
          / when_all functionality</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any">when_any</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__simple_completion">when_any,
              simple completion</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__return_value">when_any,
              return value</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_outcome__whether_result_or_exception">when_any,
              produce first outcome, whether result or exception</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_success">when_any,
              produce first success</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__heterogeneous_types">when_any,
              heterogeneous types</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__a_dubious_alternative">when_any,
              a dubious alternative</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality">when_all
            functionality</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__simple_completion">when_all,
              simple completion</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values">when_all,
              return values</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all_until_first_exception">when_all
              until first exception</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.wait_all__collecting_all_exceptions">wait_all,
              collecting all exceptions</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__heterogeneous_types">when_all,
              heterogeneous types</a></span></dt>
</dl></dd>
</dl></dd>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.integration">Sharing
          a Thread with Another Main Loop</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.performance">Performance</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom">Customization</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale">Rationale</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.acknowledgements">Acknowledgments</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.installing">Appendix:
          Installing and Running Tests</a></span></dt>
</dl></div>
<p>
          <span class="bold"><strong>Boost.Fiber</strong></span> provides the class <a class="link" href="../../../"> <code class="computeroutput">pooled_fixedsize_stack</code></a> which
          models the <a class="link" href="../../stack.html#stack_allocator_concept"><span class="emphasis"><em>stack-allocator
          concept</em></span></a>. In contrast to <a class="link" href="../../../"> <code class="computeroutput">protected_fixedsize_stack</code></a> it
          does not append a guard page at the end of each stack. The memory is managed
          internally by <a href="http://www.boost.org/doc/libs/release/libs/pool/doc/html/boost/pool.html" target="_top"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">pool</span><span class="special">&lt;&gt;</span></code></a>.
        </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">pooled_fixedsize_stack</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">pooled_fixedsize_stack</span> <span class="special">{</span>
    <span class="identifier">pooled_fixedsize_stack</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">stack_size</span> <span class="special">=</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">default_size</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">next_size</span> <span class="special">=</span> <span class="number">32</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">max_size</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>

    <span class="identifier">stack_context</span> <span class="identifier">allocate</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">deallocate</span><span class="special">(</span> <span class="identifier">stack_context</span> <span class="special">&amp;);</span>
<span class="special">}</span>
</pre>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.h0"></a>
          <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize._code__phrase_role__identifier__pooled_fixedsize_stack__phrase__phrase_role__special_____phrase__phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase___phrase_role__identifier__stack_size__phrase__phrase_role__special_____phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase___phrase_role__identifier__next_size__phrase__phrase_role__special_____phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase___phrase_role__identifier__max_size__phrase__phrase_role__special_____phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize._code__phrase_role__identifier__pooled_fixedsize_stack__phrase__phrase_role__special_____phrase__phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase___phrase_role__identifier__stack_size__phrase__phrase_role__special_____phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase___phrase_role__identifier__next_size__phrase__phrase_role__special_____phrase___phrase_role__identifier__std__phrase__phrase_role__special______phrase__phrase_role__identifier__size_t__phrase___phrase_role__identifier__max_size__phrase__phrase_role__special_____phrase___code_"><code class="computeroutput"><span class="identifier">pooled_fixedsize_stack</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">stack_size</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">next_size</span><span class="special">,</span>
          <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">max_size</span><span class="special">)</span></code></a>
        </h6>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">is_unbounded</span><span class="special">()</span>
                <span class="special">||</span> <span class="special">(</span>
                <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">maximum_size</span><span class="special">()</span>
                <span class="special">&gt;=</span> <span class="identifier">stack_size</span><span class="special">)</span></code> and <code class="computeroutput"><span class="number">0</span>
                <span class="special">&lt;</span> <span class="identifier">next_size</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Allocates memory of at least <code class="computeroutput"><span class="identifier">stack_size</span></code>
                bytes and stores a pointer to the stack and its actual size in <code class="computeroutput"><span class="identifier">sctx</span></code>. Depending on the architecture
                (the stack grows downwards/upwards) the stored address is the highest/lowest
                address of the stack. Argument <code class="computeroutput"><span class="identifier">next_size</span></code>
                determines the number of stacks to request from the system the first
                time that <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                needs to allocate system memory. The third argument <code class="computeroutput"><span class="identifier">max_size</span></code> controls how much memory
                might be allocated for stacks &#8212; a value of zero means no upper limit.
              </p></dd>
</dl>
</div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.h1"></a>
          <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize._code__phrase_role__identifier__stack_context__phrase___phrase_role__identifier__allocate__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize._code__phrase_role__identifier__stack_context__phrase___phrase_role__identifier__allocate__phrase__phrase_role__special______phrase___code_"><code class="computeroutput"><span class="identifier">stack_context</span> <span class="identifier">allocate</span><span class="special">()</span></code></a>
        </h6>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">is_unbounded</span><span class="special">()</span>
                <span class="special">||</span> <span class="special">(</span>
                <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">maximum_size</span><span class="special">()</span>
                <span class="special">&gt;=</span> <span class="identifier">stack_size</span><span class="special">)</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Allocates memory of at least <code class="computeroutput"><span class="identifier">stack_size</span></code>
                bytes and stores a pointer to the stack and its actual size in <code class="computeroutput"><span class="identifier">sctx</span></code>. Depending on the architecture
                (the stack grows downwards/upwards) the stored address is the highest/lowest
                address of the stack.
              </p></dd>
</dl>
</div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.h2"></a>
          <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize._code__phrase_role__keyword__void__phrase___phrase_role__identifier__deallocate__phrase__phrase_role__special_____phrase___phrase_role__identifier__stack_context__phrase___phrase_role__special___amp___phrase___phrase_role__identifier__sctx__phrase__phrase_role__special_____phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize._code__phrase_role__keyword__void__phrase___phrase_role__identifier__deallocate__phrase__phrase_role__special_____phrase___phrase_role__identifier__stack_context__phrase___phrase_role__special___amp___phrase___phrase_role__identifier__sctx__phrase__phrase_role__special_____phrase___code_"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">deallocate</span><span class="special">(</span> <span class="identifier">stack_context</span>
          <span class="special">&amp;</span> <span class="identifier">sctx</span><span class="special">)</span></code></a>
        </h6>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">sctx</span><span class="special">.</span><span class="identifier">sp</span></code> is valid, <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">is_unbounded</span><span class="special">()</span> <span class="special">||</span> <span class="special">(</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">maximum_size</span><span class="special">()</span> <span class="special">&gt;=</span>
                <span class="identifier">sctx</span><span class="special">.</span><span class="identifier">size</span><span class="special">)</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Deallocates the stack space.
              </p></dd>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize"></a><a name="class_fixedsize_stack"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize" title="Class fixedsize_stack">Class
          <span class="emphasis"><em>fixedsize_stack</em></span></a>
</h5></div></div></div>
<p>
            <span class="bold"><strong>Boost.Fiber</strong></span> provides the class __fixedsize__
            which models the <a class="link" href="../../stack.html#stack_allocator_concept"><span class="emphasis"><em>stack-allocator
            concept</em></span></a>. In contrast to __protected_fixedsize__ it
            does not append a guard page at the end of each stack. The memory is
            simply managed by <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">malloc</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">free</span><span class="special">()</span></code>.
          </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">context</span><span class="special">/</span><span class="identifier">fixedsize_stack</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">fixedsize_stack</span> <span class="special">{</span>
    <span class="identifier">fixedsize_stack</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">default_size</span><span class="special">());</span>

    <span class="identifier">stack_context</span> <span class="identifier">allocate</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">deallocate</span><span class="special">(</span> <span class="identifier">stack_context</span> <span class="special">&amp;);</span>
<span class="special">}</span>
</pre>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize._code__phrase_role__identifier__stack_context__phrase___phrase_role__identifier__allocate__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize._code__phrase_role__identifier__stack_context__phrase___phrase_role__identifier__allocate__phrase__phrase_role__special______phrase___code_"><code class="computeroutput"><span class="identifier">stack_context</span> <span class="identifier">allocate</span><span class="special">()</span></code></a>
          </h6>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">minimum_size</span><span class="special">()</span>
                  <span class="special">&lt;=</span> <span class="identifier">size</span></code>
                  and <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">is_unbounded</span><span class="special">()</span> <span class="special">||</span>
                  <span class="special">(</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">maximum_size</span><span class="special">()</span> <span class="special">&gt;=</span>
                  <span class="identifier">size</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Allocates memory of at least <code class="computeroutput"><span class="identifier">size</span></code>
                  bytes and stores a pointer to the stack and its actual size in
                  <code class="computeroutput"><span class="identifier">sctx</span></code>. Depending
                  on the architecture (the stack grows downwards/upwards) the stored
                  address is the highest/lowest address of the stack.
                </p></dd>
</dl>
</div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize._code__phrase_role__keyword__void__phrase___phrase_role__identifier__deallocate__phrase__phrase_role__special_____phrase___phrase_role__identifier__stack_context__phrase___phrase_role__special___amp___phrase___phrase_role__identifier__sctx__phrase__phrase_role__special_____phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fixedsize._code__phrase_role__keyword__void__phrase___phrase_role__identifier__deallocate__phrase__phrase_role__special_____phrase___phrase_role__identifier__stack_context__phrase___phrase_role__special___amp___phrase___phrase_role__identifier__sctx__phrase__phrase_role__special_____phrase___code_"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">deallocate</span><span class="special">(</span> <span class="identifier">stack_context</span>
            <span class="special">&amp;</span> <span class="identifier">sctx</span><span class="special">)</span></code></a>
          </h6>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">sctx</span><span class="special">.</span><span class="identifier">sp</span></code> is valid, <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">minimum_size</span><span class="special">()</span> <span class="special">&lt;=</span>
                  <span class="identifier">sctx</span><span class="special">.</span><span class="identifier">size</span></code> and <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">is_unbounded</span><span class="special">()</span> <span class="special">||</span>
                  <span class="special">(</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">maximum_size</span><span class="special">()</span> <span class="special">&gt;=</span>
                  <span class="identifier">sctx</span><span class="special">.</span><span class="identifier">size</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Deallocates the stack space.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack" title="Class segmented_stack">Class
          <span class="emphasis"><em>segmented_stack</em></span></a>
</h5></div></div></div>
<p>
            <span class="bold"><strong>Boost.Fiber</strong></span> supports usage of a <a class="link" href="../../../"> <code class="computeroutput">segmented_stack</code></a>,
            i.e. the stack grows on demand. The fiber is created with a minimal stack
            size which will be increased as required. Class <a class="link" href="../../../"> <code class="computeroutput">segmented_stack</code></a> models
            the <a class="link" href="../../stack.html#stack_allocator_concept"><span class="emphasis"><em>stack-allocator
            concept</em></span></a>. In contrast to <a class="link" href="../../../"> <code class="computeroutput">protected_fixedsize_stack</code></a> and
            <a class="link" href="pooled_fixedsize.html#class_fixedsize_stack"> <code class="computeroutput">fixedsize_stack</code></a> it creates a stack which grows on
            demand.
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              Segmented stacks are currently only supported by <span class="bold"><strong>gcc</strong></span>
              from version <span class="bold"><strong>4.7</strong></span> and <span class="bold"><strong>clang</strong></span>
              from version <span class="bold"><strong>3.4</strong></span> onwards. In order
              to use a <a class="link" href="../../../"> <code class="computeroutput">segmented_stack</code></a> <span class="bold"><strong>Boost.Fiber</strong></span>
              must be built with property <code class="computeroutput"><span class="identifier">segmented</span><span class="special">-</span><span class="identifier">stacks</span></code>,
              e.g. <span class="bold"><strong>toolset=gcc segmented-stacks=on</strong></span>
              at b2/bjam command line.
            </p></td></tr>
</table></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">segmented_stack</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">segmented_stack</span> <span class="special">{</span>
    <span class="identifier">segmented_stack</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">stack_size</span> <span class="special">=</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">default_size</span><span class="special">());</span>

    <span class="identifier">stack_context</span> <span class="identifier">allocate</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">deallocate</span><span class="special">(</span> <span class="identifier">stack_context</span> <span class="special">&amp;);</span>
<span class="special">}</span>
</pre>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack._code__phrase_role__identifier__stack_context__phrase___phrase_role__identifier__allocate__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack._code__phrase_role__identifier__stack_context__phrase___phrase_role__identifier__allocate__phrase__phrase_role__special______phrase___code_"><code class="computeroutput"><span class="identifier">stack_context</span> <span class="identifier">allocate</span><span class="special">()</span></code></a>
          </h6>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">minimum_size</span><span class="special">()</span>
                  <span class="special">&lt;=</span> <span class="identifier">size</span></code>
                  and <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">is_unbounded</span><span class="special">()</span> <span class="special">||</span>
                  <span class="special">(</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">maximum_size</span><span class="special">()</span> <span class="special">&gt;=</span>
                  <span class="identifier">size</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Allocates memory of at least <code class="computeroutput"><span class="identifier">size</span></code>
                  bytes and stores a pointer to the stack and its actual size in
                  <code class="computeroutput"><span class="identifier">sctx</span></code>. Depending
                  on the architecture (the stack grows downwards/upwards) the stored
                  address is the highest/lowest address of the stack.
                </p></dd>
</dl>
</div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack._code__phrase_role__keyword__void__phrase___phrase_role__identifier__deallocate__phrase__phrase_role__special_____phrase___phrase_role__identifier__stack_context__phrase___phrase_role__special___amp___phrase___phrase_role__identifier__sctx__phrase__phrase_role__special_____phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.segmented_stack._code__phrase_role__keyword__void__phrase___phrase_role__identifier__deallocate__phrase__phrase_role__special_____phrase___phrase_role__identifier__stack_context__phrase___phrase_role__special___amp___phrase___phrase_role__identifier__sctx__phrase__phrase_role__special_____phrase___code_"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">deallocate</span><span class="special">(</span> <span class="identifier">stack_context</span>
            <span class="special">&amp;</span> <span class="identifier">sctx</span><span class="special">)</span></code></a>
          </h6>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">sctx</span><span class="special">.</span><span class="identifier">sp</span></code> is valid, <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">minimum_size</span><span class="special">()</span> <span class="special">&lt;=</span>
                  <span class="identifier">sctx</span><span class="special">.</span><span class="identifier">size</span></code> and <code class="computeroutput"><span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">is_unbounded</span><span class="special">()</span> <span class="special">||</span>
                  <span class="special">(</span> <span class="identifier">traits_type</span><span class="special">::</span><span class="identifier">maximum_size</span><span class="special">()</span> <span class="special">&gt;=</span>
                  <span class="identifier">sctx</span><span class="special">.</span><span class="identifier">size</span><span class="special">)</span></code>.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Deallocates the stack space.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              If the library is compiled for segmented stacks, <a class="link" href="../../../"> <code class="computeroutput">segmented_stack</code></a> is
              the only available stack allocator.
            </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization"></a><a name="synchronization"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization" title="Synchronization">Synchronization</a>
</h5></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.mutex_types">Mutex
            Types</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions">Condition
            Variables</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers">Barriers</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels">Channels</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures">Futures</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future">Future</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise">Template
              <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code></a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task">Template
              <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code></a></span></dt>
</dl></dd>
</dl></div>
<p>
            In general, <span class="bold"><strong>Boost.Fiber</strong></span> synchronization
            objects can neither be moved nor copied. A synchronization object acts
            as a mutually-agreed rendezvous point between different fibers. If such
            an object were copied somewhere else, the new copy would have no consumers.
            If such an object were <span class="emphasis"><em>moved</em></span> somewhere else, leaving
            the original instance in an unspecified state, existing consumers would
            behave strangely.
          </p>
<p>
            The fiber synchronization objects provided by this library will, by default,
            safely synchronize fibers running on different threads. However, this
            level of synchronization can be removed (for performance) by building
            the library with <span class="bold"><strong><code class="computeroutput"><span class="identifier">BOOST_FIBERS_NO_ATOMICS</span></code></strong></span>
            defined. When the library is built with that macro, you must ensure that
            all the fibers referencing a particular synchronization object are running
            in the same thread.
          </p>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.mutex_types"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.mutex_types" title="Mutex Types">Mutex
            Types</a>
</h6></div></div></div>
<p>
              </p>
<h5>
<a name="class_mutex_bridgehead"></a>
  <span><a name="class_mutex"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_mutex">Class <code class="computeroutput">mutex</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">mutex</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">mutex</span><span class="special">();</span>

    <span class="identifier">mutex</span><span class="special">(</span> <span class="identifier">mutex</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">mutex</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">mutex</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
              <a class="link" href="pooled_fixedsize.html#class_mutex"> <code class="computeroutput">mutex</code></a> provides an exclusive-ownership mutex. At most one
              fiber can own the lock on a given instance of <a class="link" href="pooled_fixedsize.html#class_mutex"> <code class="computeroutput">mutex</code></a> at any
              time. Multiple concurrent calls to <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code> shall be permitted.
            </p>
<p>
              Any fiber blocked in <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code> is suspended until the owning fiber
              releases the lock by calling <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>.
            </p>
<p>
              </p>
<h5>
<a name="mutex_lock_bridgehead"></a>
  <span><a name="mutex_lock"></a></span>
  <a class="link" href="pooled_fixedsize.html#mutex_lock">Member function <code class="computeroutput">lock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    The calling fiber doesn't own the mutex.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    The current fiber blocks until ownership can be obtained.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                    if <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    already owns the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="mutex_try_lock_bridgehead"></a>
  <span><a name="mutex_try_lock"></a></span>
  <a class="link" href="pooled_fixedsize.html#mutex_try_lock">Member function
              <code class="computeroutput">try_lock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    The calling fiber doesn't own the mutex.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Attempt to obtain ownership for the current fiber without blocking.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                    was obtained for the current fiber, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                    if <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    already owns the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="mutex_unlock_bridgehead"></a>
  <span><a name="mutex_unlock"></a></span>
  <a class="link" href="pooled_fixedsize.html#mutex_unlock">Member function <code class="computeroutput">unlock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    The current fiber owns <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Releases a lock on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>operation_not_permitted</strong></span>: if
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    does not own the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="class_timed_mutex_bridgehead"></a>
  <span><a name="class_timed_mutex"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_timed_mutex">Class
              <code class="computeroutput">timed_mutex</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">timed_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">timed_mutex</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">timed_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">timed_mutex</span><span class="special">();</span>

    <span class="identifier">timed_mutex</span><span class="special">(</span> <span class="identifier">timed_mutex</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">timed_mutex</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">timed_mutex</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<p>
              <a class="link" href="pooled_fixedsize.html#class_timed_mutex"> <code class="computeroutput">timed_mutex</code></a> provides an exclusive-ownership mutex.
              At most one fiber can own the lock on a given instance of <a class="link" href="pooled_fixedsize.html#class_timed_mutex"> <code class="computeroutput">timed_mutex</code></a> at
              any time. Multiple concurrent calls to <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">try_lock_until</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">try_lock_for</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code> shall be permitted.
            </p>
<p>
              </p>
<h5>
<a name="timed_mutex_lock_bridgehead"></a>
  <span><a name="timed_mutex_lock"></a></span>
  <a class="link" href="pooled_fixedsize.html#timed_mutex_lock">Member function
              <code class="computeroutput">lock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    The calling fiber doesn't own the mutex.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    The current fiber blocks until ownership can be obtained.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                    if <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    already owns the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="timed_mutex_try_lock_bridgehead"></a>
  <span><a name="timed_mutex_try_lock"></a></span>
  <a class="link" href="pooled_fixedsize.html#timed_mutex_try_lock">Member
              function <code class="computeroutput">try_lock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    The calling fiber doesn't own the mutex.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Attempt to obtain ownership for the current fiber without blocking.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                    was obtained for the current fiber, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                    if <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    already owns the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="timed_mutex_unlock_bridgehead"></a>
  <span><a name="timed_mutex_unlock"></a></span>
  <a class="link" href="pooled_fixedsize.html#timed_mutex_unlock">Member
              function <code class="computeroutput">unlock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    The current fiber owns <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Releases a lock on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>operation_not_permitted</strong></span>: if
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    does not own the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="timed_mutex_try_lock_until_bridgehead"></a>
  <span><a name="timed_mutex_try_lock_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#timed_mutex_try_lock_until">Templated
              member function <code class="computeroutput">try_lock_until</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    The calling fiber doesn't own the mutex.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Attempt to obtain ownership for the current fiber. Blocks until
                    ownership can be obtained, or the specified time is reached.
                    If the specified time has already passed, behaves as <a class="link" href="pooled_fixedsize.html#timed_mutex_try_lock"> <code class="computeroutput">timed_mutex::try_lock()</code></a>.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                    was obtained for the current fiber, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>, timeout-related
                    exceptions.
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                    if <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    already owns the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="timed_mutex_try_lock_for_bridgehead"></a>
  <span><a name="timed_mutex_try_lock_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#timed_mutex_try_lock_for">Templated
              member function <code class="computeroutput">try_lock_for</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    The calling fiber doesn't own the mutex.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Attempt to obtain ownership for the current fiber. Blocks until
                    ownership can be obtained, or the specified time is reached.
                    If the specified time has already passed, behaves as <a class="link" href="pooled_fixedsize.html#timed_mutex_try_lock"> <code class="computeroutput">timed_mutex::try_lock()</code></a>.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                    was obtained for the current fiber, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>, timeout-related
                    exceptions.
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>resource_deadlock_would_occur</strong></span>:
                    if <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    already owns the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="class_recursive_mutex_bridgehead"></a>
  <span><a name="class_recursive_mutex"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_recursive_mutex">Class
              <code class="computeroutput">recursive_mutex</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">recursive_mutex</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">recursive_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">recursive_mutex</span><span class="special">();</span>

    <span class="identifier">recursive_mutex</span><span class="special">(</span> <span class="identifier">recursive_mutex</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">recursive_mutex</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">recursive_mutex</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
              <a class="link" href="pooled_fixedsize.html#class_recursive_mutex"> <code class="computeroutput">recursive_mutex</code></a> provides an exclusive-ownership
              recursive mutex. At most one fiber can own the lock on a given instance
              of <a class="link" href="pooled_fixedsize.html#class_recursive_mutex"> <code class="computeroutput">recursive_mutex</code></a> at any time. Multiple concurrent
              calls to <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code>,
              <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>
              and <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
              shall be permitted. A fiber that already has exclusive ownership of
              a given <a class="link" href="pooled_fixedsize.html#class_recursive_mutex"> <code class="computeroutput">recursive_mutex</code></a> instance can call <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code>
              or <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>
              to acquire an additional level of ownership of the mutex. <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
              must be called once for each level of ownership acquired by a single
              fiber before ownership can be acquired by another fiber.
            </p>
<p>
              </p>
<h5>
<a name="recursive_mutex_lock_bridgehead"></a>
  <span><a name="recursive_mutex_lock"></a></span>
  <a class="link" href="pooled_fixedsize.html#recursive_mutex_lock">Member
              function <code class="computeroutput">lock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    The current fiber blocks until ownership can be obtained.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="recursive_mutex_try_lock_bridgehead"></a>
  <span><a name="recursive_mutex_try_lock"></a></span>
  <a class="link" href="pooled_fixedsize.html#recursive_mutex_try_lock">Member
              function <code class="computeroutput">try_lock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Attempt to obtain ownership for the current fiber without blocking.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                    was obtained for the current fiber, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="recursive_mutex_unlock_bridgehead"></a>
  <span><a name="recursive_mutex_unlock"></a></span>
  <a class="link" href="pooled_fixedsize.html#recursive_mutex_unlock">Member
              function <code class="computeroutput">unlock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Releases a lock on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>operation_not_permitted</strong></span>: if
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    does not own the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="class_recursive_timed_mutex_bridgehead"></a>
  <span><a name="class_recursive_timed_mutex"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_recursive_timed_mutex">Class
              <code class="computeroutput">recursive_timed_mutex</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">recursive_timed_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">recursive_timed_mutex</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">recursive_timed_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">recursive_timed_mutex</span><span class="special">();</span>

    <span class="identifier">recursive_timed_mutex</span><span class="special">(</span> <span class="identifier">recursive_timed_mutex</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">recursive_timed_mutex</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">recursive_timed_mutex</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<p>
              <a class="link" href="pooled_fixedsize.html#class_recursive_timed_mutex"> <code class="computeroutput">recursive_timed_mutex</code></a> provides an exclusive-ownership
              recursive mutex. At most one fiber can own the lock on a given instance
              of <a class="link" href="pooled_fixedsize.html#class_recursive_timed_mutex"> <code class="computeroutput">recursive_timed_mutex</code></a> at any time. Multiple
              concurrent calls to <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">try_lock_for</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">try_lock_until</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code> shall be permitted. A fiber that
              already has exclusive ownership of a given <a class="link" href="pooled_fixedsize.html#class_recursive_timed_mutex"> <code class="computeroutput">recursive_timed_mutex</code></a> instance
              can call <code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code>,
              <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code>,
              <code class="computeroutput"><span class="identifier">try_lock_for</span><span class="special">()</span></code>
              or <code class="computeroutput"><span class="identifier">try_lock_until</span><span class="special">()</span></code>
              to acquire an additional level of ownership of the mutex. <code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code>
              must be called once for each level of ownership acquired by a single
              fiber before ownership can be acquired by another fiber.
            </p>
<p>
              </p>
<h5>
<a name="recursive_timed_mutex_lock_bridgehead"></a>
  <span><a name="recursive_timed_mutex_lock"></a></span>
  <a class="link" href="pooled_fixedsize.html#recursive_timed_mutex_lock">Member
              function <code class="computeroutput">lock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    The current fiber blocks until ownership can be obtained.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="recursive_timed_mutex_try_lock_bridgehead"></a>
  <span><a name="recursive_timed_mutex_try_lock"></a></span>
  <a class="link" href="pooled_fixedsize.html#recursive_timed_mutex_try_lock">Member
              function <code class="computeroutput">try_lock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Attempt to obtain ownership for the current fiber without blocking.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                    was obtained for the current fiber, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="recursive_timed_mutex_unlock_bridgehead"></a>
  <span><a name="recursive_timed_mutex_unlock"></a></span>
  <a class="link" href="pooled_fixedsize.html#recursive_timed_mutex_unlock">Member
              function <code class="computeroutput">unlock</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Releases a lock on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lock_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>operation_not_permitted</strong></span>: if
                    <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span></code>
                    does not own the mutex.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="recursive_timed_mutex_try_lock_until_bridgehead"></a>
  <span><a name="recursive_timed_mutex_try_lock_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#recursive_timed_mutex_try_lock_until">Templated
              member function <code class="computeroutput">try_lock_until</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">try_lock_until</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Attempt to obtain ownership for the current fiber. Blocks until
                    ownership can be obtained, or the specified time is reached.
                    If the specified time has already passed, behaves as <a class="link" href="pooled_fixedsize.html#recursive_timed_mutex_try_lock"> <code class="computeroutput">recursive_timed_mutex::try_lock()</code></a>.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                    was obtained for the current fiber, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Timeout-related exceptions.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="recursive_timed_mutex_try_lock_for_bridgehead"></a>
  <span><a name="recursive_timed_mutex_try_lock_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#recursive_timed_mutex_try_lock_for">Templated
              member function <code class="computeroutput">try_lock_for</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">try_lock_for</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Attempt to obtain ownership for the current fiber. Blocks until
                    ownership can be obtained, or the specified time is reached.
                    If the specified time has already passed, behaves as <a class="link" href="pooled_fixedsize.html#recursive_timed_mutex_try_lock"> <code class="computeroutput">recursive_timed_mutex::try_lock()</code></a>.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> if ownership
                    was obtained for the current fiber, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Timeout-related exceptions.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions" title="Condition Variables">Condition
            Variables</a>
</h6></div></div></div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h0"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.synopsis"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.synopsis">Synopsis</a>
            </h7><pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">cv_status</span><span class="special">;</span> <span class="special">{</span>
    <span class="identifier">no_timeout</span><span class="special">,</span>
    <span class="identifier">timeout</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">condition_variable</span><span class="special">;</span>
<span class="keyword">class</span> <span class="identifier">condition_variable_any</span><span class="special">;</span>
</pre>
<p>
              The class <a class="link" href="pooled_fixedsize.html#class_condition_variable"> <code class="computeroutput">condition_variable</code></a> provides a mechanism
              for a fiber to wait for notification from another fiber. When the fiber
              awakens from the wait, then it checks to see if the appropriate condition
              is now true, and continues if so. If the condition is not true, then
              the fiber calls <code class="computeroutput"><span class="identifier">wait</span></code>
              again to resume waiting. In the simplest case, this condition is just
              a boolean variable:
            </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mtx</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">data_ready</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">process_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">wait_for_data_to_process</span><span class="special">()</span> <span class="special">{</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx</span><span class="special">);</span>
        <span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">data_ready</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">}</span>   <span class="comment">// release lk</span>
    <span class="identifier">process_data</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              Notice that the <code class="computeroutput"><span class="identifier">lk</span></code>
              is passed to <a class="link" href="pooled_fixedsize.html#condition_variable_wait"> <code class="computeroutput">condition_variable::wait()</code></a>: <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
              will atomically add the fiber to the set of fibers waiting on the condition
              variable, and unlock the <a class="link" href="pooled_fixedsize.html#class_mutex"> <code class="computeroutput">mutex</code></a>. When the fiber is awakened,
              the <code class="computeroutput"><span class="identifier">mutex</span></code> will be locked
              again before the call to <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code> returns. This allows other fibers
              to acquire the <code class="computeroutput"><span class="identifier">mutex</span></code>
              in order to update the shared data, and ensures that the data associated
              with the condition is correctly synchronized.
            </p>
<p>
              <code class="computeroutput"><span class="identifier">wait_for_data_to_process</span><span class="special">()</span></code> could equivalently be written:
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">wait_for_data_to_process</span><span class="special">()</span> <span class="special">{</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx</span><span class="special">);</span>
        <span class="comment">// make condition_variable::wait() perform the loop</span>
        <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">data_ready</span><span class="special">;</span> <span class="special">});</span>
    <span class="special">}</span>   <span class="comment">// release lk</span>
    <span class="identifier">process_data</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              In the meantime, another fiber sets <code class="computeroutput"><span class="identifier">data_ready</span></code>
              to <code class="computeroutput"><span class="keyword">true</span></code>, and then calls
              either <a class="link" href="pooled_fixedsize.html#condition_variable_notify_one"> <code class="computeroutput">condition_variable::notify_one()</code></a> or
              <a class="link" href="pooled_fixedsize.html#condition_variable_notify_all"> <code class="computeroutput">condition_variable::notify_all()</code></a> on the
              <a class="link" href="pooled_fixedsize.html#class_condition_variable"> <code class="computeroutput">condition_variable</code></a> <code class="computeroutput"><span class="identifier">cond</span></code>
              to wake one waiting fiber or all the waiting fibers respectively.
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">retrieve_data</span><span class="special">();</span>
<span class="keyword">void</span> <span class="identifier">prepare_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">prepare_data_for_processing</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">retrieve_data</span><span class="special">();</span>
    <span class="identifier">prepare_data</span><span class="special">();</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx</span><span class="special">);</span>
        <span class="identifier">data_ready</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              Note that the same <a class="link" href="pooled_fixedsize.html#class_mutex"> <code class="computeroutput">mutex</code></a> is locked before the shared data
              is updated, but that the <code class="computeroutput"><span class="identifier">mutex</span></code>
              does not have to be locked across the call to <a class="link" href="pooled_fixedsize.html#condition_variable_notify_one"> <code class="computeroutput">condition_variable::notify_one()</code></a>.
            </p>
<p>
              Locking is important because the synchronization objects provided by
              <span class="bold"><strong>Boost.Fiber</strong></span> can be used to synchronize
              fibers running on different threads.
            </p>
<p>
              <span class="bold"><strong>Boost.Fiber</strong></span> provides both <a class="link" href="pooled_fixedsize.html#class_condition_variable"> <code class="computeroutput">condition_variable</code></a> and
              <a class="link" href="pooled_fixedsize.html#class_condition_variable_any"> <code class="computeroutput">condition_variable_any</code></a>. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">condition_variable</span></code>
              can only wait on <a href="http://en.cppreference.com/w/cpp/thread/unique_lock" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a><code class="computeroutput"><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span></code> <a class="link" href="pooled_fixedsize.html#class_mutex"> <code class="computeroutput">mutex</code></a><code class="computeroutput"> <span class="special">&gt;</span></code>
              while <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">condition_variable_any</span></code> can wait on
              user-defined lock types.
            </p>
<a name="condition_variable_spurious_wakeups"></a><h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h1"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.no_spurious_wakeups"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.no_spurious_wakeups">No
              Spurious Wakeups</a>
            </h7><p>
              Neither <a class="link" href="pooled_fixedsize.html#class_condition_variable"> <code class="computeroutput">condition_variable</code></a> nor <a class="link" href="pooled_fixedsize.html#class_condition_variable_any"> <code class="computeroutput">condition_variable_any</code></a> are
              subject to spurious wakeup: <a class="link" href="pooled_fixedsize.html#condition_variable_wait"> <code class="computeroutput">condition_variable::wait()</code></a> can
              only wake up when <a class="link" href="pooled_fixedsize.html#condition_variable_notify_one"> <code class="computeroutput">condition_variable::notify_one()</code></a> or
              <a class="link" href="pooled_fixedsize.html#condition_variable_notify_all"> <code class="computeroutput">condition_variable::notify_all()</code></a> is called.
              Even so, it is prudent to use one of the <code class="computeroutput"><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate</span>
              <span class="special">)</span></code> overloads.
            </p>
<p>
              Consider a set of consumer fibers processing items from a <a href="http://en.cppreference.com/w/cpp/container/queue" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">queue</span></code></a>. The queue is continually
              populated by a set of producer fibers.
            </p>
<p>
              The consumer fibers might reasonably wait on a <code class="computeroutput"><span class="identifier">condition_variable</span></code>
              as long as the queue remains <a href="http://en.cppreference.com/w/cpp/container/queue/empty" target="_top"><code class="computeroutput"><span class="identifier">empty</span><span class="special">()</span></code></a>.
            </p>
<p>
              Because producer fibers might <a href="http://en.cppreference.com/w/cpp/container/queue/push" target="_top"><code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code></a>
              items to the queue in bursts, they call <a class="link" href="pooled_fixedsize.html#condition_variable_notify_all"> <code class="computeroutput">condition_variable::notify_all()</code></a> rather
              than <a class="link" href="pooled_fixedsize.html#condition_variable_notify_one"> <code class="computeroutput">condition_variable::notify_one()</code></a>.
            </p>
<p>
              But a given consumer fiber might well wake up from <a class="link" href="pooled_fixedsize.html#condition_variable_wait"> <code class="computeroutput">condition_variable::wait()</code></a> and
              find the queue <code class="computeroutput"><span class="identifier">empty</span><span class="special">()</span></code>, because other consumer fibers might
              already have processed all pending items.
            </p>
<p>
              (See also <a class="link" href="pooled_fixedsize.html#spurious_wakeup">spurious wakeup</a>.)
            </p>
<a name="class_cv_status"></a><h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h2"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.enumeration__code__phrase_role__identifier__cv_status__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.enumeration__code__phrase_role__identifier__cv_status__phrase___code_">Enumeration
              <code class="computeroutput"><span class="identifier">cv_status</span></code></a>
            </h7><p>
              A timed wait operation might return because of timeout or not.
            </p>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">cv_status</span> <span class="special">{</span>
    <span class="identifier">no_timeout</span><span class="special">,</span>
    <span class="identifier">timeout</span>
<span class="special">};</span>
</pre>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h3"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions._code__phrase_role__identifier__no_timeout__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions._code__phrase_role__identifier__no_timeout__phrase___code_"><code class="computeroutput"><span class="identifier">no_timeout</span></code></a>
            </h7><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    The condition variable was awakened with <code class="computeroutput"><span class="identifier">notify_one</span></code>
                    or <code class="computeroutput"><span class="identifier">notify_all</span></code>.
                  </p></dd>
</dl>
</div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h4"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions._code__phrase_role__identifier__timeout__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions._code__phrase_role__identifier__timeout__phrase___code_"><code class="computeroutput"><span class="identifier">timeout</span></code></a>
            </h7><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    The condition variable was awakened by timeout.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="class_condition_variable_any_bridgehead"></a>
  <span><a name="class_condition_variable_any"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_condition_variable_any">Class
              <code class="computeroutput">condition_variable_any</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">condition_variable</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> condition_variable_any <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    condition_variable_any<span class="special">();</span>
    <span class="special">~</span>condition_variable_any<span class="special">();</span>

    condition_variable_any<span class="special">(</span> condition_variable_any <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    condition_variable_any <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> condition_variable_any <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    template&lt; typename LockType &gt;
    void <span class="identifier">wait</span><span class="special">(</span> LockType <span class="special">&amp;);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> LockType <span class="special">&amp;,</span> <span class="identifier">Pred</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span> LockType <span class="special">&amp;,</span>
                          <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> LockType <span class="special">&amp;,</span>
                     <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;,</span>
                     <span class="identifier">Pred</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span> LockType <span class="special">&amp;,</span>
                        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> LockType <span class="special">&amp;,</span>
                   <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;,</span>
                   <span class="identifier">Pred</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h5"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.constructor">Constructor</a>
            </h7><pre class="programlisting">condition_variable_any<span class="special">()</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Creates the object.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h6"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.destructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.destructor">Destructor</a>
            </h7><pre class="programlisting"><span class="special">~</span>condition_variable_any<span class="special">()</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    All fibers waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                    to <code class="computeroutput"><span class="identifier">notify_one</span></code>
                    or <code class="computeroutput"><span class="identifier">notify_all</span></code>
                    (though the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code> need
                    not have returned).
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Destroys the object.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_any_notify_one_bridgehead"></a>
  <span><a name="condition_variable_any_notify_one"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_any_notify_one">Member
              function <code class="computeroutput">notify_one</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If any fibers are currently <a class="link" href="../../overview.html#blocking"><span class="emphasis"><em>blocked</em></span></a>
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    in a call to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code>, unblocks
                    one of those fibers.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    It is arbitrary which waiting fiber is resumed.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_any_notify_all_bridgehead"></a>
  <span><a name="condition_variable_any_notify_all"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_any_notify_all">Member
              function <code class="computeroutput">notify_all</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If any fibers are currently <a class="link" href="../../overview.html#blocking"><span class="emphasis"><em>blocked</em></span></a>
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    in a call to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code>, unblocks
                    all of those fibers.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    This is why a waiting fiber must <span class="emphasis"><em>also</em></span> check
                    for the desired program state using a mechanism external to the
                    <code class="computeroutput">condition_variable_any</code>, and retry the wait until that state is
                    reached. A fiber waiting on a <code class="computeroutput">condition_variable_any</code> might well
                    wake up a number of times before the desired state is reached.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_any_wait_bridgehead"></a>
  <span><a name="condition_variable_any_wait"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_any_wait">Templated
              member function <code class="computeroutput">wait</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting">template&lt; typename LockType &gt;
    void <span class="identifier">wait</span><span class="special">(</span> LockType <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> LockType <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber, and either no other fiber is currently
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    or the execution of the <a href="http://en.cppreference.com/w/cpp/thread/unique_lock/mutex" target="_top"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                    member function on the <code class="computeroutput"><span class="identifier">lk</span></code>
                    objects supplied in the calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                    in all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                    as <code class="computeroutput"><span class="identifier">lk</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                    for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber.
                    The fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                    or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>.
                    When the fiber is unblocked (for whatever reason), the lock is
                    reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                    reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with
                    an exception. The member function accepting <code class="computeroutput"><span class="identifier">pred</span></code>
                    is shorthand for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
                  </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                    an error occurs, <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    if the wait was interrupted by a call to <a class="link" href="../../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
                    the <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber
                    of execution.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    The Precondition is a bit dense. It merely states that all the
                    fibers concurrently calling <code class="computeroutput"><span class="identifier">wait</span></code>
                    on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    must wait on <code class="computeroutput"><span class="identifier">lk</span></code>
                    objects governing the <span class="emphasis"><em>same</em></span> <a class="link" href="pooled_fixedsize.html#class_mutex"> <code class="computeroutput">mutex</code></a>.
                    Three distinct objects are involved in any <code class="computeroutput">condition_variable_any::wait()</code> call:
                    the <code class="computeroutput">condition_variable_any</code> itself, the <code class="computeroutput"><span class="identifier">mutex</span></code>
                    coordinating access between fibers and a local lock object (e.g.
                    <a href="http://en.cppreference.com/w/cpp/thread/unique_lock" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>). In general,
                    you can partition the lifespan of a given <code class="computeroutput">condition_variable_any</code> instance
                    into periods with one or more fibers waiting on it, separated
                    by periods when no fibers are waiting on it. When more than one
                    fiber is waiting on that <code class="computeroutput">condition_variable_any</code>, all must pass
                    lock objects referencing the <span class="emphasis"><em>same</em></span> <code class="computeroutput"><span class="identifier">mutex</span></code> instance.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_any_wait_until_bridgehead"></a>
  <span><a name="condition_variable_any_wait_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_any_wait_until">Templated
              member function <code class="computeroutput">wait_until</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span> LockType <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                      <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> LockType <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                 <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span>
                 <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber, and either no other fiber is currently
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the
                    calls to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code> in
                    all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                    as <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code>
                    for this call to <code class="computeroutput"><span class="identifier">wait_until</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber.
                    The fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                    or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                    when the system time would be equal to or later than the specified
                    <code class="computeroutput"><span class="identifier">abs_time</span></code>. When
                    the fiber is unblocked (for whatever reason), the lock is reacquired
                    by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait_until</span></code> returns. The lock
                    is also reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with
                    an exception. The member function accepting <code class="computeroutput"><span class="identifier">pred</span></code>
                    is shorthand for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> <span class="special">==</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="special">)</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                    That is, even if <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code> times out, it can still return
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">pred</span><span class="special">()</span></code>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> at
                    that time.
                  </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                    an error occurs, <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    if the wait was interrupted by a call to <a class="link" href="../../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
                    the <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber
                    of execution or timeout-related exceptions.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The overload without <code class="computeroutput"><span class="identifier">pred</span></code>
                    returns <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                    if awakened by <code class="computeroutput"><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">notify_all</span><span class="special">()</span></code>, or <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if awakened because the system time is past <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The overload accepting <code class="computeroutput"><span class="identifier">pred</span></code>
                    returns <code class="computeroutput"><span class="keyword">false</span></code> if
                    the call is returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code> was reached and the
                    predicate returns <code class="computeroutput"><span class="keyword">false</span></code>,
                    <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    See <span class="bold"><strong>Note</strong></span> for <a class="link" href="pooled_fixedsize.html#condition_variable_any_wait"> <code class="computeroutput">condition_variable_any::wait()</code></a>.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_any_wait_for_bridgehead"></a>
  <span><a name="condition_variable_any_wait_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_any_wait_for">Templated
              member function <code class="computeroutput">wait_for</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span> LockType <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> typename LockType, typename <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> LockType <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
               <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span>
               <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber, and either no other fiber is currently
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the
                    calls to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code> in
                    all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                    as <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code>
                    for this call to <code class="computeroutput"><span class="identifier">wait_for</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber.
                    The fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                    or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                    when a time interval equal to or greater than the specified
                    <code class="computeroutput"><span class="identifier">rel_time</span></code> has
                    elapsed. When the fiber is unblocked (for whatever reason), the
                    lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                    reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with
                    an exception. The <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code> member function accepting
                    <code class="computeroutput"><span class="identifier">pred</span></code> is shorthand
                    for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> <span class="special">==</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                    (except of course that <code class="computeroutput"><span class="identifier">rel_time</span></code>
                    is adjusted for each iteration). The point is that, even if
                    <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code>
                    times out, it can still return <code class="computeroutput"><span class="keyword">true</span></code>
                    if <code class="computeroutput"><span class="identifier">pred</span><span class="special">()</span></code>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> at
                    that time.
                  </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                    an error occurs, <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    if the wait was interrupted by a call to <a class="link" href="../../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
                    the <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber
                    of execution or timeout-related exceptions.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The overload without <code class="computeroutput"><span class="identifier">pred</span></code>
                    returns <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                    if awakened by <code class="computeroutput"><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">notify_all</span><span class="special">()</span></code>, or <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if awakened because at least <code class="computeroutput"><span class="identifier">rel_time</span></code>
                    has elapsed.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The overload accepting <code class="computeroutput"><span class="identifier">pred</span></code>
                    returns <code class="computeroutput"><span class="keyword">false</span></code> if
                    the call is returning because at least <code class="computeroutput"><span class="identifier">rel_time</span></code>
                    has elapsed and the predicate returns <code class="computeroutput"><span class="keyword">false</span></code>,
                    <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    See <span class="bold"><strong>Note</strong></span> for <a class="link" href="pooled_fixedsize.html#condition_variable_any_wait"> <code class="computeroutput">condition_variable_any::wait()</code></a>.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="class_condition_variable_bridgehead"></a>
  <span><a name="class_condition_variable"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_condition_variable">Class
              <code class="computeroutput">condition_variable</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">condition_variable</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> condition_variable <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    condition_variable<span class="special">();</span>
    <span class="special">~</span>condition_variable<span class="special">();</span>

    condition_variable<span class="special">(</span> condition_variable <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    condition_variable <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> condition_variable <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    void <span class="identifier">wait</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;,</span> <span class="identifier">Pred</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;,</span>
                          <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;,</span>
                     <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;,</span>
                     <span class="identifier">Pred</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;,</span>
                        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;,</span>
                   <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;,</span>
                   <span class="identifier">Pred</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h7"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.constructor0"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.constructor0">Constructor</a>
            </h7><pre class="programlisting">condition_variable<span class="special">()</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Creates the object.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.h8"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.destructor0"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.conditions.destructor0">Destructor</a>
            </h7><pre class="programlisting"><span class="special">~</span>condition_variable<span class="special">()</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    All fibers waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                    to <code class="computeroutput"><span class="identifier">notify_one</span></code>
                    or <code class="computeroutput"><span class="identifier">notify_all</span></code>
                    (though the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code> need
                    not have returned).
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Destroys the object.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_notify_one_bridgehead"></a>
  <span><a name="condition_variable_notify_one"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_notify_one">Member
              function <code class="computeroutput">notify_one</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If any fibers are currently <a class="link" href="../../overview.html#blocking"><span class="emphasis"><em>blocked</em></span></a>
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    in a call to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code>, unblocks
                    one of those fibers.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    It is arbitrary which waiting fiber is resumed.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_notify_all_bridgehead"></a>
  <span><a name="condition_variable_notify_all"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_notify_all">Member
              function <code class="computeroutput">notify_all</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If any fibers are currently <a class="link" href="../../overview.html#blocking"><span class="emphasis"><em>blocked</em></span></a>
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    in a call to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code>, unblocks
                    all of those fibers.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    This is why a waiting fiber must <span class="emphasis"><em>also</em></span> check
                    for the desired program state using a mechanism external to the
                    <code class="computeroutput">condition_variable</code>, and retry the wait until that state is reached.
                    A fiber waiting on a <code class="computeroutput">condition_variable</code> might well wake up a number
                    of times before the desired state is reached.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_wait_bridgehead"></a>
  <span><a name="condition_variable_wait"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_wait">Templated
              member function <code class="computeroutput">wait</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting">void <span class="identifier">wait</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber, and either no other fiber is currently
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    or the execution of the <a href="http://en.cppreference.com/w/cpp/thread/unique_lock/mutex" target="_top"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                    member function on the <code class="computeroutput"><span class="identifier">lk</span></code>
                    objects supplied in the calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                    in all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                    as <code class="computeroutput"><span class="identifier">lk</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code>
                    for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber.
                    The fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                    or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>.
                    When the fiber is unblocked (for whatever reason), the lock is
                    reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                    reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with
                    an exception. The member function accepting <code class="computeroutput"><span class="identifier">pred</span></code>
                    is shorthand for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
                  </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                    an error occurs, <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    if the wait was interrupted by a call to <a class="link" href="../../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
                    the <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber
                    of execution.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    The Precondition is a bit dense. It merely states that all the
                    fibers concurrently calling <code class="computeroutput"><span class="identifier">wait</span></code>
                    on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    must wait on <code class="computeroutput"><span class="identifier">lk</span></code>
                    objects governing the <span class="emphasis"><em>same</em></span> <a class="link" href="pooled_fixedsize.html#class_mutex"> <code class="computeroutput">mutex</code></a>.
                    Three distinct objects are involved in any <code class="computeroutput">condition_variable::wait()</code> call:
                    the <code class="computeroutput">condition_variable</code> itself, the <code class="computeroutput"><span class="identifier">mutex</span></code>
                    coordinating access between fibers and a local lock object (e.g.
                    <a href="http://en.cppreference.com/w/cpp/thread/unique_lock" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>). In general,
                    you can partition the lifespan of a given <code class="computeroutput">condition_variable</code> instance
                    into periods with one or more fibers waiting on it, separated
                    by periods when no fibers are waiting on it. When more than one
                    fiber is waiting on that <code class="computeroutput">condition_variable</code>, all must pass lock
                    objects referencing the <span class="emphasis"><em>same</em></span> <code class="computeroutput"><span class="identifier">mutex</span></code> instance.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_wait_until_bridgehead"></a>
  <span><a name="condition_variable_wait_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_wait_until">Templated
              member function <code class="computeroutput">wait_until</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">cv_status</span> <span class="identifier">wait_until</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                      <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">wait_until</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                 <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span>
                 <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber, and either no other fiber is currently
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the
                    calls to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code> in
                    all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                    as <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code>
                    for this call to <code class="computeroutput"><span class="identifier">wait_until</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber.
                    The fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                    or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                    when the system time would be equal to or later than the specified
                    <code class="computeroutput"><span class="identifier">abs_time</span></code>. When
                    the fiber is unblocked (for whatever reason), the lock is reacquired
                    by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait_until</span></code> returns. The lock
                    is also reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with
                    an exception. The member function accepting <code class="computeroutput"><span class="identifier">pred</span></code>
                    is shorthand for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> <span class="special">==</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">abs_time</span><span class="special">)</span> <span class="special">)</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                    That is, even if <code class="computeroutput"><span class="identifier">wait_until</span><span class="special">()</span></code> times out, it can still return
                    <code class="computeroutput"><span class="keyword">true</span></code> if <code class="computeroutput"><span class="identifier">pred</span><span class="special">()</span></code>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> at
                    that time.
                  </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                    an error occurs, <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    if the wait was interrupted by a call to <a class="link" href="../../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
                    the <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber
                    of execution or timeout-related exceptions.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The overload without <code class="computeroutput"><span class="identifier">pred</span></code>
                    returns <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                    if awakened by <code class="computeroutput"><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">notify_all</span><span class="special">()</span></code>, or <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if awakened because the system time is past <code class="computeroutput"><span class="identifier">abs_time</span></code>.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The overload accepting <code class="computeroutput"><span class="identifier">pred</span></code>
                    returns <code class="computeroutput"><span class="keyword">false</span></code> if
                    the call is returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code> was reached and the
                    predicate returns <code class="computeroutput"><span class="keyword">false</span></code>,
                    <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    See <span class="bold"><strong>Note</strong></span> for <a class="link" href="pooled_fixedsize.html#condition_variable_wait"> <code class="computeroutput">condition_variable::wait()</code></a>.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="condition_variable_wait_for_bridgehead"></a>
  <span><a name="condition_variable_wait_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#condition_variable_wait_for">Templated
              member function <code class="computeroutput">wait_for</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">cv_status</span> <span class="identifier">wait_for</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
                    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> typename <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Pred</span> <span class="special">&gt;</span>
<span class="keyword">bool</span> <span class="identifier">wait_for</span><span class="special">(</span> std::unique_lock&lt; mutex &gt; <span class="special">&amp;</span> <span class="identifier">lk</span><span class="special">,</span>
               <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span>
               <span class="identifier">Pred</span> <span class="identifier">pred</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber, and either no other fiber is currently
                    waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                    or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lk</span></code> objects supplied in the
                    calls to <code class="computeroutput"><span class="identifier">wait</span></code>,
                    <code class="computeroutput"><span class="identifier">wait_for</span></code> or
                    <code class="computeroutput"><span class="identifier">wait_until</span></code> in
                    all the fibers currently waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> would return the same value
                    as <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">mutex</span><span class="special">()</span></code>
                    for this call to <code class="computeroutput"><span class="identifier">wait_for</span></code>.
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                    Atomically call <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current fiber.
                    The fiber will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                    or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                    when a time interval equal to or greater than the specified
                    <code class="computeroutput"><span class="identifier">rel_time</span></code> has
                    elapsed. When the fiber is unblocked (for whatever reason), the
                    lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                    reacquired by invoking <code class="computeroutput"><span class="identifier">lk</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with
                    an exception. The <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code> member function accepting
                    <code class="computeroutput"><span class="identifier">pred</span></code> is shorthand
                    for:
</p>
<pre class="programlisting"><span class="keyword">while</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">pred</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span> <span class="special">==</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">rel_time</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
                    (except of course that <code class="computeroutput"><span class="identifier">rel_time</span></code>
                    is adjusted for each iteration). The point is that, even if
                    <code class="computeroutput"><span class="identifier">wait_for</span><span class="special">()</span></code>
                    times out, it can still return <code class="computeroutput"><span class="keyword">true</span></code>
                    if <code class="computeroutput"><span class="identifier">pred</span><span class="special">()</span></code>
                    returns <code class="computeroutput"><span class="keyword">true</span></code> at
                    that time.
                  </p>
</dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">lk</span></code> is locked
                    by the current fiber.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                    an error occurs, <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    if the wait was interrupted by a call to <a class="link" href="../../fiber_mgmt/fiber.html#fiber_interrupt"> <code class="computeroutput">fiber::interrupt()</code></a> on
                    the <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> object associated with the current fiber
                    of execution or timeout-related exceptions.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The overload without <code class="computeroutput"><span class="identifier">pred</span></code>
                    returns <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">no_timeout</span></code>
                    if awakened by <code class="computeroutput"><span class="identifier">notify_one</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">notify_all</span><span class="special">()</span></code>, or <code class="computeroutput"><span class="identifier">cv_status</span><span class="special">::</span><span class="identifier">timeout</span></code>
                    if awakened because at least <code class="computeroutput"><span class="identifier">rel_time</span></code>
                    has elapsed.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    The overload accepting <code class="computeroutput"><span class="identifier">pred</span></code>
                    returns <code class="computeroutput"><span class="keyword">false</span></code> if
                    the call is returning because at least <code class="computeroutput"><span class="identifier">rel_time</span></code>
                    has elapsed and the predicate returns <code class="computeroutput"><span class="keyword">false</span></code>,
                    <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    See <span class="bold"><strong>Note</strong></span> for <a class="link" href="pooled_fixedsize.html#condition_variable_wait"> <code class="computeroutput">condition_variable::wait()</code></a>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers" title="Barriers">Barriers</a>
</h6></div></div></div>
<p>
              A barrier is a concept also known as a <span class="emphasis"><em>rendezvous</em></span>,
              it is a synchronization point between multiple contexts of execution
              (fibers). The barrier is configured for a particular number of fibers
              (<code class="computeroutput"><span class="identifier">n</span></code>), and as fibers
              reach the barrier they must wait until all <code class="computeroutput"><span class="identifier">n</span></code>
              fibers have arrived. Once the <code class="computeroutput"><span class="identifier">n</span></code>-th
              fiber has reached the barrier, all the waiting fibers can proceed,
              and the barrier is reset.
            </p>
<p>
              The fact that the barrier automatically resets is significant. Consider
              a case in which you launch some number of fibers and want to wait only
              until the first of them has completed. You might be tempted to use
              a <code class="computeroutput"><span class="identifier">barrier</span><span class="special">(</span><span class="number">2</span><span class="special">)</span></code> as
              the synchronization mechanism, making each new fiber call its <a class="link" href="pooled_fixedsize.html#barrier_wait"> <code class="computeroutput">barrier::wait()</code></a> method,
              then calling <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
              in the launching fiber to wait until the first other fiber completes.
            </p>
<p>
              That will in fact unblock the launching fiber. The unfortunate part
              is that it will continue blocking the <span class="emphasis"><em>remaining</em></span>
              fibers.
            </p>
<p>
              Consider the following scenario:
            </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                  Fiber <span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> launches fibers A, B, C and D, then calls
                  <code class="computeroutput"><span class="identifier">barrier</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>.
                </li>
<li class="listitem">
                  Fiber C finishes first and likewise calls <code class="computeroutput"><span class="identifier">barrier</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>.
                </li>
<li class="listitem">
                  Fiber <span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> is unblocked, as desired.
                </li>
<li class="listitem">
                  Fiber B calls <code class="computeroutput"><span class="identifier">barrier</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>. Fiber B is <span class="emphasis"><em>blocked!</em></span>
                </li>
<li class="listitem">
                  Fiber A calls <code class="computeroutput"><span class="identifier">barrier</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>. Fibers A and B are unblocked.
                </li>
<li class="listitem">
                  Fiber D calls <code class="computeroutput"><span class="identifier">barrier</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>. Fiber D is blocked indefinitely.
                </li>
</ol></div>
<p>
              (See also <a class="link" href="pooled_fixedsize.html#wait_first_simple_section">when_any, simple
              completion</a>.)
            </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                It is unwise to tie the lifespan of a barrier to any one of its participating
                fibers. Although conceptually all waiting fibers awaken <span class="quote">&#8220;<span class="quote">simultaneously,</span>&#8221;</span>
                because of the nature of fibers, in practice they will awaken one
                by one in indeterminate order.<sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers.f0" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers.f0" class="footnote">2</a>]</sup> The rest of the waiting fibers will still be blocked
                in <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>,
                which must, before returning, access data members in the barrier
                object.
              </p></td></tr>
</table></div>
<p>
              </p>
<h5>
<a name="class_barrier_bridgehead"></a>
  <span><a name="class_barrier"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_barrier">Class <code class="computeroutput">barrier</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">barrier</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">barrier</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">explicit</span> <span class="identifier">barrier</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">);</span>

    <span class="identifier">barrier</span><span class="special">(</span> <span class="identifier">barrier</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">barrier</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">barrier</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">bool</span> <span class="identifier">wait</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
              Instances of <a class="link" href="pooled_fixedsize.html#class_barrier"> <code class="computeroutput">barrier</code></a> are not copyable or movable.
            </p>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers.h0"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers.constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers.constructor">Constructor</a>
            </h7><pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">barrier</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">initial</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Construct a barrier for <code class="computeroutput"><span class="identifier">initial</span></code>
                    fibers.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>invalid_argument</strong></span>: if <code class="computeroutput"><span class="identifier">initial</span></code> is zero.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="barrier_wait_bridgehead"></a>
  <span><a name="barrier_wait"></a></span>
  <a class="link" href="pooled_fixedsize.html#barrier_wait">Member function <code class="computeroutput">wait</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Block until <code class="computeroutput"><span class="identifier">initial</span></code>
                    fibers have called <code class="computeroutput"><span class="identifier">wait</span></code>
                    on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    When the <code class="computeroutput"><span class="identifier">initial</span></code>-th
                    fiber calls <code class="computeroutput"><span class="identifier">wait</span></code>,
                    all waiting fibers are unblocked, and the barrier is reset.
                  </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="keyword">true</span></code> for exactly
                    one fiber from each batch of waiting fibers, <code class="computeroutput"><span class="keyword">false</span></code>
                    otherwise.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code>
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
                    is one of the predefined <a class="link" href="../../fiber_mgmt.html#interruption"><span class="emphasis"><em>interruption-points</em></span></a>.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels" title="Channels">Channels</a>
</h6></div></div></div>
<p>
              <span class="bold"><strong>Boost.Fiber</strong></span> provides a bounded and
              a unbounded channel suitable to synchonize fibers via message passing.
            </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">channel_t</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">send</span><span class="special">(</span> <span class="identifier">channel_t</span> <span class="special">&amp;</span> <span class="identifier">channel</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">for</span> <span class="special">(</span> <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">5</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">channel</span><span class="special">.</span><span class="identifier">push</span><span class="special">(</span> <span class="identifier">i</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">channel</span><span class="special">.</span><span class="identifier">close</span><span class="special">();</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">recv</span><span class="special">(</span> <span class="identifier">channel_t</span> <span class="special">&amp;</span> <span class="identifier">channel</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">i</span><span class="special">;</span>
    <span class="keyword">while</span> <span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span><span class="special">::</span><span class="identifier">success</span> <span class="special">==</span> <span class="identifier">channel</span><span class="special">.</span><span class="identifier">pop</span><span class="special">(</span><span class="identifier">i</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"received "</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">}</span>

<span class="identifier">channel_t</span> <span class="identifier">channel</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span> <span class="identifier">f1</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span> <span class="identifier">send</span><span class="special">,</span> <span class="identifier">ref</span><span class="special">(</span> <span class="identifier">channel</span><span class="special">)</span> <span class="special">)</span> <span class="special">);</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span> <span class="identifier">f2</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span> <span class="identifier">recv</span><span class="special">,</span> <span class="identifier">ref</span><span class="special">(</span> <span class="identifier">channel</span><span class="special">)</span> <span class="special">)</span> <span class="special">);</span>

<span class="identifier">f1</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
<span class="identifier">f2</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
</pre>
<a name="class_channel_op_status"></a><h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.h0"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.enumeration__code__phrase_role__identifier__channel_op_status__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.enumeration__code__phrase_role__identifier__channel_op_status__phrase___code_">Enumeration
              <code class="computeroutput"><span class="identifier">channel_op_status</span></code></a>
            </h7><p>
              channel operations return the state of the channel.
            </p>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">channel_op_status</span> <span class="special">{</span>
    <span class="identifier">success</span><span class="special">,</span>
    <span class="identifier">empty</span><span class="special">,</span>
    <span class="identifier">full</span><span class="special">,</span>
    <span class="identifier">closed</span><span class="special">,</span>
    <span class="identifier">timeout</span>
<span class="special">};</span>
</pre>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.h1"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__success__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__success__phrase___code_"><code class="computeroutput"><span class="identifier">success</span></code></a>
            </h7><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Operation was successful.
                  </p></dd>
</dl>
</div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.h2"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__empty__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__empty__phrase___code_"><code class="computeroutput"><span class="identifier">empty</span></code></a>
            </h7><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    channel is empty, operation failed.
                  </p></dd>
</dl>
</div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.h3"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__full__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__full__phrase___code_"><code class="computeroutput"><span class="identifier">full</span></code></a>
            </h7><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    channel is full, operation failed.
                  </p></dd>
</dl>
</div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.h4"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__closed__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__closed__phrase___code_"><code class="computeroutput"><span class="identifier">closed</span></code></a>
            </h7><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    channel is closed, operation failed.
                  </p></dd>
</dl>
</div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.h5"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__timeout__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels._code__phrase_role__identifier__timeout__phrase___code_"><code class="computeroutput"><span class="identifier">timeout</span></code></a>
            </h7><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    The operation did not become ready before specified timeout elapsed.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="class_unbounded_channel_bridgehead"></a>
  <span><a name="class_unbounded_channel"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_unbounded_channel">Template
              <code class="computeroutput">unbounded_channel&lt;&gt;</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">unbounded_channel</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="special">=</span> <a href="http://en.cppreference.com/w/cpp/memory/allocator" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span></code></a> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">unbounded_channel</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">T</span>   <span class="identifier">value_type</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">unbounded_channel</span><span class="special">(</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">alloc</span> <span class="special">=</span> <span class="identifier">Allocator</span><span class="special">()</span> <span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">unbounded_channel</span><span class="special">(</span> <span class="identifier">unbounded_channel</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">unbounded_channel</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">unbounded_channel</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">close</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">);</span>

    <span class="identifier">channel_op_status</span> <span class="identifier">pop</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
    <span class="identifier">value_type</span> <span class="identifier">value_pop</span><span class="special">();</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">try_pop</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">pop_wait_for</span><span class="special">(</span>
        <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">pop_wait_until</span><span class="special">(</span>
        <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.h6"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.constructor">Constructor</a>
            </h7><pre class="programlisting"><span class="keyword">explicit</span> <span class="identifier">unbounded_channel</span><span class="special">(</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">alloc</span> <span class="special">=</span> <span class="identifier">Allocator</span><span class="special">()</span> <span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an object of class <code class="computeroutput"><span class="identifier">unbounded_channel</span></code>.
                    Internal nodes are allocated using <code class="computeroutput"><span class="identifier">alloc</span></code>
                    - C++11-allocators are supported.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">See also:</span></dt>
<dd><p>
                    <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> concept,
                    <a href="http://en.cppreference.com/w/cpp/memory/allocator" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span>
                    <span class="identifier">T</span> <span class="special">&gt;</span></code></a>
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="unbounded_channel_close_bridgehead"></a>
  <span><a name="unbounded_channel_close"></a></span>
  <a class="link" href="pooled_fixedsize.html#unbounded_channel_close">Member
              function <code class="computeroutput">close</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">close</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Deactivates the channel. No values can be put after calling
                    <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">close</span><span class="special">()</span></code>.
                    Fibers blocked in <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_until</span><span class="special">()</span></code> will return <code class="computeroutput"><span class="identifier">closed</span></code>.
                    Fibers blocked in <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span></code> will receive an exception.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>
                    is like closing a pipe. It informs waiting consumers that no
                    more values will arrive.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="unbounded_channel_push_bridgehead"></a>
  <span><a name="unbounded_channel_push"></a></span>
  <a class="link" href="pooled_fixedsize.html#unbounded_channel_push">Member
              function <code class="computeroutput">push</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
<span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If channel is closed, returns <code class="computeroutput"><span class="identifier">closed</span></code>.
                    Otherwise enqueues the value in the channel, wakes up a fiber
                    blocked on <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_until</span><span class="special">()</span></code> and returns <code class="computeroutput"><span class="identifier">success</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Exceptions thrown by memory allocation and copying or moving
                    <code class="computeroutput"><span class="identifier">va</span></code>.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="unbounded_channel_pop_bridgehead"></a>
  <span><a name="unbounded_channel_pop"></a></span>
  <a class="link" href="pooled_fixedsize.html#unbounded_channel_pop">Member
              function <code class="computeroutput">pop</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">channel_op_status</span> <span class="identifier">pop</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Dequeues a value from the channel. If the channel is empty, the
                    fiber gets suspended until at least one new item is <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>ed
                    (return value <code class="computeroutput"><span class="identifier">success</span></code>
                    and <code class="computeroutput"><span class="identifier">va</span></code> contains
                    dequeued value) or the channel gets <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>).
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="unbounded_channel_value_pop_bridgehead"></a>
  <span><a name="unbounded_channel_value_pop"></a></span>
  <a class="link" href="pooled_fixedsize.html#unbounded_channel_value_pop">Member
              function <code class="computeroutput">value_pop</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">value_type</span> <span class="identifier">value_pop</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Dequeues a value from the channel. If the channel is empty, the
                    fiber gets suspended until at least one new item is <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>ed
                    or the channel gets <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (which throws an exception).
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                    <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is closed or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                  </p></dd>
<dt><span class="term">Error conditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">errc</span><span class="special">::</span><span class="identifier">operation_not_permitted</span></code>
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="unbounded_channel_try_pop_bridgehead"></a>
  <span><a name="unbounded_channel_try_pop"></a></span>
  <a class="link" href="pooled_fixedsize.html#unbounded_channel_try_pop">Member
              function <code class="computeroutput">try_pop</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">channel_op_status</span> <span class="identifier">try_pop</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If channel is empty, returns <code class="computeroutput"><span class="identifier">empty</span></code>.
                    If channel is closed, returns <code class="computeroutput"><span class="identifier">closed</span></code>.
                    Otherwise it returns <code class="computeroutput"><span class="identifier">success</span></code>
                    and <code class="computeroutput"><span class="identifier">va</span></code> contains
                    the dequeued value.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Exceptions thrown by copy- or move-operations.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="unbounded_channel_pop_wait_for_bridgehead"></a>
  <span><a name="unbounded_channel_pop_wait_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#unbounded_channel_pop_wait_for">Member
              function <code class="computeroutput">pop_wait_for</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">channel_op_status</span> <span class="identifier">pop_wait_for</span><span class="special">(</span>
    <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Accepts <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code> and internally computes
                    a timeout time as (system time + <code class="computeroutput"><span class="identifier">timeout_duration</span></code>).
                    If channel is not empty, immediately dequeues a value from the
                    channel. Otherwise the fiber gets suspended until at least one
                    new item is <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>ed (return value <code class="computeroutput"><span class="identifier">success</span></code> and <code class="computeroutput"><span class="identifier">va</span></code>
                    contains dequeued value), or the channel gets <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>), or the system time
                    reaches the computed timeout time (return value <code class="computeroutput"><span class="identifier">timeout</span></code>).
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    or timeout-related exceptions.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="unbounded_channel_pop_wait_until_bridgehead"></a>
  <span><a name="unbounded_channel_pop_wait_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#unbounded_channel_pop_wait_until">Member
              function <code class="computeroutput">pop_wait_until</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">channel_op_status</span> <span class="identifier">pop_wait_until</span><span class="special">(</span>
    <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Accepts a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span>
                    <span class="special">&gt;</span></code>. If channel is not
                    empty, immediately dequeues a value from the channel. Otherwise
                    the fiber gets suspended until at least one new item is <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>ed
                    (return value <code class="computeroutput"><span class="identifier">success</span></code>
                    and <code class="computeroutput"><span class="identifier">va</span></code> contains
                    dequeued value), or the channel gets <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>), or the system time
                    reaches the passed <code class="computeroutput"><span class="identifier">time_point</span></code>
                    (return value <code class="computeroutput"><span class="identifier">timeout</span></code>).
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    or timeout-related exceptions.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="class_bounded_channel_bridgehead"></a>
  <span><a name="class_bounded_channel"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_bounded_channel">Template
              <code class="computeroutput">bounded_channel&lt;&gt;</code></a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">bounded_channel</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="special">=</span> <a href="http://en.cppreference.com/w/cpp/memory/allocator" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span></code></a> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">bounded_channel</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">T</span>   <span class="identifier">value_type</span><span class="special">;</span>

    <span class="identifier">bounded_channel</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">wm</span><span class="special">,</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">alloc</span> <span class="special">=</span> <span class="identifier">Allocator</span><span class="special">()</span> <span class="special">);</span>
    <span class="identifier">bounded_channel</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">hwm</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">lwm</span><span class="special">,</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">alloc</span> <span class="special">=</span> <span class="identifier">Allocator</span><span class="special">()</span> <span class="special">);</span>

    <span class="identifier">bounded_channel</span><span class="special">(</span> <span class="identifier">bounded_channel</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">bounded_channel</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">bounded_channel</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">upper_bound</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">lower_bound</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">close</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">push_wait_for</span><span class="special">(</span>
        <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">push_wait_for</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">push_wait_until</span><span class="special">(</span>
        <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">push_wait_until</span><span class="special">(</span>
        <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">try_push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">try_push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">);</span>

    <span class="identifier">channel_op_status</span> <span class="identifier">pop</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
    <span class="identifier">value_type</span> <span class="identifier">value_pop</span><span class="special">();</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">pop_wait_for</span><span class="special">(</span>
        <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">pop_wait_until</span><span class="special">(</span>
        <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
    <span class="identifier">channel_op_status</span> <span class="identifier">try_pop</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.h7"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.constructor0"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.channels.constructor0">Constructor</a>
            </h7><pre class="programlisting"><span class="identifier">bounded_channel</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">wm</span><span class="special">,</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">alloc</span> <span class="special">=</span> <span class="identifier">Allocator</span><span class="special">()</span> <span class="special">);</span>
<span class="identifier">bounded_channel</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">hwm</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">lwm</span><span class="special">,</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">alloc</span> <span class="special">=</span> <span class="identifier">Allocator</span><span class="special">()</span> <span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">hwm</span> <span class="special">&gt;</span>
                    <span class="identifier">lwm</span></code>
                  </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Constructs an object of class <code class="computeroutput"><span class="identifier">bounded_channel</span></code>.
                    The constructor with two arguments constructs an object of class
                    <code class="computeroutput"><span class="identifier">bounded_channel</span></code>
                    with a high-watermark of <code class="computeroutput"><span class="identifier">hwm</span></code>
                    and a low-watermark of <code class="computeroutput"><span class="identifier">lwm</span></code>
                    items. The constructor with one <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span></code>
                    argument is effectively the same as <code class="computeroutput"><span class="identifier">bounded_channel</span><span class="special">(</span><span class="identifier">wm</span><span class="special">,</span> <span class="special">(</span><span class="identifier">wm</span><span class="special">-</span><span class="number">1</span><span class="special">),</span> <span class="identifier">alloc</span><span class="special">)</span></code>.
                    Internal nodes are allocated using <code class="computeroutput"><span class="identifier">alloc</span></code>
                    - C++11-allocators are supported.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code>
                  </p></dd>
<dt><span class="term">Error Conditions:</span></dt>
<dd><p>
                    <span class="bold"><strong>invalid_argument</strong></span>: if <code class="computeroutput"><span class="identifier">lwm</span> <span class="special">&gt;=</span>
                    <span class="identifier">hwm</span></code>.
                  </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                    Once the number of values in the channel reaches <code class="computeroutput"><span class="identifier">hwm</span></code>, any call to <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>,
                    <code class="computeroutput"><span class="identifier">push_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">push_wait_until</span><span class="special">()</span></code> will block until the number
                    of values in the channel is at most <code class="computeroutput"><span class="identifier">lwm</span></code>.
                    That is, if <code class="computeroutput"><span class="identifier">lwm</span> <span class="special">&lt;</span> <span class="special">(</span><span class="identifier">hwm</span><span class="special">-</span><span class="number">1</span><span class="special">)</span></code>,
                    the channel can be in a state in which <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">push_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">push_wait_until</span><span class="special">()</span></code> calls will block (channel is
                    full) even though the number of values in the channel is less
                    than <code class="computeroutput"><span class="identifier">hwm</span></code>.
                  </p></dd>
<dt><span class="term">See also:</span></dt>
<dd><p>
                    <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> concept,
                    <a href="http://en.cppreference.com/w/cpp/memory/allocator" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span>
                    <span class="identifier">T</span> <span class="special">&gt;</span></code></a>
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_upper_bound_bridgehead"></a>
  <span><a name="bounded_channel_upper_bound"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_upper_bound">Member
              function <code class="computeroutput">upper_bound</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">upper_bound</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    the high-watermark with which <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> was constructed.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_lower_bound_bridgehead"></a>
  <span><a name="bounded_channel_lower_bound"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_lower_bound">Member
              function <code class="computeroutput">lower_bound</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">lower_bound</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                    the low-watermark with which <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> was constructed.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_close_bridgehead"></a>
  <span><a name="bounded_channel_close"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_close">Member
              function <code class="computeroutput">close</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">close</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Deactivates the channel. No values can be put after calling
                    <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">close</span><span class="special">()</span></code>.
                    Fibers blocked in <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_until</span><span class="special">()</span></code> will return <code class="computeroutput"><span class="identifier">closed</span></code>.
                    Fibers blocked in <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span></code> will receive an exception.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Nothing.
                  </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>
                    is like closing a pipe. It informs waiting consumers that no
                    more values will arrive.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_push_bridgehead"></a>
  <span><a name="bounded_channel_push"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_push">Member
              function <code class="computeroutput">push</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
<span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If channel is closed, returns <code class="computeroutput"><span class="identifier">closed</span></code>.
                    If channel is not full, enqueues the value in the channel, wakes
                    up a fiber blocked on <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_until</span><span class="special">()</span></code> and returns <code class="computeroutput"><span class="identifier">success</span></code>.
                    Otherwise the calling fiber is suspended until the number of
                    values in the channel drops to <code class="computeroutput"><span class="identifier">lwm</span></code>
                    (return value <code class="computeroutput"><span class="identifier">success</span></code>)or
                    the channel is <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>).
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    or exceptions thrown by memory allocation and copying or moving
                    <code class="computeroutput"><span class="identifier">va</span></code>.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_push_wait_for_bridgehead"></a>
  <span><a name="bounded_channel_push_wait_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_push_wait_for">Member
              function <code class="computeroutput">push_wait_for</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">channel_op_status</span> <span class="identifier">push_wait_for</span><span class="special">(</span>
    <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">channel_op_status</span> <span class="identifier">push_wait_for</span><span class="special">(</span>
    <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Accepts <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code> and internally computes
                    a time_point as (system time + <code class="computeroutput"><span class="identifier">timeout_duration</span></code>).
                    If channel is closed, returns <code class="computeroutput"><span class="identifier">closed</span></code>.
                    If channel is not full, enqueues the value in the channel, wakes
                    up a fiber blocked on <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_until</span><span class="special">()</span></code> and returns <code class="computeroutput"><span class="identifier">success</span></code>.
                    Otherwise the calling fiber is suspended until the number of
                    values in the channel drops to <code class="computeroutput"><span class="identifier">lwm</span></code>
                    (return value <code class="computeroutput"><span class="identifier">success</span></code>),
                    the channel is <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>), or the system time
                    reaches the computed time_point (return value <code class="computeroutput"><span class="identifier">timeout</span></code>).
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>,
                    exceptions thrown by memory allocation and copying or moving
                    <code class="computeroutput"><span class="identifier">va</span></code> or timeout-related
                    exceptions.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_push_wait_until_bridgehead"></a>
  <span><a name="bounded_channel_push_wait_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_push_wait_until">Member
              function <code class="computeroutput">push_wait_until</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">channel_op_status</span> <span class="identifier">push_wait_until</span><span class="special">(</span>
    <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">channel_op_status</span> <span class="identifier">push_wait_until</span><span class="special">(</span>
    <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Accepts an absolute <code class="computeroutput"><span class="identifier">timeout_time</span></code>
                    in any supported time_point type. If channel is closed, returns
                    <code class="computeroutput"><span class="identifier">closed</span></code>. If channel
                    is not full, enqueues the value in the channel, wakes up a fiber
                    blocked on <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_until</span><span class="special">()</span></code> and returns <code class="computeroutput"><span class="identifier">success</span></code>.
                    Otherwise the calling fiber is suspended until the number of
                    values in the channel drops to <code class="computeroutput"><span class="identifier">lwm</span></code>
                    (return value <code class="computeroutput"><span class="identifier">success</span></code>),
                    the channel is <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>), or the system time
                    reaches the passed time_point (return value <code class="computeroutput"><span class="identifier">timeout</span></code>).
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    or exceptions thrown by memory allocation and copying or moving
                    <code class="computeroutput"><span class="identifier">va</span></code> or timeout-related
                    exceptions.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_try_push_bridgehead"></a>
  <span><a name="bounded_channel_try_push"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_try_push">Member
              function <code class="computeroutput">try_push</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">channel_op_status</span> <span class="identifier">try_push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
<span class="identifier">channel_op_status</span> <span class="identifier">try_push</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If channel is full, returns <code class="computeroutput"><span class="identifier">full</span></code>.
                    If channel is closed, returns <code class="computeroutput"><span class="identifier">closed</span></code>.
                    Otherwise enqueues the value in the channel, wakes up a fiber
                    blocked on <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span></code>, <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">pop_wait_until</span><span class="special">()</span></code> and returns <code class="computeroutput"><span class="identifier">success</span></code>.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Exceptions thrown by memory allocation and copying or moving
                    <code class="computeroutput"><span class="identifier">va</span></code>.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_pop_bridgehead"></a>
  <span><a name="bounded_channel_pop"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_pop">Member
              function <code class="computeroutput">pop</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">channel_op_status</span> <span class="identifier">pop</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Dequeues a value from the channel. If the channel is empty, the
                    fiber gets suspended until at least one new item is <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>ed
                    (return value <code class="computeroutput"><span class="identifier">success</span></code>
                    and <code class="computeroutput"><span class="identifier">va</span></code> contains
                    dequeued value) or the channel gets <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>). Once the number of
                    items remaining in the channel drops to <code class="computeroutput"><span class="identifier">lwm</span></code>,
                    any fibers blocked on <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">push_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">push_wait_until</span><span class="special">()</span></code> may resume.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_value_pop_bridgehead"></a>
  <span><a name="bounded_channel_value_pop"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_value_pop">Member
              function <code class="computeroutput">value_pop</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">value_type</span> <span class="identifier">value_pop</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Dequeues a value from the channel. If the channel is empty, the
                    fiber gets suspended until at least one new item is <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>ed
                    or the channel gets <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (which throws an exception).
                    Once the number of items remaining in the channel drops to <code class="computeroutput"><span class="identifier">lwm</span></code>, any fibers blocked on
                    <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>,
                    <code class="computeroutput"><span class="identifier">push_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">push_wait_until</span><span class="special">()</span></code> may resume.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                    <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                    is closed or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                  </p></dd>
<dt><span class="term">Error conditions:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">errc</span><span class="special">::</span><span class="identifier">operation_not_permitted</span></code>
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_try_pop_bridgehead"></a>
  <span><a name="bounded_channel_try_pop"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_try_pop">Member
              function <code class="computeroutput">try_pop</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="identifier">channel_op_status</span> <span class="identifier">try_pop</span><span class="special">(</span> <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    If channel is empty, returns <code class="computeroutput"><span class="identifier">empty</span></code>.
                    If channel is closed, returns <code class="computeroutput"><span class="identifier">closed</span></code>.
                    Otherwise it returns <code class="computeroutput"><span class="identifier">success</span></code>
                    and <code class="computeroutput"><span class="identifier">va</span></code> contains
                    the dequeued value. Once the number of items remaining in the
                    channel drops to <code class="computeroutput"><span class="identifier">lwm</span></code>,
                    any fibers blocked on <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">push_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">push_wait_until</span><span class="special">()</span></code> may resume.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    Exceptions thrown by copy- or move-operations.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_pop_wait_for_bridgehead"></a>
  <span><a name="bounded_channel_pop_wait_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_pop_wait_for">Member
              function <code class="computeroutput">pop_wait_for</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">channel_op_status</span> <span class="identifier">pop_wait_for</span><span class="special">(</span>
    <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Accepts <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span></code> and internally computes
                    a timeout time as (system time + <code class="computeroutput"><span class="identifier">timeout_duration</span></code>).
                    If channel is not empty, immediately dequeues a value from the
                    channel. Otherwise the fiber gets suspended until at least one
                    new item is <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>ed (return value <code class="computeroutput"><span class="identifier">success</span></code> and <code class="computeroutput"><span class="identifier">va</span></code>
                    contains dequeued value), or the channel gets <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>), or the system time
                    reaches the computed timeout time (return value <code class="computeroutput"><span class="identifier">timeout</span></code>). Once the number of
                    items remaining in the channel drops to <code class="computeroutput"><span class="identifier">lwm</span></code>,
                    any fibers blocked on <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">push_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">push_wait_until</span><span class="special">()</span></code> may resume.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    or timeout-related exceptions.
                  </p></dd>
</dl>
</div>
<p>
              </p>
<h5>
<a name="bounded_channel_pop_wait_until_bridgehead"></a>
  <span><a name="bounded_channel_pop_wait_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#bounded_channel_pop_wait_until">Member
              function <code class="computeroutput">pop_wait_until</code>()</a>
</h5>
<p>
            </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">channel_op_status</span> <span class="identifier">pop_wait_until</span><span class="special">(</span>
    <span class="identifier">value_type</span> <span class="special">&amp;</span> <span class="identifier">va</span><span class="special">,</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">)</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                    Accepts a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span>
                    <span class="special">&gt;</span></code>. If channel is not
                    empty, immediately dequeues a value from the channel. Otherwise
                    the fiber gets suspended until at least one new item is <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>ed
                    (return value <code class="computeroutput"><span class="identifier">success</span></code>
                    and <code class="computeroutput"><span class="identifier">va</span></code> contains
                    dequeued value), or the channel gets <code class="computeroutput"><span class="identifier">close</span><span class="special">()</span></code>d (return value <code class="computeroutput"><span class="identifier">closed</span></code>), or the system time
                    reaches the passed <code class="computeroutput"><span class="identifier">time_point</span></code>
                    (return value <code class="computeroutput"><span class="identifier">timeout</span></code>).
                    Once the number of items remaining in the channel drops to <code class="computeroutput"><span class="identifier">lwm</span></code>, any fibers blocked on
                    <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>,
                    <code class="computeroutput"><span class="identifier">push_wait_for</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">push_wait_until</span><span class="special">()</span></code> may resume.
                  </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                    <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                    or timeout-related exceptions.
                  </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures" title="Futures">Futures</a>
</h6></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future">Future</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise">Template
              <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code></a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task">Template
              <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code></a></span></dt>
</dl></div>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.h0"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.overview"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.overview">Overview</a>
            </h7><p>
              The futures library provides a means of handling asynchronous future
              values, whether those values are generated by another fiber, or on
              a single fiber in response to external stimuli, or on-demand.
            </p>
<p>
              This is done through the provision of four class templates: <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> and
              <a class="link" href="pooled_fixedsize.html#class_shared_future"> <code class="computeroutput">shared_future&lt;&gt;</code></a> which are used to retrieve
              the asynchronous results, and <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a> and <a class="link" href="pooled_fixedsize.html#class_packaged_task"> <code class="computeroutput">packaged_task&lt;&gt;</code></a> which
              are used to generate the asynchronous results.
            </p>
<p>
              An instance of <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> holds the one and only reference
              to a result. Ownership can be transferred between instances using the
              move constructor or move-assignment operator, but at most one instance
              holds a reference to a given asynchronous result. When the result is
              ready, it is returned from <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a> by rvalue-reference
              to allow the result to be moved or copied as appropriate for the type.
            </p>
<p>
              On the other hand, many instances of <a class="link" href="pooled_fixedsize.html#class_shared_future"> <code class="computeroutput">shared_future&lt;&gt;</code></a> may
              reference the same result. Instances can be freely copied and assigned,
              and <a class="link" href="pooled_fixedsize.html#shared_future_get"> <code class="computeroutput">shared_future::get()</code></a>
returns a <code class="computeroutput"><span class="keyword">const</span></code>
              reference so that multiple calls to <a class="link" href="pooled_fixedsize.html#shared_future_get"> <code class="computeroutput">shared_future::get()</code></a>
are
              safe. You can move an instance of <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> into an
              instance of <a class="link" href="pooled_fixedsize.html#class_shared_future"> <code class="computeroutput">shared_future&lt;&gt;</code></a>, thus transferring
              ownership of the associated asynchronous result, but not vice-versa.
            </p>
<p>
              <a class="link" href="pooled_fixedsize.html#fibers_async"> <code class="computeroutput">fibers::async()</code></a> is a simple way of running asynchronous
              tasks. A call to <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code> spawns a fiber and returns a <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> that
              will deliver the result of the fiber function.
            </p>
<h7><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.h1"></a>
              <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.creating_asynchronous_values"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.creating_asynchronous_values">Creating
              asynchronous values</a>
            </h7><p>
              You can set the value in a future with either a <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a> or
              a <a class="link" href="pooled_fixedsize.html#class_packaged_task"> <code class="computeroutput">packaged_task&lt;&gt;</code></a>. A <a class="link" href="pooled_fixedsize.html#class_packaged_task"> <code class="computeroutput">packaged_task&lt;&gt;</code></a> is
              a callable object with <code class="computeroutput"><span class="keyword">void</span></code>
              return that wraps a function or callable object returning the specified
              type. When the <a class="link" href="pooled_fixedsize.html#class_packaged_task"> <code class="computeroutput">packaged_task&lt;&gt;</code></a> is invoked,
              it invokes the contained function in turn, and populates a future with
              the contained function's return value. This is an answer to the perennial
              question: <span class="quote">&#8220;<span class="quote">How do I return a value from a fiber?</span>&#8221;</span> Package
              the function you wish to run as a <a class="link" href="pooled_fixedsize.html#class_packaged_task"> <code class="computeroutput">packaged_task&lt;&gt;</code></a> and
              pass the packaged task to the fiber constructor. The future retrieved
              from the packaged task can then be used to obtain the return value.
              If the function throws an exception, that is stored in the future in
              place of the return value.
            </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="number">42</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">()&gt;</span> <span class="identifier">pt</span><span class="special">(</span><span class="identifier">calculate_the_answer_to_life_the_universe_and_everything</span><span class="special">);</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">fi</span><span class="special">=</span><span class="identifier">pt</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">();</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">pt</span><span class="special">)).</span><span class="identifier">detach</span><span class="special">();</span> <span class="comment">// launch task on a fiber</span>

<span class="identifier">fi</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span> <span class="comment">// wait for it to finish</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(!</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get</span><span class="special">()==</span><span class="number">42</span><span class="special">);</span>
</pre>
<p>
              A <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a> is a bit more low level: it just provides
              explicit functions to store a value or an exception in the associated
              future. A promise can therefore be used where the value might come
              from more than one possible source.
            </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">pi</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">fi</span><span class="special">;</span>
<span class="identifier">fi</span><span class="special">=</span><span class="identifier">pi</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">();</span>

<span class="identifier">pi</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span><span class="number">42</span><span class="special">);</span>

<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">is_ready</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_value</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(!</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">has_exception</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">fi</span><span class="special">.</span><span class="identifier">get</span><span class="special">()==</span><span class="number">42</span><span class="special">);</span>
</pre>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future" title="Future">Future</a>
</h6></div></div></div>
<p>
                A future provides a mechanism to access the result of an asynchronous
                operation.
              </p>
<a name="shared_state"></a><h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h0"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.shared_state"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.shared_state">shared
                state</a>
              </h8><p>
                Behind a <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a> and its <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> lies
                an unspecified object called their <span class="emphasis"><em>shared state</em></span>.
                The shared state is what will actually hold the async result (or
                the exception).
              </p>
<p>
                The shared state is instantiated along with the <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a>.
              </p>
<p>
                Aside from its originating <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code>, a <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> holds
                a unique reference to a particular shared state. However, multiple
                <a class="link" href="pooled_fixedsize.html#class_shared_future"> <code class="computeroutput">shared_future&lt;&gt;</code></a> instances can reference the
                same underlying shared state.
              </p>
<p>
                As <a class="link" href="pooled_fixedsize.html#class_packaged_task"> <code class="computeroutput">packaged_task&lt;&gt;</code></a> and <a class="link" href="pooled_fixedsize.html#fibers_async"> <code class="computeroutput">fibers::async()</code></a> are
                implemented using <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a>, discussions of shared
                state apply to them as well.
              </p>
<a name="class_future_status"></a><h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h1"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.enumeration__code__phrase_role__identifier__future_status__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.enumeration__code__phrase_role__identifier__future_status__phrase___code_">Enumeration
                <code class="computeroutput"><span class="identifier">future_status</span></code></a>
              </h8><p>
                Timed wait-operations ( <a class="link" href="pooled_fixedsize.html#future_wait_for"> <code class="computeroutput">future::wait_for()</code></a> and <a class="link" href="pooled_fixedsize.html#future_wait_until"> <code class="computeroutput">future::wait_until()</code></a>)
                return the state of the future.
              </p>
<pre class="programlisting"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="identifier">future_status</span> <span class="special">{</span>
    <span class="identifier">ready</span><span class="special">,</span>
    <span class="identifier">timeout</span><span class="special">,</span>
    <span class="identifier">deferred</span>  <span class="comment">// not supported yet</span>
<span class="special">};</span>
</pre>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h2"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future._code__phrase_role__identifier__ready__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future._code__phrase_role__identifier__ready__phrase___code_"><code class="computeroutput"><span class="identifier">ready</span></code></a>
              </h8><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      The <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a> is ready.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h3"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future._code__phrase_role__identifier__timeout__phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future._code__phrase_role__identifier__timeout__phrase___code_"><code class="computeroutput"><span class="identifier">timeout</span></code></a>
              </h8><div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      The <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a> did not
                      become ready before timeout has passed.
                    </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                  Deferred futures are not supported.
                </p></td></tr>
</table></div>
<p>
                </p>
<h5>
<a name="class_future_bridgehead"></a>
  <span><a name="class_future"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_future">Template <code class="computeroutput">future&lt;&gt;</code></a>
</h5>
<p>
              </p>
<p>
                A <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> contains a <a class="link" href="pooled_fixedsize.html#shared_state">shared
                state</a> which is not shared with any other future.
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">future</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">future</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">future</span><span class="special">(</span> <span class="identifier">future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">future</span><span class="special">(</span> <span class="identifier">future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="special">~</span><span class="identifier">future</span><span class="special">();</span>

    <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">shared_future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">share</span><span class="special">();</span>

    <span class="identifier">R</span> <span class="identifier">get</span><span class="special">();</span>    <span class="comment">// member only of generic future template</span>
    <span class="identifier">R</span> <span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span>  <span class="comment">// member only of future&lt; R &amp; &gt; template specialization</span>
    <span class="keyword">void</span> <span class="identifier">get</span><span class="special">();</span> <span class="comment">// member only of future&lt; void &gt; template specialization</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">get_exception_ptr</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h4"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.default_constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.default_constructor">Default
                constructor</a>
              </h8><pre class="programlisting"><span class="identifier">future</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Creates a future with no <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a>. After construction <code class="computeroutput"><span class="keyword">false</span>
                      <span class="special">==</span> <span class="identifier">valid</span><span class="special">()</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h5"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.move_constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.move_constructor">Move
                constructor</a>
              </h8><pre class="programlisting"><span class="identifier">future</span><span class="special">(</span> <span class="identifier">future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Constructs a future with the <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> of other. After construction <code class="computeroutput"><span class="keyword">false</span>
                      <span class="special">==</span> <span class="identifier">other</span><span class="special">.</span><span class="identifier">valid</span><span class="special">()</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h6"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.destructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.destructor">Destructor</a>
              </h8><pre class="programlisting"><span class="special">~</span><span class="identifier">future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Destroys the future; ownership is abandoned.
                    </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                      <code class="computeroutput">~future()</code> does <span class="emphasis"><em>not</em></span> block the calling fiber.
                    </p></dd>
</dl>
</div>
<p>
                Consider a sequence such as:
              </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                    instantiate <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a>
                  </li>
<li class="listitem">
                    obtain its <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> via <a class="link" href="pooled_fixedsize.html#promise_get_future"> <code class="computeroutput">promise::get_future()</code></a>
                  </li>
<li class="listitem">
                    launch <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a>, capturing <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code>
                  </li>
<li class="listitem">
                    destroy <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>
                  </li>
<li class="listitem">
                    call <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a>
                  </li>
</ol></div>
<p>
                The final <code class="computeroutput"><span class="identifier">set_value</span><span class="special">()</span></code> call succeeds, but the value is
                silently discarded: no additional <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> can be obtained from that
                <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code>.
              </p>
<p>
                </p>
<h5>
<a name="future_operator_assign_bridgehead"></a>
  <span><a name="future_operator_assign"></a></span>
  <a class="link" href="pooled_fixedsize.html#future_operator_assign">Member
                function <code class="computeroutput">operator=</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Moves the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      of other to <code class="computeroutput"><span class="keyword">this</span></code>.
                      After the assignment, <code class="computeroutput"><span class="keyword">false</span>
                      <span class="special">==</span> <span class="identifier">other</span><span class="special">.</span><span class="identifier">valid</span><span class="special">()</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="future_valid_bridgehead"></a>
  <span><a name="future_valid"></a></span>
  <a class="link" href="pooled_fixedsize.html#future_valid">Member function <code class="computeroutput">valid</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Returns <code class="computeroutput"><span class="keyword">true</span></code> if
                      future contains a <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="future_share_bridgehead"></a>
  <span><a name="future_share"></a></span>
  <a class="link" href="pooled_fixedsize.html#future_share">Member function <code class="computeroutput">share</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">shared_future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">share</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Move the state to a <a class="link" href="pooled_fixedsize.html#class_shared_future"> <code class="computeroutput">shared_future&lt;&gt;</code></a>.
                    </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                      a <a class="link" href="pooled_fixedsize.html#class_shared_future"> <code class="computeroutput">shared_future&lt;&gt;</code></a> containing the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a> formerly belonging
                      to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="keyword">false</span> <span class="special">==</span>
                      <span class="identifier">valid</span><span class="special">()</span></code>
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="future_get_bridgehead"></a>
  <span><a name="future_get"></a></span>
  <a class="link" href="pooled_fixedsize.html#future_get">Member function <code class="computeroutput">get</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">R</span> <span class="identifier">get</span><span class="special">();</span>    <span class="comment">// member only of generic future template</span>
<span class="identifier">R</span> <span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span>  <span class="comment">// member only of future&lt; R &amp; &gt; template specialization</span>
<span class="keyword">void</span> <span class="identifier">get</span><span class="special">();</span> <span class="comment">// member only of future&lt; void &gt; template specialization</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="keyword">true</span> <span class="special">==</span>
                      <span class="identifier">valid</span><span class="special">()</span></code>
                    </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called. If <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> is called,
                      returns the value. If <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called, throws the indicated exception.
                    </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="keyword">false</span> <span class="special">==</span>
                      <span class="identifier">valid</span><span class="special">()</span></code>
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>,
                      <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>,
                      <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">broken_promise</span></code>.
                      Any exception passed to <code class="computeroutput"><span class="identifier">promise</span><span class="special">::</span><span class="identifier">set_exception</span><span class="special">()</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="future_get_exception_ptr_bridgehead"></a>
  <span><a name="future_get_exception_ptr"></a></span>
  <a class="link" href="pooled_fixedsize.html#future_get_exception_ptr">Member
                function <code class="computeroutput">get_exception_ptr</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">get_exception_ptr</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="keyword">true</span> <span class="special">==</span>
                      <span class="identifier">valid</span><span class="special">()</span></code>
                    </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called. If <code class="computeroutput"><span class="identifier">set_value</span><span class="special">()</span></code> is called, returns a default-constructed
                      <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span></code>. If <code class="computeroutput"><span class="identifier">set_exception</span><span class="special">()</span></code>
                      is called, returns the passed <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>
                      or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>.
                    </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">get_exception_ptr</span><span class="special">()</span></code> does <span class="emphasis"><em>not</em></span>
                      invalidate the <code class="computeroutput">future</code>. After calling <code class="computeroutput"><span class="identifier">get_exception_ptr</span><span class="special">()</span></code>, you may still call <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="future_wait_bridgehead"></a>
  <span><a name="future_wait"></a></span>
  <a class="link" href="pooled_fixedsize.html#future_wait">Member function <code class="computeroutput">wait</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>
                      or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="future_wait_for_bridgehead"></a>
  <span><a name="future_wait_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#future_wait_for">Templated
                member function <code class="computeroutput">wait_for</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called, or <code class="computeroutput"><span class="identifier">timeout_duration</span></code>
                      has passed.
                    </p></dd>
<dt><span class="term">Result:</span></dt>
<dd><p>
                      A <code class="computeroutput"><span class="identifier">future_status</span></code>
                      is returned indicating the reason for returning.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>
                      or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                      or timeout-related exceptions.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="future_wait_until_bridgehead"></a>
  <span><a name="future_wait_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#future_wait_until">Templated
                member function <code class="computeroutput">wait_until</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called, or <code class="computeroutput"><span class="identifier">timeout_time</span></code>
                      has passed.
                    </p></dd>
<dt><span class="term">Result:</span></dt>
<dd><p>
                      A <code class="computeroutput"><span class="identifier">future_status</span></code>
                      is returned indicating the reason for returning.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>
                      or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                      or timeout-related exceptions.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="class_shared_future_bridgehead"></a>
  <span><a name="class_shared_future"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_shared_future">Template
                <code class="computeroutput">shared_future&lt;&gt;</code></a>
</h5>
<p>
              </p>
<p>
                A <a class="link" href="pooled_fixedsize.html#class_shared_future"> <code class="computeroutput">shared_future&lt;&gt;</code></a> contains a <a class="link" href="pooled_fixedsize.html#shared_state">shared
                state</a> which might be shared with other <a class="link" href="pooled_fixedsize.html#class_shared_future"> <code class="computeroutput">shared_future&lt;&gt;</code></a> instances.
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">shared_future</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">shared_future</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="special">~</span><span class="identifier">shared_future</span><span class="special">();</span>

    <span class="identifier">shared_future</span><span class="special">(</span> <span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="identifier">shared_future</span><span class="special">(</span> <span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">shared_future</span><span class="special">(</span> <span class="identifier">shared_future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">shared_future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">shared_future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">shared_future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">shared_future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">R</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span> <span class="comment">// member only of generic shared_future template</span>
    <span class="identifier">R</span> <span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span>      <span class="comment">// member only of shared_future&lt; R &amp; &gt; template specialization</span>
    <span class="keyword">void</span> <span class="identifier">get</span><span class="special">();</span>     <span class="comment">// member only of shared_future&lt; void &gt; template specialization</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">get_exception_ptr</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
    <span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
    <span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h7"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.default_constructor0"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.default_constructor0">Default
                constructor</a>
              </h8><pre class="programlisting"><span class="identifier">shared_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Creates a shared_future with no <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a>. After construction <code class="computeroutput"><span class="keyword">false</span>
                      <span class="special">==</span> <span class="identifier">valid</span><span class="special">()</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h8"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.move_constructor0"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.move_constructor0">Move
                constructor</a>
              </h8><pre class="programlisting"><span class="identifier">shared_future</span><span class="special">(</span> <span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="identifier">shared_future</span><span class="special">(</span> <span class="identifier">shared_future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Constructs a shared_future with the <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> of other. After construction <code class="computeroutput"><span class="keyword">false</span>
                      <span class="special">==</span> <span class="identifier">other</span><span class="special">.</span><span class="identifier">valid</span><span class="special">()</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h9"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.copy_constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.copy_constructor">Copy
                constructor</a>
              </h8><pre class="programlisting"><span class="identifier">shared_future</span><span class="special">(</span> <span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Constructs a shared_future with the <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> of other. After construction <code class="computeroutput"><span class="identifier">other</span><span class="special">.</span><span class="identifier">valid</span><span class="special">()</span></code> is unchanged.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.h10"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.destructor0"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.future.destructor0">Destructor</a>
              </h8><pre class="programlisting"><span class="special">~</span><span class="identifier">shared_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Destroys the shared_future; ownership is abandoned if not shared.
                    </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                      <code class="computeroutput">~shared_future()</code> does <span class="emphasis"><em>not</em></span> block the calling
                      fiber.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="shared_future_operator_assign_bridgehead"></a>
  <span><a name="shared_future_operator_assign"></a></span>
  <a class="link" href="pooled_fixedsize.html#shared_future_operator_assign">Member
                function <code class="computeroutput">operator=</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">shared_future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="identifier">shared_future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">shared_future</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
<span class="identifier">shared_future</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Moves or copies the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      of other to <code class="computeroutput"><span class="keyword">this</span></code>.
                      After the assignment, the state of <code class="computeroutput"><span class="identifier">other</span><span class="special">.</span><span class="identifier">valid</span><span class="special">()</span></code> depends on which overload
                      was invoked: unchanged for the overload accepting <code class="computeroutput"><span class="identifier">shared_future</span> <span class="keyword">const</span><span class="special">&amp;</span></code>, otherwise <code class="computeroutput"><span class="keyword">false</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="shared_future_valid_bridgehead"></a>
  <span><a name="shared_future_valid"></a></span>
  <a class="link" href="pooled_fixedsize.html#shared_future_valid">Member
                function <code class="computeroutput">valid</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Returns <code class="computeroutput"><span class="keyword">true</span></code> if
                      shared_future contains a <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="shared_future_get_bridgehead"></a>
  <span><a name="shared_future_get"></a></span>
  <a class="link" href="pooled_fixedsize.html#shared_future_get">Member
                function <code class="computeroutput">get</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">R</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span> <span class="comment">// member only of generic shared_future template</span>
<span class="identifier">R</span> <span class="special">&amp;</span> <span class="identifier">get</span><span class="special">();</span>      <span class="comment">// member only of shared_future&lt; R &amp; &gt; template specialization</span>
<span class="keyword">void</span> <span class="identifier">get</span><span class="special">();</span>     <span class="comment">// member only of shared_future&lt; void &gt; template specialization</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="keyword">true</span> <span class="special">==</span>
                      <span class="identifier">valid</span><span class="special">()</span></code>
                    </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called. If <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> is called,
                      returns the value. If <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called, throws the indicated exception.
                    </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="keyword">false</span> <span class="special">==</span>
                      <span class="identifier">valid</span><span class="special">()</span></code>
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>,
                      <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>,
                      <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">broken_promise</span></code>.
                      Any exception passed to <code class="computeroutput"><span class="identifier">promise</span><span class="special">::</span><span class="identifier">set_exception</span><span class="special">()</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="shared_future_get_exception_ptr_bridgehead"></a>
  <span><a name="shared_future_get_exception_ptr"></a></span>
  <a class="link" href="pooled_fixedsize.html#shared_future_get_exception_ptr">Member
                function <code class="computeroutput">get_exception_ptr</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">get_exception_ptr</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="keyword">true</span> <span class="special">==</span>
                      <span class="identifier">valid</span><span class="special">()</span></code>
                    </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called. If <code class="computeroutput"><span class="identifier">set_value</span><span class="special">()</span></code> is called, returns a default-constructed
                      <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span></code>. If <code class="computeroutput"><span class="identifier">set_exception</span><span class="special">()</span></code>
                      is called, returns the passed <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>
                      or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>.
                    </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">get_exception_ptr</span><span class="special">()</span></code> does <span class="emphasis"><em>not</em></span>
                      invalidate the <code class="computeroutput">shared_future</code>. After calling <code class="computeroutput"><span class="identifier">get_exception_ptr</span><span class="special">()</span></code>, you may still call <a class="link" href="pooled_fixedsize.html#shared_future_get"> <code class="computeroutput">shared_future::get()</code></a>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="shared_future_wait_bridgehead"></a>
  <span><a name="shared_future_wait"></a></span>
  <a class="link" href="pooled_fixedsize.html#shared_future_wait">Member
                function <code class="computeroutput">wait</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>
                      or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="shared_future_wait_for_bridgehead"></a>
  <span><a name="shared_future_wait_for"></a></span>
  <a class="link" href="pooled_fixedsize.html#shared_future_wait_for">Templated
                member function <code class="computeroutput">wait_for</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Period</span> <span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_for</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">duration</span><span class="special">&lt;</span> <span class="identifier">Rep</span><span class="special">,</span> <span class="identifier">Period</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_duration</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called, or <code class="computeroutput"><span class="identifier">timeout_duration</span></code>
                      has passed.
                    </p></dd>
<dt><span class="term">Result:</span></dt>
<dd><p>
                      A <code class="computeroutput"><span class="identifier">future_status</span></code>
                      is returned indicating the reason for returning.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>
                      or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                      or timeout-related exceptions.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="shared_future_wait_until_bridgehead"></a>
  <span><a name="shared_future_wait_until"></a></span>
  <a class="link" href="pooled_fixedsize.html#shared_future_wait_until">Templated
                member function <code class="computeroutput">wait_until</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Duration</span> <span class="special">&gt;</span>
<span class="identifier">future_status</span> <span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">&lt;</span> <span class="identifier">Clock</span><span class="special">,</span> <span class="identifier">Duration</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout_time</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Waits until <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> or <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a> is
                      called, or <code class="computeroutput"><span class="identifier">timeout_time</span></code>
                      has passed.
                    </p></dd>
<dt><span class="term">Result:</span></dt>
<dd><p>
                      A <code class="computeroutput"><span class="identifier">future_status</span></code>
                      is returned indicating the reason for returning.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>
                      or <code class="computeroutput"><span class="identifier">fiber_interrupted</span></code>
                      or timeout-related exceptions.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="fibers_async_bridgehead"></a>
  <span><a name="fibers_async"></a></span>
  <a class="link" href="pooled_fixedsize.html#fibers_async">Non-member function
                <code class="computeroutput">fibers::async()</code></a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">future</span><span class="special">/</span><span class="identifier">async</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">Function</span><span class="special">,</span> <span class="keyword">class</span> <span class="special">...</span> <span class="identifier">Args</span> <span class="special">&gt;</span>
<span class="identifier">future</span><span class="special">&lt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of_t</span><span class="special">&lt;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay_t</span><span class="special">&lt;</span> <span class="identifier">Function</span> <span class="special">&gt;(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay_t</span><span class="special">&lt;</span> <span class="identifier">Args</span> <span class="special">&gt;</span> <span class="special">...</span> <span class="special">)</span>
    <span class="special">&gt;</span>
<span class="special">&gt;</span>
<span class="identifier">async</span><span class="special">(</span> <span class="identifier">Function</span> <span class="special">&amp;&amp;</span> <span class="identifier">fn</span><span class="special">,</span> <span class="identifier">Args</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">args</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <a class="link" href="../../stack.html#stack_allocator_concept"><code class="computeroutput"><span class="identifier">StackAllocator</span></code></a><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Function</span><span class="special">,</span> <span class="keyword">class</span> <span class="special">...</span> <span class="identifier">Args</span> <span class="special">&gt;</span>
<span class="identifier">future</span><span class="special">&lt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of_t</span><span class="special">&lt;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay_t</span><span class="special">&lt;</span> <span class="identifier">Function</span> <span class="special">&gt;(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay_t</span><span class="special">&lt;</span> <span class="identifier">Args</span> <span class="special">&gt;</span> <span class="special">...</span> <span class="special">)</span>
    <span class="special">&gt;</span>
<span class="special">&gt;</span>
<span class="identifier">async</span><span class="special">(</span> <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_arg_t</span></code></a><span class="special">,</span> <a class="link" href="../../stack.html#stack_allocator_concept"><code class="computeroutput"><span class="identifier">StackAllocator</span></code></a> <span class="identifier">salloc</span><span class="special">,</span> <span class="identifier">Function</span> <span class="special">&amp;&amp;</span> <span class="identifier">fn</span><span class="special">,</span> <span class="identifier">Args</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">args</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Executes <code class="computeroutput"><span class="identifier">fn</span></code>
                      in a <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> and returns an associated <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a>.
                    </p></dd>
<dt><span class="term">Result:</span></dt>
<dd>
<p>
</p>
<pre class="programlisting"><span class="identifier">future</span><span class="special">&lt;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of_t</span><span class="special">&lt;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay_t</span><span class="special">&lt;</span> <span class="identifier">Function</span> <span class="special">&gt;(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay_t</span><span class="special">&lt;</span> <span class="identifier">Args</span> <span class="special">&gt;</span> <span class="special">...</span> <span class="special">)</span>
    <span class="special">&gt;</span>
<span class="special">&gt;</span></pre>
<p>
                      representing the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      associated with the asynchronous execution of <code class="computeroutput"><span class="identifier">fn</span></code>.
                    </p>
</dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">fiber_error</span></code>
                      or <code class="computeroutput"><span class="identifier">future_error</span></code>
                      if an error occurs.
                    </p></dd>
<dt><span class="term">Notes:</span></dt>
<dd><p>
                      The overload accepting <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_arg_t</span></code></a> uses
                      the passed <a class="link" href="../../stack.html#stack_allocator_concept"><code class="computeroutput"><span class="identifier">StackAllocator</span></code></a> when
                      constructing the launched <code class="computeroutput"><span class="identifier">fiber</span></code>.
                    </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                  Deferred futures are not supported.
                </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise"></a><a name="class_promise"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise" title="Template promise&lt;&gt;">Template
              <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code></a>
</h6></div></div></div>
<p>
                A <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a> provides a mechanism to store a value
                (or exception) that can later be retrieved from the corresponding
                <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> object. <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code> and <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> communicate via their underlying
                <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>.
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">promise</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">promise</span><span class="special">();</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="special">&gt;</span>
    <span class="identifier">promise</span><span class="special">(</span> <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_arg_t</span></code></a><span class="special">,</span> <span class="identifier">Allocator</span><span class="special">);</span>

    <span class="identifier">promise</span><span class="special">(</span> <span class="identifier">promise</span> <span class="special">&amp;&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">promise</span> <span class="special">&amp;&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">promise</span><span class="special">(</span> <span class="identifier">promise</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">promise</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="special">~</span><span class="identifier">promise</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">promise</span> <span class="special">&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">R</span> <span class="keyword">const</span><span class="special">&amp;);</span>  <span class="comment">// member only of generic promise template</span>
    <span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">R</span> <span class="special">&amp;&amp;);</span>      <span class="comment">// member only of generic promise template</span>
    <span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">R</span> <span class="special">&amp;);</span>       <span class="comment">// member only of promise&lt; R &amp; &gt; template</span>
    <span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">();</span>           <span class="comment">// member only of promise&lt; void &gt; template</span>

    <span class="keyword">void</span> <span class="identifier">set_exception</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">p</span><span class="special">);</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">promise</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;,</span> <span class="identifier">promise</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.h0"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.default_constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.default_constructor">Default
                constructor</a>
              </h8><pre class="programlisting"><span class="identifier">promise</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Creates a promise with an empty <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Exceptions caused by memory allocation.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.h1"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.constructor">Constructor</a>
              </h8><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="special">&gt;</span>
<span class="identifier">promise</span><span class="special">(</span> <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_arg_t</span></code></a><span class="special">,</span> <span class="identifier">Allocator</span> <span class="identifier">alloc</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Creates a promise with an empty <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> by using <code class="computeroutput"><span class="identifier">alloc</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Exceptions caused by memory allocation.
                    </p></dd>
<dt><span class="term">See also:</span></dt>
<dd><p>
                      <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_arg_t</span></code></a>
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.h2"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.move_constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.move_constructor">Move
                constructor</a>
              </h8><pre class="programlisting"><span class="identifier">promise</span><span class="special">(</span> <span class="identifier">promise</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Creates a promise by moving the <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> from <code class="computeroutput"><span class="identifier">other</span></code>.
                    </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">other</span></code> contains
                      no valid shared state.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.h3"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.destructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.promise.destructor">Destructor</a>
              </h8><pre class="programlisting"><span class="special">~</span><span class="identifier">promise</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                      and abandons the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      if shared state is ready; otherwise stores <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">broken_promise</span></code>
                      as if by <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a>: the
                      shared state is set ready.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="promise_operator_assign_bridgehead"></a>
  <span><a name="promise_operator_assign"></a></span>
  <a class="link" href="pooled_fixedsize.html#promise_operator_assign">Member
                function <code class="computeroutput">operator=</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">promise</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">promise</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Transfers the ownership of <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">other</span></code> contains
                      no valid shared state.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="promise_swap_bridgehead"></a>
  <span><a name="promise_swap"></a></span>
  <a class="link" href="pooled_fixedsize.html#promise_swap">Member function <code class="computeroutput">swap</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">promise</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Swaps the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      between other and <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="promise_get_future_bridgehead"></a>
  <span><a name="promise_get_future"></a></span>
  <a class="link" href="pooled_fixedsize.html#promise_get_future">Member
                function <code class="computeroutput">get_future</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                      A <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> with the same <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">future_already_retrieved</span></code>
                      or <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="promise_set_value_bridgehead"></a>
  <span><a name="promise_set_value"></a></span>
  <a class="link" href="pooled_fixedsize.html#promise_set_value">Member
                function <code class="computeroutput">set_value</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">R</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">);</span>  <span class="comment">// member only of generic promise template</span>
<span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">R</span> <span class="special">&amp;&amp;</span> <span class="identifier">value</span><span class="special">);</span>      <span class="comment">// member only of generic promise template</span>
<span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">R</span> <span class="special">&amp;</span> <span class="identifier">value</span><span class="special">);</span>       <span class="comment">// member only of promise&lt; R &amp; &gt; template</span>
<span class="keyword">void</span> <span class="identifier">set_value</span><span class="special">();</span>                 <span class="comment">// member only of promise&lt; void &gt; template</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Store the result in the <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> and marks the state as ready.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">future_already_satisfied</span></code>
                      or <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="promise_set_exception_bridgehead"></a>
  <span><a name="promise_set_exception"></a></span>
  <a class="link" href="pooled_fixedsize.html#promise_set_exception">Member
                function <code class="computeroutput">set_exception</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">set_exception</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Store an exception pointer in the <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> and marks the state as ready.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">future_already_satisfied</span></code>
                      or <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="swap_for_promise_bridgehead"></a>
  <span><a name="swap_for_promise"></a></span>
  <a class="link" href="pooled_fixedsize.html#swap_for_promise">Non-member
                function <code class="computeroutput">swap()</code></a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">R</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">promise</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">l</span><span class="special">,</span> <span class="identifier">promise</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">r</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Same as <code class="computeroutput"><span class="identifier">l</span><span class="special">.</span><span class="identifier">swap</span><span class="special">(</span>
                      <span class="identifier">r</span><span class="special">)</span></code>.
                    </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task"></a><a name="class_packaged_task"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task" title="Template packaged_task&lt;&gt;">Template
              <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code></a>
</h6></div></div></div>
<p>
                A <a class="link" href="pooled_fixedsize.html#class_packaged_task"> <code class="computeroutput">packaged_task&lt;&gt;</code></a> wraps a callable target
                that returns a value so that the return value can be computed asynchronously.
              </p>
<p>
                Conventional usage of <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code> is like this:
              </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                    Instantiate <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code> with template arguments
                    matching the signature of the callable. Pass the callable to
                    the <a class="link" href="pooled_fixedsize.html#packaged_task_packaged_task">constructor</a>.
                  </li>
<li class="listitem">
                    Call <a class="link" href="pooled_fixedsize.html#packaged_task_get_future"> <code class="computeroutput">packaged_task::get_future()</code></a> and capture
                    the returned <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> instance.
                  </li>
<li class="listitem">
                    Launch a <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> to run the new <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code>, passing any arguments
                    required by the original callable.
                  </li>
<li class="listitem">
                    Call <a class="link" href="../../fiber_mgmt/fiber.html#fiber_detach"> <code class="computeroutput">fiber::detach()</code></a> on the newly-launched <code class="computeroutput"><span class="identifier">fiber</span></code>.
                  </li>
<li class="listitem">
                    At some later point, retrieve the result from the <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>.
                  </li>
</ol></div>
<p>
                This is, in fact, pretty much what <a class="link" href="pooled_fixedsize.html#fibers_async"> <code class="computeroutput">fibers::async()</code></a>
encapsulates.
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">class</span> <span class="identifier">R</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Args</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">packaged_task</span><span class="special">&lt;</span> <span class="identifier">R</span><span class="special">(</span> <span class="identifier">Args</span> <span class="special">...</span> <span class="special">)</span> <span class="special">&gt;</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">packaged_task</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span> <span class="special">&gt;</span>
    <span class="keyword">explicit</span> <span class="identifier">packaged_task</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;);</span>

    <span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="special">&gt;</span>
    <span class="identifier">packaged_task</span><span class="special">(</span> <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_arg_t</span></code></a><span class="special">,</span> <span class="identifier">Allocator</span> <span class="keyword">const</span><span class="special">&amp;,</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;);</span>

    <span class="identifier">packaged_task</span><span class="special">(</span> <span class="identifier">packaged_task</span> <span class="special">&amp;&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">packaged_task</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">packaged_task</span> <span class="special">&amp;&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">packaged_task</span><span class="special">(</span> <span class="identifier">packaged_task</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">packaged_task</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">packaged_task</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="special">~</span><span class="identifier">packaged_task</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">packaged_task</span> <span class="special">&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">Args</span> <span class="special">...);</span>

    <span class="keyword">void</span> <span class="identifier">reset</span><span class="special">();</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Signature</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">packaged_task</span><span class="special">&lt;</span> <span class="identifier">Signature</span> <span class="special">&gt;</span> <span class="special">&amp;,</span> <span class="identifier">packaged_task</span><span class="special">&lt;</span> <span class="identifier">Signature</span> <span class="special">&gt;</span> <span class="special">&amp;)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.h0"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.default_constructor__code__phrase_role__identifier__packaged_task__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.default_constructor__code__phrase_role__identifier__packaged_task__phrase__phrase_role__special______phrase___code_">Default
                constructor <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">()</span></code></a>
              </h8><pre class="programlisting"><span class="identifier">packaged_task</span><span class="special">()</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Constructs an object of class <code class="computeroutput"><span class="identifier">packaged_task</span></code>
                      with no <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<a name="packaged_task_packaged_task"></a><h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.h1"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.templated_constructor__code__phrase_role__identifier__packaged_task__phrase__phrase_role__special______phrase___code_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.templated_constructor__code__phrase_role__identifier__packaged_task__phrase__phrase_role__special______phrase___code_">Templated
                constructor <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">()</span></code></a>
              </h8><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span> <span class="special">&gt;</span>
<span class="keyword">explicit</span> <span class="identifier">packaged_task</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">fn</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <a href="http://en.cppreference.com/w/cpp/concept/Allocator" target="_top"><code class="computeroutput"><span class="identifier">Allocator</span></code></a> <span class="special">&gt;</span>
<span class="identifier">packaged_task</span><span class="special">(</span> <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_arg_t</span></code></a><span class="special">,</span> <span class="identifier">Allocator</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">alloc</span><span class="special">,</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">fn</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Constructs an object of class <code class="computeroutput"><span class="identifier">packaged_task</span></code>
                      with a <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a> and
                      copies or moves the callable target <code class="computeroutput"><span class="identifier">fn</span></code>
                      to internal storage.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Exceptions caused by memory allocation.
                    </p></dd>
<dt><span class="term">Note:</span></dt>
<dd><p>
                      The signature of <code class="computeroutput"><span class="identifier">Fn</span></code>
                      should have a return type convertible to <code class="computeroutput"><span class="identifier">R</span></code>.
                    </p></dd>
<dt><span class="term">See also:</span></dt>
<dd><p>
                      <a href="http://en.cppreference.com/w/cpp/memory/allocator_arg_t" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_arg_t</span></code></a>
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.h2"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.move_constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.move_constructor">Move
                constructor</a>
              </h8><pre class="programlisting"><span class="identifier">packaged_task</span><span class="special">(</span> <span class="identifier">packaged_task</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Creates a packaged_task by moving the <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> from <code class="computeroutput"><span class="identifier">other</span></code>.
                    </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">other</span></code> contains
                      no valid shared state.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<h8><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.h3"></a>
                <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.destructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.futures.packaged_task.destructor">Destructor</a>
              </h8><pre class="programlisting"><span class="special">~</span><span class="identifier">packaged_task</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                      and abandons the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      if shared state is ready; otherwise stores <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with error condition <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">broken_promise</span></code>
                      as if by <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a>: the
                      shared state is set ready.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="packaged_task_operator_assign_bridgehead"></a>
  <span><a name="packaged_task_operator_assign"></a></span>
  <a class="link" href="pooled_fixedsize.html#packaged_task_operator_assign">Member
                function <code class="computeroutput">operator=</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">packaged_task</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">packaged_task</span> <span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Transfers the ownership of <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a> to <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">other</span></code> contains
                      no valid shared state.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="packaged_task_swap_bridgehead"></a>
  <span><a name="packaged_task_swap"></a></span>
  <a class="link" href="pooled_fixedsize.html#packaged_task_swap">Member
                function <code class="computeroutput">swap</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">packaged_task</span> <span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Swaps the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      between other and <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="packaged_task_valid_bridgehead"></a>
  <span><a name="packaged_task_valid"></a></span>
  <a class="link" href="pooled_fixedsize.html#packaged_task_valid">Member
                function <code class="computeroutput">valid</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">valid</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Returns <code class="computeroutput"><span class="keyword">true</span></code> if
                      <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                      contains a <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      Nothing.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="packaged_task_get_future_bridgehead"></a>
  <span><a name="packaged_task_get_future"></a></span>
  <a class="link" href="pooled_fixedsize.html#packaged_task_get_future">Member
                function <code class="computeroutput">get_future</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">R</span> <span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                      A <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> with the same <a class="link" href="pooled_fixedsize.html#shared_state">shared
                      state</a>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">future_already_retrieved</span></code>
                      or <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="packaged_task_operator_apply_bridgehead"></a>
  <span><a name="packaged_task_operator_apply"></a></span>
  <a class="link" href="pooled_fixedsize.html#packaged_task_operator_apply">Member
                function <code class="computeroutput">operator()</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">Args</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">args</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Invokes the stored callable target. Any exception thrown by
                      the callable target <code class="computeroutput"><span class="identifier">fn</span></code>
                      is stored in the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      as if by <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a>. Otherwise,
                      the value returned by <code class="computeroutput"><span class="identifier">fn</span></code>
                      is stored in the shared state as if by <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a>.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="packaged_task_reset_bridgehead"></a>
  <span><a name="packaged_task_reset"></a></span>
  <a class="link" href="pooled_fixedsize.html#packaged_task_reset">Member
                function <code class="computeroutput">reset</code>()</a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">reset</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Resets the <a class="link" href="pooled_fixedsize.html#shared_state">shared state</a>
                      and abandons the result of previous executions. A new shared
                      state is constructed.
                    </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                      <code class="computeroutput"><span class="identifier">future_error</span></code>
                      with <code class="computeroutput"><span class="identifier">future_errc</span><span class="special">::</span><span class="identifier">no_state</span></code>.
                    </p></dd>
</dl>
</div>
<p>
                </p>
<h5>
<a name="swap_for_packaged_task_bridgehead"></a>
  <span><a name="swap_for_packaged_task"></a></span>
  <a class="link" href="pooled_fixedsize.html#swap_for_packaged_task">Non-member
                function <code class="computeroutput">swap()</code></a>
</h5>
<p>
              </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Signature</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <span class="identifier">packaged_task</span><span class="special">&lt;</span> <span class="identifier">Signature</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">l</span><span class="special">,</span> <span class="identifier">packaged_task</span><span class="special">&lt;</span> <span class="identifier">Signature</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">r</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                      Same as <code class="computeroutput"><span class="identifier">l</span><span class="special">.</span><span class="identifier">swap</span><span class="special">(</span>
                      <span class="identifier">r</span><span class="special">)</span></code>.
                    </p></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fls" title="Fiber local storage">Fiber
          local storage</a>
</h5></div></div></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls.synopsis"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fls.synopsis">Synopsis</a>
          </h6>
<p>
            Fiber local storage allows a separate instance of a given data item for
            each fiber.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls.cleanup_at_fiber_exit"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fls.cleanup_at_fiber_exit">Cleanup
            at fiber exit</a>
          </h6>
<p>
            When a fiber exits, the objects associated with each <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr"> <code class="computeroutput">fiber_specific_ptr</code></a> instance
            are destroyed. By default, the object pointed to by a pointer <code class="computeroutput"><span class="identifier">p</span></code> is destroyed by invoking <code class="computeroutput"><span class="keyword">delete</span> <span class="identifier">p</span></code>,
            but this can be overridden for a specific instance of <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr"> <code class="computeroutput">fiber_specific_ptr</code></a> by
            providing a cleanup routine <code class="computeroutput"><span class="identifier">func</span></code>
            to the constructor. In this case, the object is destroyed by invoking
            <code class="computeroutput"><span class="identifier">func</span><span class="special">(</span><span class="identifier">p</span><span class="special">)</span></code>.
            The cleanup functions are called in an unspecified order.
          </p>
<p>
            </p>
<h5>
<a name="class_fiber_specific_ptr_bridgehead"></a>
  <span><a name="class_fiber_specific_ptr"></a></span>
  <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr">Class
            <code class="computeroutput">fiber_specific_ptr</code></a>
</h5>
<p>
          </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">fss</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">fiber_specific_ptr</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">T</span>   <span class="identifier">element_type</span><span class="special">;</span>

    <span class="identifier">fiber_specific_ptr</span><span class="special">();</span>

    <span class="keyword">explicit</span> <span class="identifier">fiber_specific_ptr</span><span class="special">(</span> <span class="keyword">void</span><span class="special">(*</span><span class="identifier">fn</span><span class="special">)(</span><span class="identifier">T</span><span class="special">*)</span> <span class="special">);</span>

    <span class="special">~</span><span class="identifier">fiber_specific_ptr</span><span class="special">();</span>

    <span class="identifier">fiber_specific_ptr</span><span class="special">(</span> <span class="identifier">fiber_specific_ptr</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>
    <span class="identifier">fiber_specific_ptr</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span> <span class="identifier">fiber_specific_ptr</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">delete</span><span class="special">;</span>

    <span class="identifier">T</span> <span class="special">*</span> <span class="identifier">get</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">T</span> <span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">T</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>

    <span class="identifier">T</span> <span class="special">*</span> <span class="identifier">release</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">reset</span><span class="special">(</span> <span class="identifier">T</span> <span class="special">*);</span>
<span class="special">};</span>
</pre>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls.h2"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls.constructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fls.constructor">Constructor</a>
          </h6>
<pre class="programlisting"><span class="identifier">fiber_specific_ptr</span><span class="special">();</span>
<span class="keyword">explicit</span> <span class="identifier">fiber_specific_ptr</span><span class="special">(</span> <span class="keyword">void</span><span class="special">(*</span><span class="identifier">fn</span><span class="special">)(</span><span class="identifier">T</span><span class="special">*)</span> <span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">delete</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()</span></code> is well-formed; <code class="computeroutput"><span class="identifier">fn</span><span class="special">(</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">())</span></code>
                  does not throw
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Construct a <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr"> <code class="computeroutput">fiber_specific_ptr</code></a> object for
                  storing a pointer to an object of type <code class="computeroutput"><span class="identifier">T</span></code>
                  specific to each fiber. When <code class="computeroutput"><span class="identifier">reset</span><span class="special">()</span></code> is called, or the fiber exits,
                  <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr"> <code class="computeroutput">fiber_specific_ptr</code></a> calls <code class="computeroutput"><span class="identifier">fn</span><span class="special">(</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">())</span></code>. If the no-arguments constructor
                  is used, the default <code class="computeroutput"><span class="keyword">delete</span></code>-based
                  cleanup function will be used to destroy the fiber-local objects.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="identifier">fiber_error</span></code> if
                  an error occurs.
                </p></dd>
</dl>
</div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls.h3"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.fls.destructor"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.fls.destructor">Destructor</a>
          </h6>
<pre class="programlisting"><span class="special">~</span><span class="identifier">fiber_specific_ptr</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  All the fiber specific instances associated to this <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr"> <code class="computeroutput">fiber_specific_ptr</code></a>
(except
                  maybe the one associated to this fiber) must be nullptr.
                </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Calls <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">reset</span><span class="special">()</span></code>
                  to clean up the associated value for the current fiber, and destroys
                  <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
                </p></dd>
<dt><span class="term">Remarks:</span></dt>
<dd><p>
                  The requirement is an implementation restriction. If the destructor
                  promised to delete instances for all fibers, the implementation
                  would be forced to maintain a list of all the fibers having an
                  associated specific ptr, which is against the goal of fiber specific
                  data. In general, a <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr"> <code class="computeroutput">fiber_specific_ptr</code></a> should
                  outlive the fibers that use it.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              Care needs to be taken to ensure that any fibers still running after
              an instance of <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr"> <code class="computeroutput">fiber_specific_ptr</code></a> has been destroyed
              do not call any member functions on that instance.
            </p></td></tr>
</table></div>
<p>
            </p>
<h5>
<a name="fiber_specific_ptr_get_bridgehead"></a>
  <span><a name="fiber_specific_ptr_get"></a></span>
  <a class="link" href="pooled_fixedsize.html#fiber_specific_ptr_get">Member
            function <code class="computeroutput">get</code>()</a>
</h5>
<p>
          </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="special">*</span> <span class="identifier">get</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  The pointer associated with the current fiber.
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The initial value associated with an instance of <a class="link" href="pooled_fixedsize.html#class_fiber_specific_ptr"> <code class="computeroutput">fiber_specific_ptr</code></a> is
              <code class="computeroutput"><span class="keyword">nullptr</span></code> for each fiber.
            </p></td></tr>
</table></div>
<p>
            </p>
<h5>
<a name="fiber_specific_ptr_operator_arrow_bridgehead"></a>
  <span><a name="fiber_specific_ptr_operator_arrow"></a></span>
  <a class="link" href="pooled_fixedsize.html#fiber_specific_ptr_operator_arrow">Member
            function <code class="computeroutput">operator-&gt;</code>()</a>
</h5>
<p>
          </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="special">*</span> <span class="keyword">operator</span><span class="special">-&gt;()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()</span></code>
                  is not <code class="computeroutput"><span class="keyword">nullptr</span></code>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()</span></code>
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
<p>
            </p>
<h5>
<a name="fiber_specific_ptr_operator_star_bridgehead"></a>
  <span><a name="fiber_specific_ptr_operator_star"></a></span>
  <a class="link" href="pooled_fixedsize.html#fiber_specific_ptr_operator_star">Member
            function <code class="computeroutput">operator*</code>()</a>
</h5>
<p>
          </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">*()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()</span></code>
                  is not <code class="computeroutput"><span class="keyword">nullptr</span></code>.
                </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="special">*(</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">())</span></code>
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
<p>
            </p>
<h5>
<a name="fiber_specific_ptr_release_bridgehead"></a>
  <span><a name="fiber_specific_ptr_release"></a></span>
  <a class="link" href="pooled_fixedsize.html#fiber_specific_ptr_release">Member
            function <code class="computeroutput">release</code>()</a>
</h5>
<p>
          </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="special">*</span> <span class="identifier">release</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  Return <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()</span></code>
                  and store <code class="computeroutput"><span class="keyword">nullptr</span></code>
                  as the pointer associated with the current fiber without invoking
                  the cleanup function.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()==</span><span class="keyword">nullptr</span></code>
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Nothing.
                </p></dd>
</dl>
</div>
<p>
            </p>
<h5>
<a name="fiber_specific_ptr_reset_bridgehead"></a>
  <span><a name="fiber_specific_ptr_reset"></a></span>
  <a class="link" href="pooled_fixedsize.html#fiber_specific_ptr_reset">Member
            function <code class="computeroutput">reset</code>()</a>
</h5>
<p>
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">reset</span><span class="special">(</span> <span class="identifier">T</span> <span class="special">*</span> <span class="identifier">new_value</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                  If <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()!=</span><span class="identifier">new_value</span></code> and <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()</span></code> is not <code class="computeroutput"><span class="keyword">nullptr</span></code>,
                  invoke <code class="computeroutput"><span class="keyword">delete</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">fn</span><span class="special">(</span><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">())</span></code> as appropriate. Store <code class="computeroutput"><span class="identifier">new_value</span></code> as the pointer associated
                  with the current fiber.
                </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                  <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">get</span><span class="special">()==</span><span class="identifier">new_value</span></code>
                </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                  Exception raised during cleanup of previous value.
                </p></dd>
</dl>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration"></a><a name="migration"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration" title="Migrating fibers between threads">Migrating
          fibers between threads</a>
</h5></div></div></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.overview"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.overview">Overview</a>
          </h6>
<p>
            Each fiber owns a stack and manages its execution state, including all
            registers and CPU flags, the instruction pointer and the stack pointer.
            That means, in general, a fiber is not bound to a specific thread.<sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.f0" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.migration.f0" class="footnote">3</a>]</sup> <sup>,</sup><sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.f1" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.migration.f1" class="footnote">4</a>]</sup>
          </p>
<p>
            Migrating a fiber from a logical CPU with heavy workload to another logical
            CPU with a lighter workload might speed up the overall execution. Note
            that in the case of NUMA-architectures, it is not always advisable to
            migrate data between threads. Suppose fiber <span class="emphasis"><em>f</em></span> is
            running on logical CPU <span class="emphasis"><em>cpu0</em></span> which belongs to NUMA
            node <span class="emphasis"><em>node0</em></span>. The data of <span class="emphasis"><em>f</em></span> are
            allocated on the physical memory located at <span class="emphasis"><em>node0</em></span>.
            Migrating the fiber from <span class="emphasis"><em>cpu0</em></span> to another logical
            CPU <span class="emphasis"><em>cpuX</em></span> which is part of a different NUMA node
            <span class="emphasis"><em>nodeX</em></span> might reduce the performance of the application
            due to increased latency of memory access.
          </p>
<p>
            Only fibers that are contained in <a class="link" href="../../scheduling.html#class_sched_algorithm"> <code class="computeroutput">sched_algorithm</code></a>'s
            ready queue can migrate between threads. You cannot migrate a running
            fiber, nor one that is <a class="link" href="../../overview.html#blocking"><span class="emphasis"><em>blocked</em></span></a>.
          </p>
<p>
            In<span class="bold"><strong>Boost.Fiber</strong></span> a fiber is migrated by
            invoking <a class="link" href="../../scheduling.html#context_migrate"> <code class="computeroutput">context::migrate()</code></a> on the <a class="link" href="../../scheduling.html#class_context"> <code class="computeroutput">context</code></a> instance
            for a fiber already associated with the destination thread, passing the
            <code class="computeroutput"><span class="identifier">context</span></code> for the fiber
            to be migrated.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.example_of_work_sharing"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.example_of_work_sharing">Example
            of work sharing</a>
          </h6>
<p>
            In the example <a href="../../../../../examples/work_sharing.cpp" target="_top">work_sharing.cpp</a>
            multiple worker fibers are created on the main thread. Each fiber gets
            a character as parameter at construction. This character is printed out
            ten times. Between each iteration the fiber calls <a class="link" href="../../fiber_mgmt/this_fiber.html#this_fiber_yield"> <code class="computeroutput">this_fiber::yield()</code></a>.
            That puts the fiber in the ready queue of the fiber-scheduler <span class="emphasis"><em>shared_ready_queue</em></span>,
            running in the current thread. The next fiber ready to be executed is
            dequeued from the shared ready queue and resumed by <span class="emphasis"><em>shared_ready_queue</em></span>
            running on <span class="emphasis"><em>any participating thread</em></span>.
          </p>
<p>
            All instances of <span class="emphasis"><em>shared_ready_queue</em></span> share one global
            concurrent queue, used as ready queue. This mechanism shares all worker
            fibers between all instances of <span class="emphasis"><em>shared_ready_queue</em></span>,
            thus between all participating threads.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.h2"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.setup_of_threads_and_fibers"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.setup_of_threads_and_fibers">Setup
            of threads and fibers</a>
          </h6>
<p>
            In <code class="computeroutput"><span class="identifier">main</span><span class="special">()</span></code>
            the fiber-scheduler is installed and the worker fibers and the threads
            are launched.
          </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">use_scheduling_algorithm</span><span class="special">&lt;</span> <span class="identifier">shared_ready_queue</span> <span class="special">&gt;();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c0" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c1"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a>

<span class="keyword">for</span> <span class="special">(</span> <span class="keyword">char</span> <span class="identifier">c</span> <span class="special">:</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"abcdefghijklmnopqrstuvwxyz"</span><span class="special">))</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c2" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c3"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">([</span><span class="identifier">c</span><span class="special">](){</span> <span class="identifier">whatevah</span><span class="special">(</span> <span class="identifier">c</span><span class="special">);</span> <span class="special">}).</span><span class="identifier">detach</span><span class="special">();</span>
    <span class="special">++</span><span class="identifier">fiber_count</span><span class="special">;</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c4" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c5"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a>
<span class="special">}</span>
<span class="identifier">barrier</span> <span class="identifier">b</span><span class="special">(</span> <span class="number">4</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span> <span class="identifier">threads</span><span class="special">[]</span> <span class="special">=</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c6" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c7"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span><span class="special">(</span> <span class="identifier">thread</span><span class="special">,</span> <span class="special">&amp;</span> <span class="identifier">b</span><span class="special">),</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span><span class="special">(</span> <span class="identifier">thread</span><span class="special">,</span> <span class="special">&amp;</span> <span class="identifier">b</span><span class="special">),</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span><span class="special">(</span> <span class="identifier">thread</span><span class="special">,</span> <span class="special">&amp;</span> <span class="identifier">b</span><span class="special">)</span>
<span class="special">};</span>
<span class="identifier">b</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c8" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c9"><img src="../../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a>
<span class="special">{</span>
    <span class="identifier">lock_t</span><a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c10" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c11"><img src="../../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx_count</span><span class="special">);</span>
    <span class="identifier">cnd_count</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="special">[](){</span> <span class="keyword">return</span> <span class="number">0</span> <span class="special">==</span> <span class="identifier">fiber_count</span><span class="special">;</span> <span class="special">}</span> <span class="special">);</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c12" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c13"><img src="../../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a>
<span class="special">}</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c14" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c15"><img src="../../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a>
<span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="number">0</span> <span class="special">==</span> <span class="identifier">fiber_count</span><span class="special">);</span>
<span class="keyword">for</span> <span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span> <span class="special">&amp;</span> <span class="identifier">t</span> <span class="special">:</span> <span class="identifier">threads</span><span class="special">)</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c16" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c17"><img src="../../../../../../../doc/src/images/callouts/9.png" alt="9" border="0"></a>
    <span class="identifier">t</span><span class="special">.</span><span class="identifier">join</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c1"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c0"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Install the scheduling algorithm <code class="computeroutput"><span class="identifier">shared_ready_queue</span></code>
                in the main thread too, so each new fiber gets launched into the
                shared pool.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c3"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c2"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Launch a number of worker fibers; each worker fiber picks up a character
                that is passed as parameter to fiber-function <code class="computeroutput"><span class="identifier">whatevah</span></code>.
                Each worker fiber gets detached.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c5"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c4"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Increment fiber counter for each new fiber.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c7"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c6"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Launch a couple of threads that join the work sharing.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c9"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c8"><img src="../../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                sync with other threads: allow them to start processing
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c11"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c10"><img src="../../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                <code class="computeroutput"><span class="identifier">lock_t</span></code> is typedef'ed
                as <a href="http://en.cppreference.com/w/cpp/thread/unique_lock" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>&lt; <a href="http://en.cppreference.com/w/cpp/thread/mutex" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">mutex</span></code></a> &gt;
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c13"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c12"><img src="../../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Suspend main fiber and resume worker fibers in the meanwhile. Main
                fiber gets resumed (e.g returns from <code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>) if all worker fibers are complete.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c15"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c14"><img src="../../../../../../../doc/src/images/callouts/8.png" alt="8" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Releasing lock of mtx_count is required before joining the threads,
                othwerwise the other threads would be blocked inside condition_variable::wait()
                and would never return (deadlock).
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c17"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c16"><img src="../../../../../../../doc/src/images/callouts/9.png" alt="9" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                wait for threads to terminate
              </p></td>
</tr>
</table></div>
<p>
            The start of the threads is synchronized with a barrier. The main fiber
            of each thread (including main thread) is suspended until all worker
            fibers are complete. When the main fiber returns from <a class="link" href="pooled_fixedsize.html#condition_variable_wait"> <code class="computeroutput">condition_variable::wait()</code></a>,
            the thread terminates: the main thread joins all other threads.
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">thread</span><span class="special">(</span> <span class="identifier">barrier</span> <span class="special">*</span> <span class="identifier">b</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span> <span class="identifier">buffer</span><span class="special">;</span>
    <span class="identifier">buffer</span> <span class="special">&lt;&lt;</span> <span class="string">"thread started "</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">flush</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">use_scheduling_algorithm</span><span class="special">&lt;</span> <span class="identifier">shared_ready_queue</span> <span class="special">&gt;();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c18" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c19"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a>
    <span class="identifier">b</span><span class="special">-&gt;</span><span class="identifier">wait</span><span class="special">();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c20" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c21"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a>
    <span class="identifier">lock_t</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx_count</span><span class="special">);</span>
    <span class="identifier">cnd_count</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="special">[](){</span> <span class="keyword">return</span> <span class="number">0</span> <span class="special">==</span> <span class="identifier">fiber_count</span><span class="special">;</span> <span class="special">}</span> <span class="special">);</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c22" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c23"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="number">0</span> <span class="special">==</span> <span class="identifier">fiber_count</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c19"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c18"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Install the scheduling algorithm <code class="computeroutput"><span class="identifier">shared_ready_queue</span></code>
                in order to join the work sharing.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c21"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c20"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                sync with other threads: allow them to start processing
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c23"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c22"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Suspend main fiber and resume worker fibers in the meanwhile. Main
                fiber gets resumed (e.g returns from <code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>) if all worker fibers are complete.
              </p></td>
</tr>
</table></div>
<p>
            Each worker fiber executes function <code class="computeroutput"><span class="identifier">whatevah</span><span class="special">()</span></code> with character <code class="computeroutput"><span class="identifier">me</span></code>
            as parameter. The fiber yields in a loop and prints out a message if
            it was migrated to another thread.
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">whatevah</span><span class="special">(</span> <span class="keyword">char</span> <span class="identifier">me</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">try</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span><span class="special">::</span><span class="identifier">id</span> <span class="identifier">my_thread</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c24" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c25"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span> <span class="identifier">buffer</span><span class="special">;</span>
            <span class="identifier">buffer</span> <span class="special">&lt;&lt;</span> <span class="string">"fiber "</span> <span class="special">&lt;&lt;</span> <span class="identifier">me</span> <span class="special">&lt;&lt;</span> <span class="string">" started on thread "</span> <span class="special">&lt;&lt;</span> <span class="identifier">my_thread</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">flush</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="keyword">for</span> <span class="special">(</span> <span class="keyword">unsigned</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="number">10</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c26" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c27"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">yield</span><span class="special">();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c28" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c29"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">thread</span><span class="special">::</span><span class="identifier">id</span> <span class="identifier">new_thread</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">this_thread</span><span class="special">::</span><span class="identifier">get_id</span><span class="special">();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c30" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c31"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a>
            <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">new_thread</span> <span class="special">!=</span> <span class="identifier">my_thread</span><span class="special">)</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c32" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c33"><img src="../../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a>
                <span class="identifier">my_thread</span> <span class="special">=</span> <span class="identifier">new_thread</span><span class="special">;</span>
                <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span> <span class="identifier">buffer</span><span class="special">;</span>
                <span class="identifier">buffer</span> <span class="special">&lt;&lt;</span> <span class="string">"fiber "</span> <span class="special">&lt;&lt;</span> <span class="identifier">me</span> <span class="special">&lt;&lt;</span> <span class="string">" switched to thread "</span> <span class="special">&lt;&lt;</span> <span class="identifier">my_thread</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
                <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">buffer</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">flush</span><span class="special">;</span>
            <span class="special">}</span>
        <span class="special">}</span>
    <span class="special">}</span> <span class="keyword">catch</span> <span class="special">(</span> <span class="special">...</span> <span class="special">)</span> <span class="special">{</span>
    <span class="special">}</span>
    <span class="identifier">lock_t</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx_count</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="number">0</span> <span class="special">==</span> <span class="special">--</span><span class="identifier">fiber_count</span><span class="special">)</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c34" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c35"><img src="../../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a>
        <span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
        <span class="identifier">cnd_count</span><span class="special">.</span><span class="identifier">notify_all</span><span class="special">();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c36" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c37"><img src="../../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c25"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c24"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                get ID of initial thread
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c27"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c26"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                loop ten times
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c29"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c28"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                yield to other fibers
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c31"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c30"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                get ID of current thread
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c33"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c32"><img src="../../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                test if fiber was migrated to another thread
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c35"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c34"><img src="../../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Decrement fiber counter for each completed fiber.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c37"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c36"><img src="../../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Notify all fibers waiting on <code class="computeroutput"><span class="identifier">cnd_count</span></code>.
              </p></td>
</tr>
</table></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.h3"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.scheduling_fibers"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.scheduling_fibers">Scheduling
            fibers</a>
          </h6>
<p>
            The fiber scheduler <code class="computeroutput"><span class="identifier">shared_ready_queue</span></code>
            is like <code class="computeroutput"><span class="identifier">round_robin</span></code>,
            except that it shares a common ready queue among all participating threads.
            A thread participates in this pool by executing <a class="link" href="../../fiber_mgmt/fiber.html#use_scheduling_algorithm"> <code class="computeroutput">use_scheduling_algorithm()</code></a>
before
            any other <span class="bold"><strong>Boost.Fiber</strong></span> operation.
          </p>
<p>
            The important point about the ready queue is that it's a class static,
            common to all instances of shared_ready_queue. Fibers that are enqueued
            via <a class="link" href="../../scheduling.html#sched_algorithm_awakened"> <code class="computeroutput">sched_algorithm::awakened()</code></a> (fibers that are
            ready to be resumed) are thus available to all threads. It is required
            to reserve a separate, scheduler-specific queue for the thread's main
            fiber and dispatcher fibers: these may <span class="emphasis"><em>not</em></span> be shared
            between threads! When we're passed either of these fibers, push it there
            instead of in the shared queue: it would be Bad News for thread B to
            retrieve and attempt to execute thread A's main fiber.
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">awakened</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">*</span> <span class="identifier">ctx</span><span class="special">)</span> <span class="keyword">noexcept</span> <span class="special">{</span>
    <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="keyword">nullptr</span> <span class="special">!=</span> <span class="identifier">ctx</span><span class="special">);</span>

    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">ctx</span><span class="special">-&gt;</span><span class="identifier">is_context</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">pinned_context</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c38" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c39"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a>
        <span class="identifier">local_queue_</span><span class="special">.</span><span class="identifier">push</span><span class="special">(</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span>
        <span class="identifier">lock_t</span> <span class="identifier">lk</span><span class="special">(</span><span class="identifier">rqueue_mtx_</span><span class="special">);</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c40" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c41"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a>
        <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">push</span><span class="special">(</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c39"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c38"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                recognize when we're passed this thread's main fiber (or an implicit
                library helper fiber): never put those on the shared queue
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c41"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c40"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                worker fiber, enqueue on shared queue
              </p></td>
</tr>
</table></div>
<p>
            When <a class="link" href="../../scheduling.html#sched_algorithm_pick_next"> <code class="computeroutput">sched_algorithm::pick_next()</code></a> gets called
            inside one thread, a fiber is dequeued from <span class="emphasis"><em>rqueue_</em></span>
            and will be resumed in that thread.
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">virtual</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">*</span> <span class="identifier">pick_next</span><span class="special">()</span> <span class="keyword">noexcept</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">*</span> <span class="identifier">ctx</span><span class="special">(</span> <span class="keyword">nullptr</span><span class="special">);</span>
    <span class="identifier">lock_t</span> <span class="identifier">lk</span><span class="special">(</span><span class="identifier">rqueue_mtx_</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">empty</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c42" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c43"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a>
        <span class="identifier">ctx</span> <span class="special">=</span> <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">front</span><span class="special">();</span>
        <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">pop</span><span class="special">();</span>
        <span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
        <span class="identifier">BOOST_ASSERT</span><span class="special">(</span> <span class="keyword">nullptr</span> <span class="special">!=</span> <span class="identifier">ctx</span><span class="special">);</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">active</span><span class="special">()-&gt;</span><span class="identifier">migrate</span><span class="special">(</span> <span class="identifier">ctx</span><span class="special">);</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c44" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c45"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a>
    <span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span>
        <span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">local_queue_</span><span class="special">.</span><span class="identifier">empty</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c46" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c47"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a>
            <span class="identifier">ctx</span> <span class="special">=</span> <span class="identifier">local_queue_</span><span class="special">.</span><span class="identifier">front</span><span class="special">();</span>
            <span class="identifier">local_queue_</span><span class="special">.</span><span class="identifier">pop</span><span class="special">();</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">ctx</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c43"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c42"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                pop an item from the ready queue
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c45"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c44"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                attach context to current scheduler via the active fiber of this
                thread; benign if the fiber already belongs to this thread
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c47"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.c46"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                nothing in the ready queue, return main or dispatcher fiber
              </p></td>
</tr>
</table></div>
<p>
            The source code above is found in <a href="../../../../../examples/work_sharing.cpp" target="_top">work_sharing.cpp</a>.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks"></a><a name="callbacks"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks" title="Integrating Fibers with Asynchronous Callbacks">Integrating
          Fibers with Asynchronous Callbacks</a>
</h5></div></div></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.overview"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.overview">Overview</a>
          </h6>
<p>
            One of the primary benefits of <span class="bold"><strong>Boost.Fiber</strong></span>
            is the ability to use asynchronous operations for efficiency, while at
            the same time structuring the calling code <span class="emphasis"><em>as if</em></span>
            the operations were synchronous. Asynchronous operations provide completion
            notification in a variety of ways, but most involve a callback function
            of some kind. This section discusses tactics for interfacing <span class="bold"><strong>Boost.Fiber</strong></span> with an arbitrary async operation.
          </p>
<p>
            For purposes of illustration, consider the following hypothetical API:
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">AsyncAPI</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// constructor acquires some resource that can be read and written</span>
    <span class="identifier">AsyncAPI</span><span class="special">();</span>

    <span class="comment">// callbacks accept an int error code; 0 == success</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">errorcode</span><span class="special">;</span>

    <span class="comment">// write callback only needs to indicate success or failure</span>
    <span class="keyword">void</span> <span class="identifier">init_write</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">,</span>
                     <span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span> <span class="keyword">void</span><span class="special">(</span> <span class="identifier">errorcode</span><span class="special">)</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">callback</span><span class="special">);</span>

    <span class="comment">// read callback needs to accept both errorcode and data</span>
    <span class="keyword">void</span> <span class="identifier">init_read</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span> <span class="keyword">void</span><span class="special">(</span> <span class="identifier">errorcode</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;);</span>

    <span class="comment">// ... other operations ...</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            The significant points about each of <code class="computeroutput"><span class="identifier">init_write</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">init_read</span><span class="special">()</span></code> are:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                The <code class="computeroutput"><span class="identifier">AsyncAPI</span></code> method
                only initiates the operation. It returns immediately, while the requested
                operation is still pending.
              </li>
<li class="listitem">
                The method accepts a callback. When the operation completes, the
                callback is called with relevant parameters (error code, data if
                applicable).
              </li>
</ul></div>
<p>
            We would like to wrap these asynchronous methods in functions that appear
            synchronous by blocking the calling fiber until the operation completes.
            This lets us use the wrapper function's return value to deliver relevant
            data.
          </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
              <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a> and <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> are your
              friends here.
            </p></td></tr>
</table></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.return_errorcode"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.return_errorcode">Return
            Errorcode</a>
          </h6>
<p>
            The <code class="computeroutput"><span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">init_write</span><span class="special">()</span></code>
            callback passes only an <code class="computeroutput"><span class="identifier">errorcode</span></code>.
            If we simply want the blocking wrapper to return that <code class="computeroutput"><span class="identifier">errorcode</span></code>,
            this is an extremely straightforward use of <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a> and
            <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="identifier">write_ec</span><span class="special">(</span> <span class="identifier">AsyncAPI</span> <span class="special">&amp;</span> <span class="identifier">api</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span> <span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="special">&gt;</span> <span class="identifier">promise</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="special">&gt;</span> <span class="identifier">future</span><span class="special">(</span> <span class="identifier">promise</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">()</span> <span class="special">);</span>
    <span class="comment">// In general, even though we block waiting for future::get() and therefore</span>
    <span class="comment">// won't destroy 'promise' until promise::set_value() has been called, we</span>
    <span class="comment">// are advised that with threads it's possible for ~promise() to be</span>
    <span class="comment">// entered before promise::set_value() has returned. While that shouldn't</span>
    <span class="comment">// happen with fibers::promise, a robust way to deal with the lifespan</span>
    <span class="comment">// issue is to bind 'promise' into our lambda. Since promise is move-only,</span>
    <span class="comment">// use initialization capture.</span>
    <span class="identifier">api</span><span class="special">.</span><span class="identifier">init_write</span><span class="special">(</span>
        <span class="identifier">data</span><span class="special">,</span>
        <span class="special">[&amp;</span><span class="identifier">promise</span><span class="special">](</span> <span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="identifier">ec</span><span class="special">)</span> <span class="keyword">mutable</span> <span class="special">{</span>
                            <span class="identifier">promise</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">ec</span><span class="special">);</span>
                  <span class="special">});</span>
    <span class="keyword">return</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            All we have to do is:
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                Instantiate a <code class="computeroutput"><span class="identifier">promise</span><span class="special">&lt;&gt;</span></code> of correct type.
              </li>
<li class="listitem">
                Obtain its <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>.
              </li>
<li class="listitem">
                Arrange for the callback to call <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a>.
              </li>
<li class="listitem">
                Block on <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a>.
              </li>
</ol></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              This tactic for resuming a pending fiber works even if the callback
              is called on a different thread than the one on which the initiating
              fiber is running. In fact, <a href="../../../../../examples/adapt_callbacks.cpp" target="_top">the
              example program's</a> dummy <code class="computeroutput"><span class="identifier">AsyncAPI</span></code>
              implementation illustrates that: it simulates async I/O by launching
              a new thread that sleeps briefly and then calls the relevant callback.
            </p></td></tr>
</table></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.h2"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.success_or_exception"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.success_or_exception">Success
            or Exception</a>
          </h6>
<p>
            A wrapper more aligned with modern C++ practice would use an exception,
            rather than an <code class="computeroutput"><span class="identifier">errorcode</span></code>,
            to communicate failure to its caller. This is straightforward to code
            in terms of <code class="computeroutput"><span class="identifier">write_ec</span><span class="special">()</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">write</span><span class="special">(</span> <span class="identifier">AsyncAPI</span> <span class="special">&amp;</span> <span class="identifier">api</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="identifier">ec</span> <span class="special">=</span> <span class="identifier">write_ec</span><span class="special">(</span> <span class="identifier">api</span><span class="special">,</span> <span class="identifier">data</span><span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">throw</span> <span class="identifier">make_exception</span><span class="special">(</span><span class="string">"write"</span><span class="special">,</span> <span class="identifier">ec</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            The point is that since each fiber has its own stack, you need not repeat
            messy boilerplate: normal encapsulation works.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.h3"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.return_errorcode_or_data"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.return_errorcode_or_data">Return
            Errorcode or Data</a>
          </h6>
<p>
            Things get a bit more interesting when the async operation's callback
            passes multiple data items of interest. One approach would be to use
            <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;&gt;</span></code>
            to capture both:
          </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span> <span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">read_ec</span><span class="special">(</span> <span class="identifier">AsyncAPI</span> <span class="special">&amp;</span> <span class="identifier">api</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span> <span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">result_pair</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span> <span class="identifier">result_pair</span> <span class="special">&gt;</span> <span class="identifier">promise</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">result_pair</span> <span class="special">&gt;</span> <span class="identifier">future</span><span class="special">(</span> <span class="identifier">promise</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">()</span> <span class="special">);</span>
    <span class="comment">// We promise that both 'promise' and 'future' will survive until our</span>
    <span class="comment">// lambda has been called.</span>
    <span class="identifier">api</span><span class="special">.</span><span class="identifier">init_read</span><span class="special">([&amp;</span><span class="identifier">promise</span><span class="special">](</span> <span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">)</span> <span class="keyword">mutable</span> <span class="special">{</span>
                            <span class="identifier">promise</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">result_pair</span><span class="special">(</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">data</span><span class="special">)</span> <span class="special">);</span>
                  <span class="special">});</span>
    <span class="keyword">return</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            Once you bundle the interesting data in <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;&gt;</span></code>, the code is effectively identical
            to <code class="computeroutput"><span class="identifier">write_ec</span><span class="special">()</span></code>.
            You can call it like this:
          </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tie</span><span class="special">(</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">data</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">read_ec</span><span class="special">(</span> <span class="identifier">api</span><span class="special">);</span>
</pre>
<p>
          </p>
<a name="Data_or_Exception"></a><h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.h4"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.data_or_exception"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.data_or_exception">Data
            or Exception</a>
          </h6>
<p>
            But a more natural API for a function that obtains data is to return
            only the data on success, throwing an exception on error.
          </p>
<p>
            As with <code class="computeroutput"><span class="identifier">write</span><span class="special">()</span></code>
            above, it's certainly possible to code a <code class="computeroutput"><span class="identifier">read</span><span class="special">()</span></code> wrapper in terms of <code class="computeroutput"><span class="identifier">read_ec</span><span class="special">()</span></code>. But since a given application is unlikely
            to need both, let's code <code class="computeroutput"><span class="identifier">read</span><span class="special">()</span></code> from scratch, leveraging <a class="link" href="pooled_fixedsize.html#promise_set_exception"> <code class="computeroutput">promise::set_exception()</code></a>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">read</span><span class="special">(</span> <span class="identifier">AsyncAPI</span> <span class="special">&amp;</span> <span class="identifier">api</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">promise</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">future</span><span class="special">(</span> <span class="identifier">promise</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">()</span> <span class="special">);</span>
    <span class="comment">// Both 'promise' and 'future' will survive until our lambda has been</span>
    <span class="comment">// called.</span>
    <span class="identifier">api</span><span class="special">.</span><span class="identifier">init_read</span><span class="special">([&amp;</span><span class="identifier">promise</span><span class="special">](</span> <span class="identifier">AsyncAPI</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">)</span> <span class="keyword">mutable</span> <span class="special">{</span>
                           <span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">{</span>
                               <span class="identifier">promise</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">data</span><span class="special">);</span>
                           <span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span>
                               <span class="identifier">promise</span><span class="special">.</span><span class="identifier">set_exception</span><span class="special">(</span>
                                       <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_exception_ptr</span><span class="special">(</span>
                                           <span class="identifier">make_exception</span><span class="special">(</span><span class="string">"read"</span><span class="special">,</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">)</span> <span class="special">);</span>
                           <span class="special">}</span>
                  <span class="special">});</span>
    <span class="keyword">return</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a> will do the right thing, either returning <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> or throwing an exception.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.h5"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.success_error_virtual_methods"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.success_error_virtual_methods">Success/Error
            Virtual Methods</a>
          </h6>
<p>
            One classic approach to completion notification is to define an abstract
            base class with <code class="computeroutput"><span class="identifier">success</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">error</span><span class="special">()</span></code> methods. Code wishing to perform async
            I/O must derive a subclass, override each of these methods and pass the
            async operation a pointer to a subclass instance. The abstract base class
            might look like this:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// every async operation receives a subclass instance of this abstract base</span>
<span class="comment">// class through which to communicate its result</span>
<span class="keyword">struct</span> <span class="identifier">Response</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">Response</span> <span class="special">&gt;</span> <span class="identifier">ptr</span><span class="special">;</span>

    <span class="comment">// called if the operation succeeds</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">success</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

    <span class="comment">// called if the operation fails</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">error</span><span class="special">(</span> <span class="identifier">AsyncAPIBase</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            Now the <code class="computeroutput"><span class="identifier">AsyncAPI</span></code> operation
            might look more like this:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// derive Response subclass, instantiate, pass Response::ptr</span>
<span class="keyword">void</span> <span class="identifier">init_read</span><span class="special">(</span> <span class="identifier">Response</span><span class="special">::</span><span class="identifier">ptr</span><span class="special">);</span>
</pre>
<p>
          </p>
<p>
            We can address this by writing a one-size-fits-all <code class="computeroutput"><span class="identifier">PromiseResponse</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">PromiseResponse</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">Response</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// called if the operation succeeds</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">success</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">promise_</span><span class="special">.</span><span class="identifier">set_value</span><span class="special">(</span> <span class="identifier">data</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// called if the operation fails</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">error</span><span class="special">(</span> <span class="identifier">AsyncAPIBase</span><span class="special">::</span><span class="identifier">errorcode</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">promise_</span><span class="special">.</span><span class="identifier">set_exception</span><span class="special">(</span>
                <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_exception_ptr</span><span class="special">(</span>
                    <span class="identifier">make_exception</span><span class="special">(</span><span class="string">"read"</span><span class="special">,</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">)</span> <span class="special">);</span>
    <span class="special">}</span>

    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">get_future</span><span class="special">()</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">promise_</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">();</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">promise</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span>   <span class="identifier">promise_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            Now we can simply obtain the <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> from that <code class="computeroutput"><span class="identifier">PromiseResponse</span></code>
            and wait on its <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">read</span><span class="special">(</span> <span class="identifier">AsyncAPI</span> <span class="special">&amp;</span> <span class="identifier">api</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Because init_read() requires a shared_ptr, we must allocate our</span>
    <span class="comment">// ResponsePromise on the heap, even though we know its lifespan.</span>
    <span class="keyword">auto</span> <span class="identifier">promisep</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">PromiseResponse</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">future</span><span class="special">(</span> <span class="identifier">promisep</span><span class="special">-&gt;</span><span class="identifier">get_future</span><span class="special">()</span> <span class="special">);</span>
    <span class="comment">// Both 'promisep' and 'future' will survive until our lambda has been</span>
    <span class="comment">// called.</span>
    <span class="identifier">api</span><span class="special">.</span><span class="identifier">init_read</span><span class="special">(</span> <span class="identifier">promisep</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            The source code above is found in <a href="../../../../../examples/adapt_callbacks.cpp" target="_top">adapt_callbacks.cpp</a>
            and <a href="../../../../../examples/adapt_method_calls.cpp" target="_top">adapt_method_calls.cpp</a>.
          </p>
<a name="callbacks_asio"></a><h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.h6"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.then_there_s__ulink_url__http___www_boost_org_doc_libs_release_libs_asio_index_html__boost_asio__ulink_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.then_there_s__ulink_url__http___www_boost_org_doc_libs_release_libs_asio_index_html__boost_asio__ulink_">Then
            There's <a href="http://www.boost.org/doc/libs/release/libs/asio/index.html" target="_top">Boost.Asio</a></a>
          </h6>
<p>
            Since the simplest form of Boost.Asio asynchronous operation completion
            token is a callback function, we could apply the same tactics for Asio
            as for our hypothetical <code class="computeroutput"><span class="identifier">AsyncAPI</span></code>
            asynchronous operations.
          </p>
<p>
            Fortunately we need not. Boost.Asio incorporates a mechanism<sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.f0" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.f0" class="footnote">5</a>]</sup> by which the caller can customize the notification behavior
            of every async operation. Therefore we can construct a <span class="emphasis"><em>completion
            token</em></span> which, when passed to a <a href="http://www.boost.org/doc/libs/release/libs/asio/index.html" target="_top">Boost.Asio</a>
            async operation, requests blocking for the calling fiber.
          </p>
<p>
            A typical Asio async function might look something like this:<sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.f1" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.f1" class="footnote">6</a>]</sup>
          </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span> <span class="special">...,</span> <span class="keyword">class</span> <span class="identifier">CompletionToken</span> <span class="special">&gt;</span>
<span class="emphasis"><em>deduced_return_type</em></span>
<span class="identifier">async_something</span><span class="special">(</span> <span class="special">...</span> <span class="special">,</span> <span class="identifier">CompletionToken</span><span class="special">&amp;&amp;</span> <span class="identifier">token</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// construct handler_type instance from CompletionToken</span>
    <span class="identifier">handler_type</span><span class="special">&lt;</span><span class="identifier">CompletionToken</span><span class="special">,</span> <span class="special">...&gt;::</span><span class="identifier">type</span> <span class="identifier">handler</span><span class="special">(</span><span class="identifier">token</span><span class="special">);</span>
    <span class="comment">// construct async_result instance from handler_type</span>
    <span class="identifier">async_result</span><span class="special">&lt;</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">handler</span><span class="special">)&gt;</span> <span class="identifier">result</span><span class="special">(</span><span class="identifier">handler</span><span class="special">);</span>

    <span class="comment">// ... arrange to call handler on completion ...</span>
    <span class="comment">// ... initiate actual I/O operation ...</span>

    <span class="keyword">return</span> <span class="identifier">result</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
            We will engage that mechanism, which is based on specializing Asio's
            <code class="computeroutput"><span class="identifier">handler_type</span><span class="special">&lt;&gt;</span></code>
            template for the <code class="computeroutput"><span class="identifier">CompletionToken</span></code>
            type and the signature of the specific callback. The remainder of this
            discussion will refer back to <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> as the Asio async function under consideration.
          </p>
<p>
            The implementation described below uses lower-level facilities than
            <code class="computeroutput"><span class="identifier">promise</span></code> and <code class="computeroutput"><span class="identifier">future</span></code> for two reasons:
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                The <code class="computeroutput"><span class="identifier">promise</span></code> mechanism
                interacts badly with <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service/stop.html" target="_top"><code class="computeroutput"><span class="identifier">io_service</span><span class="special">::</span><span class="identifier">stop</span><span class="special">()</span></code></a>.
                It produces <code class="computeroutput"><span class="identifier">broken_promise</span></code>
                exceptions.
              </li>
<li class="listitem">
                If more than one thread is calling the <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service/run.html" target="_top"><code class="computeroutput"><span class="identifier">io_service</span><span class="special">::</span><span class="identifier">run</span><span class="special">()</span></code></a>
                method, the implementation described below allows resuming the suspended
                fiber on whichever thread gets there first with completion notification.
                More on this later.
              </li>
</ol></div>
<p>
            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">yield</span></code> is a completion token of this
            kind. <code class="computeroutput"><span class="identifier">yield</span></code> is an instance
            of <code class="computeroutput"><span class="identifier">yield_t</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">yield_t</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">yield_t</span><span class="special">(</span> <span class="keyword">bool</span> <span class="identifier">hop</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">allow_hop_</span><span class="special">(</span> <span class="identifier">hop</span><span class="special">)</span> <span class="special">{</span>
    <span class="special">}</span>

    <span class="comment">/**
     * @code
     * static yield_t yield;
     * boost::system::error_code myec;
     * func(yield[myec]);
     * @endcode
     * @c yield[myec] returns an instance of @c yield_t whose @c ec_ points
     * to @c myec. The expression @c yield[myec] "binds" @c myec to that
     * (anonymous) @c yield_t instance, instructing @c func() to store any
     * @c error_code it might produce into @c myec rather than throwing @c
     * boost::system::system_error.
     */</span>
    <span class="identifier">yield_t</span> <span class="keyword">operator</span><span class="special">[](</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span> <span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="identifier">yield_t</span> <span class="identifier">tmp</span><span class="special">{</span> <span class="special">*</span> <span class="keyword">this</span> <span class="special">};</span>
        <span class="identifier">tmp</span><span class="special">.</span><span class="identifier">ec_</span> <span class="special">=</span> <span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">tmp</span><span class="special">;</span>
    <span class="special">}</span>

<span class="comment">//private:</span>
    <span class="comment">// ptr to bound error_code instance if any</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span>   <span class="special">*</span>   <span class="identifier">ec_</span><span class="special">{</span> <span class="keyword">nullptr</span> <span class="special">};</span>
    <span class="comment">// allow calling fiber to "hop" to another thread if it could resume more</span>
    <span class="comment">// quickly that way</span>
    <span class="keyword">bool</span>                            <span class="identifier">allow_hop_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            <code class="computeroutput"><span class="identifier">yield_t</span></code> is in fact only
            a placeholder, a way to trigger Boost.Asio customization. It can bind
            a <a href="http://www.boost.org/doc/libs/release/libs/system/doc/reference.html#Class-error_code" target="_top"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span></code></a> for use by the actual
            handler.
          </p>
<p>
            In fact there are two canonical instances of <code class="computeroutput"><span class="identifier">yield_t</span></code>
            &#8212; <code class="computeroutput"><span class="identifier">yield</span></code> and <code class="computeroutput"><span class="identifier">yield_hop</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// canonical instance with allow_hop_ == false</span>
<span class="keyword">thread_local</span> <span class="identifier">yield_t</span> <span class="identifier">yield</span><span class="special">{</span> <span class="keyword">false</span> <span class="special">};</span>
<span class="comment">// canonical instance with allow_hop_ == true</span>
<span class="keyword">thread_local</span> <span class="identifier">yield_t</span> <span class="identifier">yield_hop</span><span class="special">{</span> <span class="keyword">true</span> <span class="special">};</span>
</pre>
<p>
          </p>
<p>
            We'll get to the differences between these shortly.
          </p>
<p>
            Asio customization is engaged by specializing <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/handler_type.html" target="_top"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">handler_type</span><span class="special">&lt;&gt;</span></code></a>
            for <code class="computeroutput"><span class="identifier">yield_t</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Handler type specialisation for fibers::asio::yield.</span>
<span class="comment">// When 'yield' is passed as a completion handler which accepts only</span>
<span class="comment">// error_code, use yield_handler&lt;void&gt;. yield_handler will take care of the</span>
<span class="comment">// error_code one way or another.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">ReturnType</span> <span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">handler_type</span><span class="special">&lt;</span> <span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">yield_t</span><span class="special">,</span> <span class="identifier">ReturnType</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">)</span> <span class="special">&gt;</span>
<span class="special">{</span> <span class="keyword">typedef</span> <span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">yield_handler</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span>    <span class="identifier">type</span><span class="special">;</span> <span class="special">};</span>
</pre>
<p>
          </p>
<p>
            (There are actually four different specializations in <a href="../../../../../examples/asio/detail/yield.hpp" target="_top">detail/yield.hpp</a>,
            one for each of the four Asio async callback signatures we expect to
            have to support.)
          </p>
<p>
            The above directs Asio to use <code class="computeroutput"><span class="identifier">yield_handler</span></code>
            as the actual handler for an async operation to which <code class="computeroutput"><span class="identifier">yield</span></code>
            is passed. There's a generic <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> implementation and a <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code>
            specialization. Let's start with the <code class="computeroutput"><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code>
            specialization:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// yield_handler&lt;void&gt; is like yield_handler&lt;T&gt; without value_. In fact it's</span>
<span class="comment">// just like yield_handler_base.</span>
<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">class</span> <span class="identifier">yield_handler</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;:</span> <span class="keyword">public</span> <span class="identifier">yield_handler_base</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">explicit</span> <span class="identifier">yield_handler</span><span class="special">(</span> <span class="identifier">yield_t</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">yield_handler_base</span><span class="special">{</span> <span class="identifier">y</span> <span class="special">}</span> <span class="special">{</span>
    <span class="special">}</span>

    <span class="comment">// nullary completion callback</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()()</span> <span class="special">{</span>
        <span class="special">(</span> <span class="special">*</span> <span class="keyword">this</span><span class="special">)(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// inherit operator()(error_code) overload from base class</span>
    <span class="keyword">using</span> <span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>,
            having consulted the <code class="computeroutput"><span class="identifier">handler_type</span><span class="special">&lt;&gt;</span></code> traits specialization, instantiates
            a <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code>
            to be passed as the actual callback for the async operation. <code class="computeroutput"><span class="identifier">yield_handler</span></code>'s constructor accepts
            the <code class="computeroutput"><span class="identifier">yield_t</span></code> instance
            (the <code class="computeroutput"><span class="identifier">yield</span></code> object passed
            to the async function) and passes it along to <code class="computeroutput"><span class="identifier">yield_handler_base</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// This class encapsulates common elements between yield_handler&lt;T&gt; (capturing</span>
<span class="comment">// a value to return from asio async function) and yield_handler&lt;void&gt; (no</span>
<span class="comment">// such value). See yield_handler&lt;T&gt; and its &lt;void&gt; specialization below. Both</span>
<span class="comment">// yield_handler&lt;T&gt; and yield_handler&lt;void&gt; are passed by value through</span>
<span class="comment">// various layers of asio functions. In other words, they're potentially</span>
<span class="comment">// copied multiple times. So key data such as the yield_completion instance</span>
<span class="comment">// must be stored in our async_result&lt;yield_handler&lt;&gt;&gt; specialization, which</span>
<span class="comment">// should be instantiated only once.</span>
<span class="keyword">class</span> <span class="identifier">yield_handler_base</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">yield_handler_base</span><span class="special">(</span> <span class="identifier">yield_t</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">:</span>
        <span class="comment">// capture the context* associated with the running fiber</span>
        <span class="identifier">ctx_</span><span class="special">{</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">active</span><span class="special">()</span> <span class="special">},</span>
        <span class="comment">// capture the passed yield_t</span>
        <span class="identifier">yt_</span><span class="special">{</span> <span class="identifier">y</span> <span class="special">}</span> <span class="special">{</span>
    <span class="special">}</span>

    <span class="comment">// completion callback passing only (error_code)</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">BOOST_ASSERT_MSG</span><span class="special">(</span> <span class="identifier">ycomp_</span><span class="special">,</span>
                          <span class="string">"Must inject yield_completion* "</span>
                          <span class="string">"before calling yield_handler_base::operator()()"</span><span class="special">);</span>
        <span class="identifier">BOOST_ASSERT_MSG</span><span class="special">(</span> <span class="identifier">yt_</span><span class="special">.</span><span class="identifier">ec_</span><span class="special">,</span>
                          <span class="string">"Must inject boost::system::error_code* "</span>
                          <span class="string">"before calling yield_handler_base::operator()()"</span><span class="special">);</span>
        <span class="comment">// If originating fiber is busy testing completed_ flag, wait until it</span>
        <span class="comment">// has observed (! completed_).</span>
        <span class="identifier">yield_completion</span><span class="special">::</span><span class="identifier">lock_t</span> <span class="identifier">lk</span><span class="special">{</span> <span class="identifier">ycomp_</span><span class="special">-&gt;</span><span class="identifier">mtx_</span> <span class="special">};</span>
        <span class="comment">// Notify a subsequent yield_completion::wait() call that it need not</span>
        <span class="comment">// suspend.</span>
        <span class="identifier">ycomp_</span><span class="special">-&gt;</span><span class="identifier">completed_</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
        <span class="comment">// set the error_code bound by yield_t</span>
        <span class="special">*</span> <span class="identifier">yt_</span><span class="special">.</span><span class="identifier">ec_</span> <span class="special">=</span> <span class="identifier">ec</span><span class="special">;</span>
        <span class="comment">// Are we permitted to wake up the suspended fiber on this thread, the</span>
        <span class="comment">// thread that called the completion handler?</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">ctx_</span><span class="special">-&gt;</span><span class="identifier">is_context</span><span class="special">(</span> <span class="identifier">fibers</span><span class="special">::</span><span class="identifier">type</span><span class="special">::</span><span class="identifier">pinned_context</span><span class="special">)</span> <span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="identifier">yt_</span><span class="special">.</span><span class="identifier">allow_hop_</span><span class="special">)</span> <span class="special">{</span>
            <span class="comment">// We must not migrate a pinned_context to another thread. If this</span>
            <span class="comment">// isn't a pinned_context, and the application passed yield_hop</span>
            <span class="comment">// rather than yield, migrate this fiber to the running thread.</span>
            <span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">active</span><span class="special">()-&gt;</span><span class="identifier">migrate</span><span class="special">(</span> <span class="identifier">ctx_</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="comment">// either way, wake the fiber</span>
        <span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">active</span><span class="special">()-&gt;</span><span class="identifier">set_ready</span><span class="special">(</span> <span class="identifier">ctx_</span><span class="special">);</span>
    <span class="special">}</span>

<span class="comment">//private:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span>      <span class="special">*</span>   <span class="identifier">ctx_</span><span class="special">;</span>
    <span class="identifier">yield_t</span>                         <span class="identifier">yt_</span><span class="special">;</span>
    <span class="comment">// We depend on this pointer to yield_completion, which will be injected</span>
    <span class="comment">// by async_result.</span>
    <span class="identifier">yield_completion</span>            <span class="special">*</span>   <span class="identifier">ycomp_</span><span class="special">{</span> <span class="keyword">nullptr</span> <span class="special">};</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            <code class="computeroutput"><span class="identifier">yield_handler_base</span></code> stores
            a copy of the <code class="computeroutput"><span class="identifier">yield_t</span></code>
            instance &#8212; which, as shown above, is only an <code class="computeroutput"><span class="identifier">error_code</span></code>
            and a <code class="computeroutput"><span class="keyword">bool</span></code>. It also captures
            the <a class="link" href="../../scheduling.html#class_context"> <code class="computeroutput">context</code></a>* for the currently-running fiber by calling
            <a class="link" href="../../scheduling.html#context_active"> <code class="computeroutput">context::active()</code></a>.
          </p>
<p>
            You will notice that <code class="computeroutput"><span class="identifier">yield_handler_base</span></code>
            has one more data member (<code class="computeroutput"><span class="identifier">ycomp_</span></code>)
            that is initialized to <code class="computeroutput"><span class="keyword">nullptr</span></code>
            by its constructor &#8212; though its <code class="computeroutput"><span class="keyword">operator</span><span class="special">()()</span></code> method relies on <code class="computeroutput"><span class="identifier">ycomp_</span></code>
            being non-null. More on this in a moment.
          </p>
<p>
            Having constructed the <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code> instance, <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> goes on to construct an <code class="computeroutput"><span class="identifier">async_result</span></code> specialized for the <code class="computeroutput"><span class="identifier">handler_type</span><span class="special">&lt;&gt;::</span><span class="identifier">type</span></code>: in this case, <code class="computeroutput"><span class="identifier">async_result</span><span class="special">&lt;</span><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;&gt;</span></code>. It passes the <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code>
            instance to the new <code class="computeroutput"><span class="identifier">async_result</span></code>
            instance.
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Without the need to handle a passed value, our yield_handler&lt;void&gt;</span>
<span class="comment">// specialization is just like async_result_base.</span>
<span class="keyword">template</span><span class="special">&lt;&gt;</span>
<span class="keyword">class</span> <span class="identifier">async_result</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">yield_handler</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span>
    <span class="keyword">public</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">async_result_base</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">type</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">async_result</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">yield_handler</span><span class="special">&lt;</span> <span class="keyword">void</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">h</span><span class="special">):</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">async_result_base</span><span class="special">{</span> <span class="identifier">h</span> <span class="special">}</span> <span class="special">{</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            Naturally that leads us straight to <code class="computeroutput"><span class="identifier">async_result_base</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Factor out commonality between async_result&lt;yield_handler&lt;T&gt;&gt; and</span>
<span class="comment">// async_result&lt;yield_handler&lt;void&gt;&gt;</span>
<span class="keyword">class</span> <span class="identifier">async_result_base</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">explicit</span> <span class="identifier">async_result_base</span><span class="special">(</span> <span class="identifier">yield_handler_base</span> <span class="special">&amp;</span> <span class="identifier">h</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Inject ptr to our yield_completion instance into this</span>
        <span class="comment">// yield_handler&lt;&gt;.</span>
        <span class="identifier">h</span><span class="special">.</span><span class="identifier">ycomp_</span> <span class="special">=</span> <span class="special">&amp;</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">ycomp_</span><span class="special">;</span>
        <span class="comment">// if yield_t didn't bind an error_code, make yield_handler_base's</span>
        <span class="comment">// error_code* point to an error_code local to this object so</span>
        <span class="comment">// yield_handler_base::operator() can unconditionally store through</span>
        <span class="comment">// its error_code*</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">h</span><span class="special">.</span><span class="identifier">yt_</span><span class="special">.</span><span class="identifier">ec_</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">h</span><span class="special">.</span><span class="identifier">yt_</span><span class="special">.</span><span class="identifier">ec_</span> <span class="special">=</span> <span class="special">&amp;</span> <span class="identifier">ec_</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">get</span><span class="special">()</span> <span class="special">{</span>
        <span class="comment">// Unless yield_handler_base::operator() has already been called,</span>
        <span class="comment">// suspend the calling fiber until that call.</span>
        <span class="identifier">ycomp_</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span>
        <span class="comment">// The only way our own ec_ member could have a non-default value is</span>
        <span class="comment">// if our yield_handler did not have a bound error_code AND the</span>
        <span class="comment">// completion callback passed a non-default error_code.</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">ec_</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">throw_exception</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">system_error</span><span class="special">{</span> <span class="identifier">ec_</span> <span class="special">}</span> <span class="special">);</span>
        <span class="special">}</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">interruption_point</span><span class="special">();</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="comment">// If yield_t does not bind an error_code instance, store into here.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span>       <span class="identifier">ec_</span><span class="special">{};</span>
    <span class="comment">// async_result_base owns the yield_completion because, unlike</span>
    <span class="comment">// yield_handler&lt;&gt;, async_result&lt;&gt; is only instantiated once.</span>
    <span class="identifier">yield_completion</span>                <span class="identifier">ycomp_</span><span class="special">{};</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            This is how <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="identifier">ycomp_</span></code>
            becomes non-null: <code class="computeroutput"><span class="identifier">async_result_base</span></code>'s
            constructor injects a pointer back to its own <code class="computeroutput"><span class="identifier">yield_completion</span></code>
            member.
          </p>
<p>
            Recall that both of the canonical <code class="computeroutput"><span class="identifier">yield_t</span></code>
            instances <code class="computeroutput"><span class="identifier">yield</span></code> and
            <code class="computeroutput"><span class="identifier">yield_hop</span></code> initialize
            their <code class="computeroutput"><span class="identifier">error_code</span><span class="special">*</span></code>
            member <code class="computeroutput"><span class="identifier">ec_</span></code> to <code class="computeroutput"><span class="keyword">nullptr</span></code>. If either of these instances
            is passed to <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> (<code class="computeroutput"><span class="identifier">ec_</span></code>
            is still <code class="computeroutput"><span class="keyword">nullptr</span></code>), the copy
            stored in <code class="computeroutput"><span class="identifier">yield_handler_base</span></code>
            will likewise have null <code class="computeroutput"><span class="identifier">ec_</span></code>.
            <code class="computeroutput"><span class="identifier">async_result_base</span></code>'s constructor
            sets <code class="computeroutput"><span class="identifier">yield_handler_base</span></code>'s
            <code class="computeroutput"><span class="identifier">yield_t</span></code>'s <code class="computeroutput"><span class="identifier">ec_</span></code> member to point to its own <code class="computeroutput"><span class="identifier">error_code</span></code> member.
          </p>
<p>
            The stage is now set. <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> initiates the actual async operation,
            arranging to call its <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code> instance on completion. Let's say,
            for the sake of argument, that the actual async operation's callback
            has signature <code class="computeroutput"><span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">)</span></code>.
          </p>
<p>
            But since it's an async operation, control returns at once to <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>.
            <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>
            calls <code class="computeroutput"><span class="identifier">async_result</span><span class="special">&lt;</span><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>,
            and will return its return value.
          </p>
<p>
            <code class="computeroutput"><span class="identifier">async_result</span><span class="special">&lt;</span><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>
            inherits <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">get</span><span class="special">()</span></code>.
          </p>
<p>
            <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">get</span><span class="special">()</span></code>
            immediately calls <code class="computeroutput"><span class="identifier">yield_completion</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>.
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Bundle a completion bool flag with a spinlock to protect it.</span>
<span class="keyword">struct</span> <span class="identifier">yield_completion</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">fibers</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">spinlock</span>    <span class="identifier">mutex_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">mutex_t</span> <span class="special">&gt;</span> <span class="identifier">lock_t</span><span class="special">;</span>

    <span class="identifier">mutex_t</span> <span class="identifier">mtx_</span><span class="special">{};</span>
    <span class="keyword">bool</span>    <span class="identifier">completed_</span><span class="special">{</span> <span class="keyword">false</span> <span class="special">};</span>

    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="special">{</span>
        <span class="comment">// yield_handler_base::operator()() will set completed_ true and</span>
        <span class="comment">// attempt to wake a suspended fiber. It would be Bad if that call</span>
        <span class="comment">// happened between our detecting (! completed_) and suspending.</span>
        <span class="identifier">lock_t</span> <span class="identifier">lk</span><span class="special">{</span> <span class="identifier">mtx_</span> <span class="special">};</span>
        <span class="comment">// If completed_ is already set, we're done here: don't suspend.</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">completed_</span><span class="special">)</span> <span class="special">{</span>
            <span class="comment">// suspend(unique_lock&lt;spinlock&gt;) unlocks the lock in the act of</span>
            <span class="comment">// resuming another fiber</span>
            <span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span><span class="special">::</span><span class="identifier">active</span><span class="special">()-&gt;</span><span class="identifier">suspend</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            Supposing that the pending async operation has not yet completed, <code class="computeroutput"><span class="identifier">yield_completion</span><span class="special">::</span><span class="identifier">completed_</span></code> will still be <code class="computeroutput"><span class="keyword">false</span></code>, and <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code> will call <a class="link" href="../../scheduling.html#context_suspend"> <code class="computeroutput">context::suspend()</code></a> on
            the currently-running fiber.
          </p>
<p>
            Other fibers will now have a chance to run.
          </p>
<p>
            Some time later, the async operation completes. It calls <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span> <span class="keyword">const</span><span class="special">&amp;)</span></code> with an <code class="computeroutput"><span class="identifier">error_code</span></code>
            indicating either success or failure. We'll consider both cases.
          </p>
<p>
            <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;</span></code>
            explicitly inherits <code class="computeroutput"><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span>
            <span class="keyword">const</span><span class="special">&amp;)</span></code>
            from <code class="computeroutput"><span class="identifier">yield_handler_base</span></code>.
          </p>
<p>
            <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span> <span class="keyword">const</span><span class="special">&amp;)</span></code> first sets <code class="computeroutput"><span class="identifier">yield_completion</span><span class="special">::</span><span class="identifier">completed_</span></code>
            <code class="computeroutput"><span class="keyword">true</span></code>. This way, if <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>'s
            async operation completes immediately &#8212; if <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> is called even before <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">get</span><span class="special">()</span></code>
            &#8212; the calling fiber will <span class="emphasis"><em>not</em></span> suspend.
          </p>
<p>
            The actual <code class="computeroutput"><span class="identifier">error_code</span></code>
            produced by the async operation is then stored through the stored <code class="computeroutput"><span class="identifier">yield_t</span><span class="special">::</span><span class="identifier">ec_</span></code> pointer. If <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>'s caller used (e.g.) <code class="computeroutput"><span class="identifier">yield</span><span class="special">[</span><span class="identifier">my_ec</span><span class="special">]</span></code>
            to bind a local <code class="computeroutput"><span class="identifier">error_code</span></code>
            instance, the actual <code class="computeroutput"><span class="identifier">error_code</span></code>
            value is stored into the caller's variable. Otherwise, it is stored into
            <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">ec_</span></code>.
          </p>
<p>
            Finally we get to the distinction between <code class="computeroutput"><span class="identifier">yield</span></code>
            and <code class="computeroutput"><span class="identifier">yield_hop</span></code>.
          </p>
<p>
            As described for <a class="link" href="../../scheduling.html#context_is_context"> <code class="computeroutput">context::is_context()</code></a>, a <code class="computeroutput"><span class="identifier">pinned_context</span></code> fiber is special to
            the library and must never be passed to <a class="link" href="../../scheduling.html#context_migrate"> <code class="computeroutput">context::migrate()</code></a>.
            We must detect and avoid that case here.
          </p>
<p>
            The <code class="computeroutput"><span class="identifier">yield_t</span><span class="special">::</span><span class="identifier">allow_hop_</span></code> <code class="computeroutput"><span class="keyword">bool</span></code>
            indicates whether <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>'s caller is willing to allow the running
            fiber to <span class="quote">&#8220;<span class="quote">hop</span>&#8221;</span> to another thread (<code class="computeroutput"><span class="identifier">yield_hop</span></code>)
            or whether s/he insists that the fiber resume on the same thread (<code class="computeroutput"><span class="identifier">yield</span></code>).
          </p>
<p>
            If the caller passed <code class="computeroutput"><span class="identifier">yield_hop</span></code>
            to <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>,
            and the running fiber isn't a <code class="computeroutput"><span class="identifier">pinned_context</span></code>,
            <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code>
            passes the <code class="computeroutput"><span class="identifier">context</span></code> of
            the original fiber &#8212; the one on which <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> was called, captured in <code class="computeroutput"><span class="identifier">yield_handler_base</span></code>'s constructor &#8212; to
            the current thread's <a class="link" href="../../scheduling.html#context_migrate"> <code class="computeroutput">context::migrate()</code></a>.
          </p>
<p>
            If the running application has more than one thread calling <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service/run.html" target="_top"><code class="computeroutput"><span class="identifier">io_service</span><span class="special">::</span><span class="identifier">run</span><span class="special">()</span></code></a>,
            that fiber could return from <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> on a different thread (the one calling
            <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code>)
            than the one on which it entered <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>.
          </p>
<p>
            In any case, the fiber is marked as ready to run by passing it to <a class="link" href="../../scheduling.html#context_set_ready"> <code class="computeroutput">context::set_ready()</code></a>.
            Control then returns from <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code>: the callback is done.
          </p>
<p>
            In due course, the fiber <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="identifier">ctx_</span></code>
            is resumed. Control returns from <a class="link" href="../../scheduling.html#context_suspend"> <code class="computeroutput">context::suspend()</code></a> to
            <code class="computeroutput"><span class="identifier">yield_completion</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code>,
            which returns to <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">get</span><span class="special">()</span></code>.
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                If the original caller passed <code class="computeroutput"><span class="identifier">yield</span><span class="special">[</span><span class="identifier">my_ec</span><span class="special">]</span></code> to <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> to bind a local <code class="computeroutput"><span class="identifier">error_code</span></code>
                instance, then <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> stored its <code class="computeroutput"><span class="identifier">error_code</span></code>
                to the caller's <code class="computeroutput"><span class="identifier">my_ec</span></code>
                instance, leaving <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">ec_</span></code>
                initialized to success.
              </li>
<li class="listitem">
                If the original caller passed <code class="computeroutput"><span class="identifier">yield</span></code>
                to <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> without binding a local <code class="computeroutput"><span class="identifier">error_code</span></code> variable, then <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code>
                stored its <code class="computeroutput"><span class="identifier">error_code</span></code>
                into <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">ec_</span></code>.
                If in fact that <code class="computeroutput"><span class="identifier">error_code</span></code>
                is success, then all is well.
              </li>
<li class="listitem">
                Otherwise &#8212; the original caller did not bind a local <code class="computeroutput"><span class="identifier">error_code</span></code> and <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()</span></code> was called with an <code class="computeroutput"><span class="identifier">error_code</span></code> indicating error &#8212; <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">get</span><span class="special">()</span></code>
                throws <code class="computeroutput"><span class="identifier">system_error</span></code>
                with that <code class="computeroutput"><span class="identifier">error_code</span></code>.
              </li>
</ul></div>
<p>
            The case in which <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>'s completion callback has signature
            <code class="computeroutput"><span class="keyword">void</span><span class="special">()</span></code>
            is similar. <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">&gt;::</span><span class="keyword">operator</span><span class="special">()()</span></code> invokes the machinery above with
            a <span class="quote">&#8220;<span class="quote">success</span>&#8221;</span> <code class="computeroutput"><span class="identifier">error_code</span></code>.
          </p>
<p>
            A completion callback with signature <code class="computeroutput"><span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">T</span><span class="special">)</span></code> (that is: in addition to <code class="computeroutput"><span class="identifier">error_code</span></code>, callback receives some
            data item) is handled somewhat differently. For this kind of signature,
            <code class="computeroutput"><span class="identifier">handler_type</span><span class="special">&lt;&gt;::</span><span class="identifier">type</span></code> specifies <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> (for <code class="computeroutput"><span class="identifier">T</span></code>
            other than <code class="computeroutput"><span class="keyword">void</span></code>).
          </p>
<p>
            A <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            reserves a <code class="computeroutput"><span class="identifier">value_</span></code> pointer
            to a value of type <code class="computeroutput"><span class="identifier">T</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// asio uses handler_type&lt;completion token type, signature&gt;::type to decide</span>
<span class="comment">// what to instantiate as the actual handler. Below, we specialize</span>
<span class="comment">// handler_type&lt; yield_t, ... &gt; to indicate yield_handler&lt;&gt;. So when you pass</span>
<span class="comment">// an instance of yield_t as an asio completion token, asio selects</span>
<span class="comment">// yield_handler&lt;&gt; as the actual handler class.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">yield_handler</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">yield_handler_base</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// asio passes the completion token to the handler constructor</span>
    <span class="keyword">explicit</span> <span class="identifier">yield_handler</span><span class="special">(</span> <span class="identifier">yield_t</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">yield_handler_base</span><span class="special">{</span> <span class="identifier">y</span> <span class="special">}</span> <span class="special">{</span>
    <span class="special">}</span>

    <span class="comment">// completion callback passing only value (T)</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">T</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// just like callback passing success error_code</span>
        <span class="special">(*</span><span class="keyword">this</span><span class="special">)(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span> <span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// completion callback passing (error_code, T)</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system</span><span class="special">::</span><span class="identifier">error_code</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">,</span> <span class="identifier">T</span> <span class="identifier">t</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">BOOST_ASSERT_MSG</span><span class="special">(</span> <span class="identifier">value_</span><span class="special">,</span>
                          <span class="string">"Must inject value ptr "</span>
                          <span class="string">"before caling yield_handler&lt;T&gt;::operator()()"</span><span class="special">);</span>
        <span class="comment">// move the value to async_result&lt;&gt; instance BEFORE waking up a</span>
        <span class="comment">// suspended fiber</span>
        <span class="special">*</span> <span class="identifier">value_</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">t</span><span class="special">);</span>
        <span class="comment">// forward the call to base-class completion handler</span>
        <span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()(</span> <span class="identifier">ec</span><span class="special">);</span>
    <span class="special">}</span>

<span class="comment">//private:</span>
    <span class="comment">// pointer to destination for eventual value</span>
    <span class="comment">// this must be injected by async_result before operator()() is called</span>
    <span class="identifier">T</span>                           <span class="special">*</span>   <span class="identifier">value_</span><span class="special">{</span> <span class="keyword">nullptr</span> <span class="special">};</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            This pointer is initialized to <code class="computeroutput"><span class="keyword">nullptr</span></code>.
          </p>
<p>
            When <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code> instantiates <code class="computeroutput"><span class="identifier">async_result</span><span class="special">&lt;</span><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// asio constructs an async_result&lt;&gt; instance from the yield_handler specified</span>
<span class="comment">// by handler_type&lt;&gt;::type. A particular asio async method constructs the</span>
<span class="comment">// yield_handler, constructs this async_result specialization from it, then</span>
<span class="comment">// returns the result of calling its get() method.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">async_result</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">yield_handler</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">:</span>
    <span class="keyword">public</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">async_result_base</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// type returned by get()</span>
    <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">type</span><span class="special">;</span>

    <span class="keyword">explicit</span> <span class="identifier">async_result</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">yield_handler</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">h</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">async_result_base</span><span class="special">{</span> <span class="identifier">h</span> <span class="special">}</span> <span class="special">{</span>
        <span class="comment">// Inject ptr to our value_ member into yield_handler&lt;&gt;: result will</span>
        <span class="comment">// be stored here.</span>
        <span class="identifier">h</span><span class="special">.</span><span class="identifier">value_</span> <span class="special">=</span> <span class="special">&amp;</span> <span class="identifier">value_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// asio async method returns result of calling get()</span>
    <span class="identifier">type</span> <span class="identifier">get</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">get</span><span class="special">();</span>
        <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span> <span class="identifier">value_</span><span class="special">);</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">type</span>                            <span class="identifier">value_</span><span class="special">{};</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            this <code class="computeroutput"><span class="identifier">async_result</span><span class="special">&lt;&gt;</span></code>
            specialization reserves a member of type <code class="computeroutput"><span class="identifier">T</span></code>
            to receive the passed data item, and sets <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value_</span></code>
            to point to its own data member.
          </p>
<p>
            <code class="computeroutput"><span class="identifier">async_result</span><span class="special">&lt;</span><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;</span></code>
            overrides <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>.
            The override calls <code class="computeroutput"><span class="identifier">async_result_base</span><span class="special">::</span><span class="identifier">get</span><span class="special">()</span></code>, so the calling fiber suspends as described
            above.
          </p>
<p>
            <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span><span class="special">,</span>
            <span class="identifier">T</span><span class="special">)</span></code>
            stores its passed <code class="computeroutput"><span class="identifier">T</span></code> value
            into <code class="computeroutput"><span class="identifier">async_result</span><span class="special">&lt;</span><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;::</span><span class="identifier">value_</span></code>.
          </p>
<p>
            Then it passes control to <code class="computeroutput"><span class="identifier">yield_handler_base</span><span class="special">::</span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">error_code</span><span class="special">)</span></code> to deal with waking (and possibly migrating)
            the original fiber as described above.
          </p>
<p>
            When <code class="computeroutput"><span class="identifier">async_result</span><span class="special">&lt;</span><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;::</span><span class="identifier">get</span><span class="special">()</span></code>
            resumes, it returns the stored <code class="computeroutput"><span class="identifier">value_</span></code>
            to <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>
            and ultimately to <code class="computeroutput"><span class="identifier">async_something</span><span class="special">()</span></code>'s caller.
          </p>
<p>
            The case of a callback signature <code class="computeroutput"><span class="keyword">void</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span></code> is handled by having <code class="computeroutput"><span class="identifier">yield_handler</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span><span class="special">)</span></code> engage the <code class="computeroutput"><span class="keyword">void</span><span class="special">(</span><span class="identifier">error_code</span><span class="special">,</span> <span class="identifier">T</span><span class="special">)</span></code> machinery, passing a <span class="quote">&#8220;<span class="quote">success</span>&#8221;</span>
            <code class="computeroutput"><span class="identifier">error_code</span></code>.
          </p>
<p>
            The source code above is found in <a href="../../../../../examples/asio/yield.hpp" target="_top">yield.hpp</a>
            and <a href="../../../../../examples/asio/detail/yield.hpp" target="_top">detail/yield.hpp</a>.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking"></a><a name="nonblocking"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking" title="Integrating Fibers with Nonblocking I/O">Integrating
          Fibers with Nonblocking I/O</a>
</h5></div></div></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.overview"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.overview">Overview</a>
          </h6>
<p>
            <span class="emphasis"><em>Nonblocking</em></span> I/O is distinct from <span class="emphasis"><em>asynchronous</em></span>
            I/O. A true async I/O operation promises to initiate the operation and
            notify the caller on completion, usually via some sort of callback (as
            described in <a class="link" href="pooled_fixedsize.html#callbacks">Integrating Fibers with Asynchronous
            Callbacks</a>).
          </p>
<p>
            In contrast, a nonblocking I/O operation refuses to start at all if it
            would be necessary to block, returning an error code such as <a href="http://man7.org/linux/man-pages/man3/errno.3.html" target="_top"><code class="computeroutput"><span class="identifier">EWOULDBLOCK</span></code></a>. The operation
            is performed only when it can complete immediately. In effect, the caller
            must repeatedly retry the operation until it stops returning <code class="computeroutput"><span class="identifier">EWOULDBLOCK</span></code>.
          </p>
<p>
            In a classic event-driven program, it can be something of a headache
            to use nonblocking I/O. At the point where the nonblocking I/O is attempted,
            a return value of <code class="computeroutput"><span class="identifier">EWOULDBLOCK</span></code>
            requires the caller to pass control back to the main event loop, arranging
            to retry again on the next iteration.
          </p>
<p>
            Worse, a nonblocking I/O operation might <span class="emphasis"><em>partially</em></span>
            succeed. That means that the relevant business logic must continue receiving
            control on every main loop iteration until all required data have been
            processed: a doubly-nested loop, implemented as a callback-driven state
            machine.
          </p>
<p>
            <span class="bold"><strong>Boost.Fiber</strong></span> can simplify this problem
            immensely. Once you have integrated with the application's main loop
            as described in <a class="link" href="pooled_fixedsize.html#integration">Sharing a Thread with Another
            Main Loop</a>, waiting for the next main-loop iteration is as simple
            as calling <a class="link" href="../../fiber_mgmt/this_fiber.html#this_fiber_yield"> <code class="computeroutput">this_fiber::yield()</code></a>.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.example_nonblocking_api"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.example_nonblocking_api">Example
            Nonblocking API</a>
          </h6>
<p>
            For purposes of illustration, consider this API:
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">NonblockingAPI</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">NonblockingAPI</span><span class="special">();</span>

    <span class="comment">// nonblocking operation: may return EWOULDBLOCK</span>
    <span class="keyword">int</span> <span class="identifier">read</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">desired</span><span class="special">);</span>

    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.h2"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.polling_for_completion"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.polling_for_completion">Polling
            for Completion</a>
          </h6>
<p>
            We can build a low-level wrapper around <code class="computeroutput"><span class="identifier">NonblockingAPI</span><span class="special">::</span><span class="identifier">read</span><span class="special">()</span></code> that shields its caller from ever having
            to deal with <code class="computeroutput"><span class="identifier">EWOULDBLOCK</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// guaranteed not to return EWOULDBLOCK</span>
<span class="keyword">int</span> <span class="identifier">read_chunk</span><span class="special">(</span> <span class="identifier">NonblockingAPI</span> <span class="special">&amp;</span> <span class="identifier">api</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">desired</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">error</span><span class="special">;</span>
    <span class="keyword">while</span> <span class="special">(</span> <span class="identifier">EWOULDBLOCK</span> <span class="special">==</span> <span class="special">(</span> <span class="identifier">error</span> <span class="special">=</span> <span class="identifier">api</span><span class="special">.</span><span class="identifier">read</span><span class="special">(</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">desired</span><span class="special">)</span> <span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="comment">// not ready yet -- try again on the next iteration of the</span>
        <span class="comment">// application's main loop</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">yield</span><span class="special">();</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">error</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.h3"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.filling_all_desired_data"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.filling_all_desired_data">Filling
            All Desired Data</a>
          </h6>
<p>
            Given <code class="computeroutput"><span class="identifier">read_chunk</span><span class="special">()</span></code>,
            we can straightforwardly iterate until we have all desired data:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// keep reading until desired length, EOF or error</span>
<span class="comment">// may return both partial data and nonzero error</span>
<span class="keyword">int</span> <span class="identifier">read_desired</span><span class="special">(</span> <span class="identifier">NonblockingAPI</span> <span class="special">&amp;</span> <span class="identifier">api</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">desired</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// we're going to accumulate results into 'data'</span>
    <span class="identifier">data</span><span class="special">.</span><span class="identifier">clear</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">chunk</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">error</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
    <span class="keyword">while</span> <span class="special">(</span> <span class="identifier">data</span><span class="special">.</span><span class="identifier">length</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">desired</span> <span class="special">&amp;&amp;</span>
           <span class="special">(</span> <span class="identifier">error</span> <span class="special">=</span> <span class="identifier">read_chunk</span><span class="special">(</span> <span class="identifier">api</span><span class="special">,</span> <span class="identifier">chunk</span><span class="special">,</span> <span class="identifier">desired</span> <span class="special">-</span> <span class="identifier">data</span><span class="special">.</span><span class="identifier">length</span><span class="special">()</span> <span class="special">)</span> <span class="special">)</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">data</span><span class="special">.</span><span class="identifier">append</span><span class="special">(</span> <span class="identifier">chunk</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">error</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            (Of <span class="emphasis"><em>course</em></span> there are more efficient ways to accumulate
            string data. That's not the point of this example.)
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.h4"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.wrapping_it_up"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.nonblocking.wrapping_it_up">Wrapping
            it Up</a>
          </h6>
<p>
            Finally, we can define a relevant exception:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// exception class augmented with both partially-read data and errorcode</span>
<span class="keyword">class</span> <span class="identifier">IncompleteRead</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">IncompleteRead</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">what</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">partial</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span> <span class="identifier">what</span><span class="special">),</span>
        <span class="identifier">partial_</span><span class="special">(</span> <span class="identifier">partial</span><span class="special">),</span>
        <span class="identifier">ec_</span><span class="special">(</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">{</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">get_partial</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">partial_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">int</span> <span class="identifier">get_errorcode</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">ec_</span><span class="special">;</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">partial_</span><span class="special">;</span>
    <span class="keyword">int</span>         <span class="identifier">ec_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<p>
            and write a simple <code class="computeroutput"><span class="identifier">read</span><span class="special">()</span></code> function that either returns all desired
            data or throws <code class="computeroutput"><span class="identifier">IncompleteRead</span></code>:
          </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// read all desired data or throw IncompleteRead</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">read</span><span class="special">(</span> <span class="identifier">NonblockingAPI</span> <span class="special">&amp;</span> <span class="identifier">api</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">desired</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">data</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">ec</span><span class="special">(</span> <span class="identifier">read_desired</span><span class="special">(</span> <span class="identifier">api</span><span class="special">,</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">desired</span><span class="special">)</span> <span class="special">);</span>

    <span class="comment">// for present purposes, EOF isn't a failure</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="number">0</span> <span class="special">==</span> <span class="identifier">ec</span> <span class="special">||</span> <span class="identifier">EOF</span> <span class="special">==</span> <span class="identifier">ec</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">data</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// oh oh, partial read</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span> <span class="identifier">msg</span><span class="special">;</span>
    <span class="identifier">msg</span> <span class="special">&lt;&lt;</span> <span class="string">"NonblockingAPI::read() error "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ec</span> <span class="special">&lt;&lt;</span> <span class="string">" after "</span>
        <span class="special">&lt;&lt;</span> <span class="identifier">data</span><span class="special">.</span><span class="identifier">length</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">" of "</span> <span class="special">&lt;&lt;</span> <span class="identifier">desired</span> <span class="special">&lt;&lt;</span> <span class="string">" characters"</span><span class="special">;</span>
    <span class="keyword">throw</span> <span class="identifier">IncompleteRead</span><span class="special">(</span> <span class="identifier">msg</span><span class="special">.</span><span class="identifier">str</span><span class="special">(),</span> <span class="identifier">data</span><span class="special">,</span> <span class="identifier">ec</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            Once we can transparently wait for the next main-loop iteration using
            <a class="link" href="../../fiber_mgmt/this_fiber.html#this_fiber_yield"> <code class="computeroutput">this_fiber::yield()</code></a>, ordinary encapsulation Just Works.
          </p>
<p>
            The source code above is found in <a href="../../../../../examples/adapt_nonblocking.cpp" target="_top">adapt_nonblocking.cpp</a>.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any"></a><a name="when_any"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any" title="when_any / when_all functionality">when_any
          / when_all functionality</a>
</h5></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any">when_any</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__simple_completion">when_any,
              simple completion</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__return_value">when_any,
              return value</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_outcome__whether_result_or_exception">when_any,
              produce first outcome, whether result or exception</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_success">when_any,
              produce first success</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__heterogeneous_types">when_any,
              heterogeneous types</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__a_dubious_alternative">when_any,
              a dubious alternative</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality">when_all
            functionality</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__simple_completion">when_all,
              simple completion</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values">when_all,
              return values</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all_until_first_exception">when_all
              until first exception</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.wait_all__collecting_all_exceptions">wait_all,
              collecting all exceptions</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__heterogeneous_types">when_all,
              heterogeneous types</a></span></dt>
</dl></dd>
</dl></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.overview"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.overview">Overview</a>
          </h6>
<p>
            A bit of wisdom from the early days of computing still holds true today:
            prefer to model program state using the instruction pointer rather than
            with Boolean flags. In other words, if the program must <span class="quote">&#8220;<span class="quote">do something</span>&#8221;</span>
            and then do something almost the same, but with minor changes... perhaps
            parts of that something should be broken out as smaller separate functions,
            rather than introducing flags to alter the internal behavior of a monolithic
            function.
          </p>
<p>
            To that we would add: prefer to describe control flow using C++ native
            constructs such as function calls, <code class="computeroutput"><span class="keyword">if</span></code>,
            <code class="computeroutput"><span class="keyword">while</span></code>, <code class="computeroutput"><span class="keyword">for</span></code>,
            <code class="computeroutput"><span class="keyword">do</span></code> et al. rather than as
            chains of callbacks.
          </p>
<p>
            One of the great strengths of <span class="bold"><strong>Boost.Fiber</strong></span>
            is the flexibility it confers on the coder to restructure an application
            from chains of callbacks to straightforward C++ statement sequence, even
            when code in that fiber is in fact interleaved with code running in other
            fibers.
          </p>
<p>
            There has been much recent discussion about the benefits of when_any
            and when_all functionality. When dealing with asynchronous and possibly
            unreliable services, these are valuable idioms. But of course when_any
            and when_all are closely tied to the use of chains of callbacks.
          </p>
<p>
            This section presents recipes for achieving the same ends, in the context
            of a fiber that wants to <span class="quote">&#8220;<span class="quote">do something</span>&#8221;</span> when one or more
            other independent activities have completed. Accordingly, these are
            <code class="computeroutput"><span class="identifier">wait_something</span><span class="special">()</span></code>
            functions rather than <code class="computeroutput"><span class="identifier">when_something</span><span class="special">()</span></code> functions. The expectation is that
            the calling fiber asks to launch those independent activities, then waits
            for them, then sequentially proceeds with whatever processing depends
            on those results.
          </p>
<p>
            The function names shown (e.g. <a class="link" href="pooled_fixedsize.html#wait_first_simple"><code class="computeroutput"><span class="identifier">wait_first_simple</span><span class="special">()</span></code></a>)
            are for illustrative purposes only, because all these functions have
            been bundled into a single source file. Presumably, if (say) <a class="link" href="pooled_fixedsize.html#wait_first_success"><code class="computeroutput"><span class="identifier">wait_first_success</span><span class="special">()</span></code></a>
            best suits your application needs, you could introduce that variant with
            the name <code class="computeroutput"><span class="identifier">wait_any</span><span class="special">()</span></code>.
          </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The functions presented in this section accept variadic argument lists
              of task functions. Corresponding <code class="computeroutput"><span class="identifier">wait_something</span><span class="special">()</span></code> functions accepting a container of
              task functions are left as an exercise for the interested reader. Those
              should actually be simpler. Most of the complexity would arise from
              overloading the same name for both purposes.
            </p></td></tr>
</table></div>
<p>
            All the source code for this section is found in <a href="../../../../../examples/wait_stuff.cpp" target="_top">wait_stuff.cpp</a>.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.example_task_function"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.example_task_function">Example
            Task Function</a>
          </h6>
<p>
            <a name="wait_sleeper"></a>We found it convenient to model an asynchronous
            task using this function:
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
<span class="identifier">T</span> <span class="identifier">sleeper_impl</span><span class="special">(</span> <span class="identifier">T</span> <span class="identifier">item</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">ms</span><span class="special">,</span> <span class="keyword">bool</span> <span class="identifier">thrw</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span> <span class="identifier">descb</span><span class="special">,</span> <span class="identifier">funcb</span><span class="special">;</span>
    <span class="identifier">descb</span> <span class="special">&lt;&lt;</span> <span class="identifier">item</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">desc</span><span class="special">(</span> <span class="identifier">descb</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">);</span>
    <span class="identifier">funcb</span> <span class="special">&lt;&lt;</span> <span class="string">"  sleeper("</span> <span class="special">&lt;&lt;</span> <span class="identifier">item</span> <span class="special">&lt;&lt;</span> <span class="string">")"</span><span class="special">;</span>
    <span class="identifier">Verbose</span> <span class="identifier">v</span><span class="special">(</span> <span class="identifier">funcb</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">);</span>

    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">sleep_for</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">milliseconds</span><span class="special">(</span> <span class="identifier">ms</span><span class="special">)</span> <span class="special">);</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">thrw</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span> <span class="identifier">desc</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">return</span> <span class="identifier">item</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            with type-specific <code class="computeroutput"><span class="identifier">sleeper</span><span class="special">()</span></code> <span class="quote">&#8220;<span class="quote">front ends</span>&#8221;</span> for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>, <code class="computeroutput"><span class="keyword">double</span></code>
            and <code class="computeroutput"><span class="keyword">int</span></code>.
          </p>
<p>
            <code class="computeroutput"><span class="identifier">Verbose</span></code> simply prints
            a message to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span></code> on construction and destruction.
          </p>
<p>
            Basically:
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                <code class="computeroutput"><span class="identifier">sleeper</span><span class="special">()</span></code>
                prints a start message;
              </li>
<li class="listitem">
                sleeps for the specified number of milliseconds;
              </li>
<li class="listitem">
                if <code class="computeroutput"><span class="identifier">thrw</span></code> is passed
                as <code class="computeroutput"><span class="keyword">true</span></code>, throws a string
                description of the passed <code class="computeroutput"><span class="identifier">item</span></code>;
              </li>
<li class="listitem">
                else returns the passed <code class="computeroutput"><span class="identifier">item</span></code>.
              </li>
<li class="listitem">
                On the way out, <code class="computeroutput"><span class="identifier">sleeper</span><span class="special">()</span></code> produces a stop message.
              </li>
</ol></div>
<p>
            This function will feature in the example calls to the various functions
            presented below.
          </p>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any" title="when_any">when_any</a>
</h6></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__simple_completion">when_any,
              simple completion</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__return_value">when_any,
              return value</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_outcome__whether_result_or_exception">when_any,
              produce first outcome, whether result or exception</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_success">when_any,
              produce first success</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__heterogeneous_types">when_any,
              heterogeneous types</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__a_dubious_alternative">when_any,
              a dubious alternative</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__simple_completion"></a><a name="wait_first_simple_section"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__simple_completion" title="when_any, simple completion">when_any,
              simple completion</a>
</h6></div></div></div>
<p>
                The simplest case is when you only need to know that the first of
                a set of asynchronous tasks has completed &#8212; but you don't need to obtain
                a return value, and you're confident that they will not throw exceptions.
              </p>
<p>
                <a name="wait_done"></a>For this we introduce a <code class="computeroutput"><span class="identifier">Done</span></code>
                class to wrap a <code class="computeroutput"><span class="keyword">bool</span></code>
                variable with a <a class="link" href="pooled_fixedsize.html#class_condition_variable"> <code class="computeroutput">condition_variable</code></a> and a <a class="link" href="pooled_fixedsize.html#class_mutex"> <code class="computeroutput">mutex</code></a>:
              </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Wrap canonical pattern for condition_variable + bool flag</span>
<span class="keyword">struct</span> <span class="identifier">Done</span> <span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">condition_variable</span>   <span class="identifier">cond</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span>                <span class="identifier">mutex</span><span class="special">;</span>
    <span class="keyword">bool</span>                                <span class="identifier">ready</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">Done</span> <span class="special">&gt;</span>     <span class="identifier">ptr</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span> <span class="identifier">mutex</span><span class="special">);</span>
        <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lock</span><span class="special">,</span> <span class="special">[</span><span class="keyword">this</span><span class="special">](){</span> <span class="keyword">return</span> <span class="identifier">ready</span><span class="special">;</span> <span class="special">});</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">notify</span><span class="special">()</span> <span class="special">{</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span> <span class="identifier">mutex</span><span class="special">);</span>
            <span class="identifier">ready</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
        <span class="special">}</span> <span class="comment">// release mutex</span>
        <span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
              </p>
<p>
                The pattern we follow throughout this section is to pass a <a href="http://www.cplusplus.com/reference/memory/shared_ptr/" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;&gt;</span></code></a>
                to the relevant synchronization object to the various tasks' fiber
                functions. This eliminates nagging questions about the lifespan of
                the synchronization object relative to the last of the fibers.
              </p>
<p>
                <a name="wait_first_simple"></a><code class="computeroutput"><span class="identifier">wait_first_simple</span><span class="special">()</span></code> uses that tactic for <a class="link" href="pooled_fixedsize.html#wait_done"><code class="computeroutput"><span class="identifier">Done</span></code></a>:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_first_simple</span><span class="special">(</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Use shared_ptr because each function's fiber will bind it separately,</span>
    <span class="comment">// and we're going to return before the last of them completes.</span>
    <span class="keyword">auto</span> <span class="identifier">done</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">Done</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="identifier">wait_first_simple_impl</span><span class="special">(</span> <span class="identifier">done</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="identifier">done</span><span class="special">-&gt;</span><span class="identifier">wait</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                <a name="wait_first_simple_impl"></a><code class="computeroutput"><span class="identifier">wait_first_simple_impl</span><span class="special">()</span></code> is an ordinary recursion over the
                argument pack, capturing <code class="computeroutput"><span class="identifier">Done</span><span class="special">::</span><span class="identifier">ptr</span></code>
                for each new fiber:
              </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Degenerate case: when there are no functions to wait for, return</span>
<span class="comment">// immediately.</span>
<span class="keyword">void</span> <span class="identifier">wait_first_simple_impl</span><span class="special">(</span> <span class="identifier">Done</span><span class="special">::</span><span class="identifier">ptr</span><span class="special">)</span> <span class="special">{</span>
<span class="special">}</span>

<span class="comment">// When there's at least one function to wait for, launch it and recur to</span>
<span class="comment">// process the rest.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_first_simple_impl</span><span class="special">(</span> <span class="identifier">Done</span><span class="special">::</span><span class="identifier">ptr</span> <span class="identifier">done</span><span class="special">,</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">(</span> <span class="special">[</span><span class="identifier">done</span><span class="special">,</span> <span class="identifier">function</span><span class="special">](){</span>
                              <span class="identifier">function</span><span class="special">();</span>
                              <span class="identifier">done</span><span class="special">-&gt;</span><span class="identifier">notify</span><span class="special">();</span>
                          <span class="special">}).</span><span class="identifier">detach</span><span class="special">();</span>
    <span class="identifier">wait_first_simple_impl</span><span class="special">(</span> <span class="identifier">done</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                The body of the fiber's lambda is extremely simple, as promised:
                call the function, notify <a class="link" href="pooled_fixedsize.html#wait_done"><code class="computeroutput"><span class="identifier">Done</span></code></a> when it returns. The
                first fiber to do so allows <code class="computeroutput"><span class="identifier">wait_first_simple</span><span class="special">()</span></code> to return &#8212; which is why it's useful
                to have <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">Done</span><span class="special">&gt;</span></code>
                manage the lifespan of our <code class="computeroutput"><span class="identifier">Done</span></code>
                object rather than declaring it as a stack variable in <code class="computeroutput"><span class="identifier">wait_first_simple</span><span class="special">()</span></code>.
              </p>
<p>
                This is how you might call it:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">wait_first_simple</span><span class="special">(</span>
        <span class="special">[](){</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfs_long"</span><span class="special">,</span>   <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfs_medium"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfs_short"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
</pre>
<p>
              </p>
<p>
                In this example, control resumes after <code class="computeroutput"><span class="identifier">wait_first_simple</span><span class="special">()</span></code> when <a class="link" href="pooled_fixedsize.html#wait_sleeper"><code class="computeroutput"><span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfs_short"</span><span class="special">,</span>
                <span class="number">50</span><span class="special">)</span></code></a>
                completes &#8212; even though the other two <code class="computeroutput"><span class="identifier">sleeper</span><span class="special">()</span></code> fibers are still running.
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__return_value"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__return_value" title="when_any, return value">when_any,
              return value</a>
</h6></div></div></div>
<p>
                It seems more useful to add the ability to capture the return value
                from the first of the task functions to complete. Again, we assume
                that none will throw an exception.
              </p>
<p>
                One tactic would be to adapt our <a class="link" href="pooled_fixedsize.html#wait_done"><code class="computeroutput"><span class="identifier">Done</span></code></a> class to store the
                first of the return values, rather than a simple <code class="computeroutput"><span class="keyword">bool</span></code>.
                However, we choose instead to use a <a class="link" href="pooled_fixedsize.html#class_unbounded_channel"> <code class="computeroutput">unbounded_channel&lt;&gt;</code></a>.
                We'll only need to enqueue the first value, so we'll <a class="link" href="pooled_fixedsize.html#unbounded_channel_close"> <code class="computeroutput">unbounded_channel::close()</code></a> it
                once we've retrieved that value. Subsequent <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code> calls will return <code class="computeroutput"><span class="identifier">closed</span></code>.
              </p>
<p>
                <a name="wait_first_value"></a>
</p>
<pre class="programlisting"><span class="comment">// Assume that all passed functions have the same return type. The return type</span>
<span class="comment">// of wait_first_value() is the return type of the first passed function. It is</span>
<span class="comment">// simply invalid to pass NO functions.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">wait_first_value</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">channel_t</span><span class="special">;</span>
    <span class="keyword">auto</span> <span class="identifier">channelp</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">channel_t</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="comment">// launch all the relevant fibers</span>
    <span class="identifier">wait_first_value_impl</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;(</span> <span class="identifier">channelp</span><span class="special">,</span>
                                       <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">),</span>
                                       <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="comment">// retrieve the first value</span>
    <span class="identifier">return_t</span> <span class="identifier">value</span><span class="special">(</span> <span class="identifier">channelp</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span> <span class="special">);</span>
    <span class="comment">// close the channel: no subsequent push() has to succeed</span>
    <span class="identifier">channelp</span><span class="special">-&gt;</span><span class="identifier">close</span><span class="special">();</span>
    <span class="keyword">return</span> <span class="identifier">value</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                <a name="wait_first_value_impl"></a>The meat of the <code class="computeroutput"><span class="identifier">wait_first_value_impl</span><span class="special">()</span></code>
                function is as you might expect:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Fn</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_first_value_impl</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">channel</span><span class="special">,</span>
                            <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">(</span> <span class="special">[</span><span class="identifier">channel</span><span class="special">,</span> <span class="identifier">function</span><span class="special">](){</span>
                              <span class="comment">// Ignore channel_op_status returned by push():</span>
                              <span class="comment">// might be closed; we simply don't care.</span>
                              <span class="identifier">channel</span><span class="special">-&gt;</span><span class="identifier">push</span><span class="special">(</span> <span class="identifier">function</span><span class="special">()</span> <span class="special">);</span>
                          <span class="special">}).</span><span class="identifier">detach</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                It calls the passed function, pushes its return value and ignores
                the <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>
                result. You might call it like this:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">wait_first_value</span><span class="special">(</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfv_third"</span><span class="special">,</span>  <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfv_second"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfv_first"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_first_value() =&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="string">"wfv_first"</span><span class="special">);</span>
</pre>
<p>
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_outcome__whether_result_or_exception"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_outcome__whether_result_or_exception" title="when_any, produce first outcome, whether result or exception">when_any,
              produce first outcome, whether result or exception</a>
</h6></div></div></div>
<p>
                We may not be running in an environment in which we can guarantee
                no exception will be thrown by any of our task functions. In that
                case, the above implementations of <code class="computeroutput"><span class="identifier">wait_first_something</span><span class="special">()</span></code> would be na&#239;ve: as mentioned in
                <a class="link" href="../../fiber_mgmt.html#exceptions">the section on Fiber Management</a>,
                an uncaught exception in one of our task fibers would cause <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span><span class="special">()</span></code>
                to be called.
              </p>
<p>
                Let's at least ensure that such an exception would propagate to the
                fiber awaiting the first result. We can use <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a> to
                transport either a return value or an exception. Therefore, we will
                change <a class="link" href="pooled_fixedsize.html#wait_first_value"><code class="computeroutput"><span class="identifier">wait_first_value</span><span class="special">()</span></code></a>'s <a class="link" href="pooled_fixedsize.html#class_unbounded_channel"> <code class="computeroutput">unbounded_channel&lt;&gt;</code></a> to
                hold <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;</span>
                <span class="identifier">T</span> <span class="special">&gt;</span></code>
                items instead of simply <code class="computeroutput"><span class="identifier">T</span></code>.
              </p>
<p>
                Once we have a <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> in hand, all we need do is
                call <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a>, which will either return the value
                or rethrow the exception.
              </p>
<p>
                <a name="wait_first_outcome"></a>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">wait_first_outcome</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// In this case, the value we pass through the channel is actually a</span>
    <span class="comment">// future -- which is already ready. future can carry either a value or an</span>
    <span class="comment">// exception.</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">future_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">future_t</span> <span class="special">&gt;</span> <span class="identifier">channel_t</span><span class="special">;</span>
    <span class="keyword">auto</span> <span class="identifier">channelp</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">channel_t</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="comment">// launch all the relevant fibers</span>
    <span class="identifier">wait_first_outcome_impl</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;(</span> <span class="identifier">channelp</span><span class="special">,</span>
                                         <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">),</span>
                                         <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="comment">// retrieve the first future</span>
    <span class="identifier">future_t</span> <span class="identifier">future</span><span class="special">(</span> <span class="identifier">channelp</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span> <span class="special">);</span>
    <span class="comment">// close the channel: no subsequent push() has to succeed</span>
    <span class="identifier">channelp</span><span class="special">-&gt;</span><span class="identifier">close</span><span class="special">();</span>
    <span class="comment">// either return value or throw exception</span>
    <span class="keyword">return</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                So far so good &#8212; but there's a timing issue. How should we obtain the
                <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>
                to <a class="link" href="pooled_fixedsize.html#unbounded_channel_push"> <code class="computeroutput">unbounded_channel::push()</code></a> on the channel?
              </p>
<p>
                We could call <a class="link" href="pooled_fixedsize.html#fibers_async"> <code class="computeroutput">fibers::async()</code></a>. That would certainly produce
                a <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>
                for the task function. The trouble is that it would return too quickly!
                We only want <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> items for <span class="emphasis"><em>completed</em></span>
                tasks on our <code class="computeroutput"><span class="identifier">unbounded_channel</span><span class="special">&lt;&gt;</span></code>. In fact, we only want the
                <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>
                for the one that completes first. If each fiber launched by <code class="computeroutput"><span class="identifier">wait_first_outcome</span><span class="special">()</span></code>
                were to <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>
                the result of calling <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code>, the channel would only ever report
                the result of the leftmost task item &#8212; <span class="emphasis"><em>not</em></span> the
                one that completes most quickly.
              </p>
<p>
                Calling <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a> on the future returned by <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code>
                wouldn't be right. You can only call <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code> once per <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> instance! And if there were
                an exception, it would be rethrown inside the helper fiber at the
                producer end of the channel, rather than propagated to the consumer
                end.
              </p>
<p>
                We could call <a class="link" href="pooled_fixedsize.html#future_wait"> <code class="computeroutput">future::wait()</code></a>. That would block the helper
                fiber until the <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> became ready, at which point
                we could <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>
                it to be retrieved by <code class="computeroutput"><span class="identifier">wait_first_outcome</span><span class="special">()</span></code>.
              </p>
<p>
                That would work &#8212; but there's a simpler tactic that avoids creating
                an extra fiber. We can wrap the task function in a <a class="link" href="pooled_fixedsize.html#class_packaged_task"> <code class="computeroutput">packaged_task&lt;&gt;</code></a>.
                While one naturally thinks of passing a <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code> to a new fiber &#8212; that is, in
                fact, what <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code> does &#8212; in this case, we're already
                running in the helper fiber at the producer end of the channel! We
                can simply <span class="emphasis"><em>call</em></span> the <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code>. On return from that call,
                the task function has completed, meaning that the <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> obtained from the <code class="computeroutput"><span class="identifier">packaged_task</span><span class="special">&lt;&gt;</span></code>
                is certain to be ready. At that point we can simply <code class="computeroutput"><span class="identifier">push</span><span class="special">()</span></code>
                it to the channel.
              </p>
<p>
                <a name="wait_first_outcome_impl"></a>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">CHANNELP</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Fn</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_first_outcome_impl</span><span class="special">(</span> <span class="identifier">CHANNELP</span> <span class="identifier">channel</span><span class="special">,</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">(</span>
        <span class="comment">// Use std::bind() here for C++11 compatibility. C++11 lambda capture</span>
        <span class="comment">// can't move a move-only Fn type, but bind() can. Let bind() move the</span>
        <span class="comment">// channel pointer and the function into the bound object, passing</span>
        <span class="comment">// references into the lambda.</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span>
            <span class="special">[](</span> <span class="identifier">CHANNELP</span> <span class="special">&amp;</span> <span class="identifier">channel</span><span class="special">,</span>
                <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&amp;</span> <span class="identifier">function</span><span class="special">)</span> <span class="special">{</span>
                <span class="comment">// Instantiate a packaged_task to capture any exception thrown by</span>
                <span class="comment">// function.</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">packaged_task</span><span class="special">&lt;</span> <span class="identifier">T</span><span class="special">()</span> <span class="special">&gt;</span> <span class="identifier">task</span><span class="special">(</span> <span class="identifier">function</span><span class="special">);</span>
                <span class="comment">// Immediately run this packaged_task on same fiber. We want</span>
                <span class="comment">// function() to have completed BEFORE we push the future.</span>
                <span class="identifier">task</span><span class="special">();</span>
                <span class="comment">// Pass the corresponding future to consumer. Ignore</span>
                <span class="comment">// channel_op_status returned by push(): might be closed; we</span>
                <span class="comment">// simply don't care.</span>
                <span class="identifier">channel</span><span class="special">-&gt;</span><span class="identifier">push</span><span class="special">(</span> <span class="identifier">task</span><span class="special">.</span><span class="identifier">get_future</span><span class="special">()</span> <span class="special">);</span>
            <span class="special">},</span>
            <span class="identifier">channel</span><span class="special">,</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">)</span>
        <span class="special">)).</span><span class="identifier">detach</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                Calling it might look like this:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">wait_first_outcome</span><span class="special">(</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfos_first"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfos_second"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfos_third"</span><span class="special">,</span>  <span class="number">150</span><span class="special">);</span> <span class="special">});</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_first_outcome(success) =&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="string">"wfos_first"</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">thrown</span><span class="special">;</span>
<span class="keyword">try</span> <span class="special">{</span>
    <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">wait_first_outcome</span><span class="special">(</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfof_first"</span><span class="special">,</span>   <span class="number">50</span><span class="special">,</span> <span class="keyword">true</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfof_second"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfof_third"</span><span class="special">,</span>  <span class="number">150</span><span class="special">);</span> <span class="special">});</span>
<span class="special">}</span> <span class="keyword">catch</span> <span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">e</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">thrown</span> <span class="special">=</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">();</span>
<span class="special">}</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_first_outcome(fail) threw '"</span> <span class="special">&lt;&lt;</span> <span class="identifier">thrown</span>
          <span class="special">&lt;&lt;</span> <span class="string">"'"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">thrown</span> <span class="special">==</span> <span class="string">"wfof_first"</span><span class="special">);</span>
</pre>
<p>
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_success"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__produce_first_success" title="when_any, produce first success">when_any,
              produce first success</a>
</h6></div></div></div>
<p>
                One scenario for <span class="quote">&#8220;<span class="quote">when_any</span>&#8221;</span> functionality is when we're
                redundantly contacting some number of possibly-unreliable web services.
                Not only might they be slow &#8212; any one of them might produce a failure
                rather than the desired result.
              </p>
<p>
                In such a case, <a class="link" href="pooled_fixedsize.html#wait_first_outcome"><code class="computeroutput"><span class="identifier">wait_first_outcome</span><span class="special">()</span></code></a>
                isn't the right approach. If one of the services produces an error
                quickly, while another follows up with a real answer, we don't want
                to prefer the error just because it arrived first!
              </p>
<p>
                Given the <code class="computeroutput"><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">T</span>
                <span class="special">&gt;</span> <span class="special">&gt;</span></code>
                we already constructed for <code class="computeroutput"><span class="identifier">wait_first_outcome</span><span class="special">()</span></code>, though, we can readily recast
                the interface function to deliver the first <span class="emphasis"><em>successful</em></span>
                result.
              </p>
<p>
                That does beg the question: what if <span class="emphasis"><em>all</em></span> the
                task functions throw an exception? In that case we'd probably better
                know about it.
              </p>
<p>
                <a name="exception_list"></a>The <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4407.html#parallel.exceptions.synopsis" target="_top">C++
                Parallelism Draft Technical Specification</a> proposes a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_list</span></code> exception capable
                of delivering a collection of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span></code>s.
                Until that becomes universally available, let's fake up an <code class="computeroutput"><span class="identifier">exception_list</span></code> of our own:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">exception_list</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">exception_list</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">what</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span> <span class="identifier">what</span><span class="special">)</span> <span class="special">{</span>
    <span class="special">}</span>

    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="special">&gt;</span>   <span class="identifier">bundle_t</span><span class="special">;</span>

    <span class="comment">// N4407 proposed std::exception_list API</span>
    <span class="keyword">typedef</span> <span class="identifier">bundle_t</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">iterator</span><span class="special">;</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">bundle_</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="identifier">iterator</span> <span class="identifier">begin</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">bundle_</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="identifier">iterator</span> <span class="identifier">end</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">bundle_</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="comment">// extension to populate</span>
    <span class="keyword">void</span> <span class="identifier">add</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">ep</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">bundle_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">ep</span><span class="special">);</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">bundle_t</span> <span class="identifier">bundle_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
              </p>
<p>
                Now we can build <code class="computeroutput"><span class="identifier">wait_first_success</span><span class="special">()</span></code>, using <a class="link" href="pooled_fixedsize.html#wait_first_outcome_impl"><code class="computeroutput"><span class="identifier">wait_first_outcome_impl</span><span class="special">()</span></code></a>.
              </p>
<p>
                Instead of retrieving only the first <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> from the channel, we must
                now loop over <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> items. Of course we must
                limit that iteration! If we launch only <code class="computeroutput"><span class="identifier">count</span></code>
                producer fibers, the <code class="computeroutput"><span class="special">(</span><span class="identifier">count</span><span class="special">+</span><span class="number">1</span><span class="special">)</span></code>
                <sup>st</sup>
   <a class="link" href="pooled_fixedsize.html#unbounded_channel_pop"> <code class="computeroutput">unbounded_channel::pop()</code></a> call would block forever.
              </p>
<p>
                Given a ready <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>, we can distinguish failure
                by calling <a class="link" href="pooled_fixedsize.html#future_get_exception_ptr"> <code class="computeroutput">future::get_exception_ptr()</code></a>. If
                the <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>
                in fact contains a result rather than an exception, <code class="computeroutput"><span class="identifier">get_exception_ptr</span><span class="special">()</span></code>
                returns <code class="computeroutput"><span class="keyword">nullptr</span></code>. In
                that case, we can confidently call <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a> to return
                that result to our caller.
              </p>
<p>
                If the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span></code> is <span class="emphasis"><em>not</em></span>
                <code class="computeroutput"><span class="keyword">nullptr</span></code>, though, we
                collect it into our pending <code class="computeroutput"><span class="identifier">exception_list</span></code>
                and loop back for the next <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code> from the channel.
              </p>
<p>
                If we fall out of the loop &#8212; if every single task fiber threw an exception
                &#8212; we throw the <code class="computeroutput"><span class="identifier">exception_list</span></code>
                exception into which we've been collecting those <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span></code>s.
              </p>
<p>
                <a name="wait_first_success"></a>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="identifier">wait_first_success</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">count</span><span class="special">(</span> <span class="number">1</span> <span class="special">+</span> <span class="keyword">sizeof</span> <span class="special">...</span> <span class="special">(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">);</span>
    <span class="comment">// In this case, the value we pass through the channel is actually a</span>
    <span class="comment">// future -- which is already ready. future can carry either a value or an</span>
    <span class="comment">// exception.</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;::</span><span class="identifier">type</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">future_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">future_t</span> <span class="special">&gt;</span> <span class="identifier">channel_t</span><span class="special">;</span>
    <span class="keyword">auto</span> <span class="identifier">channelp</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">channel_t</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="comment">// launch all the relevant fibers</span>
    <span class="identifier">wait_first_outcome_impl</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;(</span> <span class="identifier">channelp</span><span class="special">,</span>
                                         <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">),</span>
                                         <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="comment">// instantiate exception_list, just in case</span>
    <span class="identifier">exception_list</span> <span class="identifier">exceptions</span><span class="special">(</span><span class="string">"wait_first_success() produced only errors"</span><span class="special">);</span>
    <span class="comment">// retrieve up to 'count' results -- but stop there!</span>
    <span class="keyword">for</span> <span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">count</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// retrieve the next future</span>
        <span class="identifier">future_t</span> <span class="identifier">future</span><span class="special">(</span> <span class="identifier">channelp</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span> <span class="special">);</span>
        <span class="comment">// retrieve exception_ptr if any</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">error</span><span class="special">(</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get_exception_ptr</span><span class="special">()</span> <span class="special">);</span>
        <span class="comment">// if no error, then yay, return value</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">error</span><span class="special">)</span> <span class="special">{</span>
            <span class="comment">// close the channel: no subsequent push() has to succeed</span>
            <span class="identifier">channelp</span><span class="special">-&gt;</span><span class="identifier">close</span><span class="special">();</span>
            <span class="comment">// show caller the value we got</span>
            <span class="keyword">return</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">();</span>
        <span class="special">}</span>

        <span class="comment">// error is non-null: collect</span>
        <span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">add</span><span class="special">(</span> <span class="identifier">error</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="comment">// We only arrive here when every passed function threw an exception.</span>
    <span class="comment">// Throw our collection to inform caller.</span>
    <span class="keyword">throw</span> <span class="identifier">exceptions</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                A call might look like this:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">wait_first_success</span><span class="special">(</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfss_first"</span><span class="special">,</span>   <span class="number">50</span><span class="special">,</span> <span class="keyword">true</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfss_second"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfss_third"</span><span class="special">,</span>  <span class="number">150</span><span class="special">);</span> <span class="special">});</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_first_success(success) =&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="string">"wfss_second"</span><span class="special">);</span>
</pre>
<p>
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__heterogeneous_types"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__heterogeneous_types" title="when_any, heterogeneous types">when_any,
              heterogeneous types</a>
</h6></div></div></div>
<p>
                We would be remiss to ignore the case in which the various task functions
                have distinct return types. That means that the value returned by
                the first of them might have any one of those types. We can express
                that with <a href="http://www.boost.org/doc/libs/release/doc/html/variant.html" target="_top">Boost.Variant</a>.
              </p>
<p>
                To keep the example simple, we'll revert to pretending that none
                of them can throw an exception. That makes <code class="computeroutput"><span class="identifier">wait_first_value_het</span><span class="special">()</span></code> strongly resemble <a class="link" href="pooled_fixedsize.html#wait_first_value"><code class="computeroutput"><span class="identifier">wait_first_value</span><span class="special">()</span></code></a>.
                We can actually reuse <a class="link" href="pooled_fixedsize.html#wait_first_value_impl"><code class="computeroutput"><span class="identifier">wait_first_value_impl</span><span class="special">()</span></code></a>,
                merely passing <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="identifier">T0</span><span class="special">,</span> <span class="identifier">T1</span><span class="special">,</span> <span class="special">...&gt;</span></code>
                as the channel's value type rather than the common <code class="computeroutput"><span class="identifier">T</span></code>!
              </p>
<p>
                Naturally this could be extended to use <a class="link" href="pooled_fixedsize.html#wait_first_success"><code class="computeroutput"><span class="identifier">wait_first_success</span><span class="special">()</span></code></a>
                semantics instead.
              </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// No need to break out the first Fn for interface function: let the compiler</span>
<span class="comment">// complain if empty.</span>
<span class="comment">// Our functions have different return types, and we might have to return any</span>
<span class="comment">// of them. Use a variant, expanding std::result_of&lt;Fn()&gt;::type for each Fn in</span>
<span class="comment">// parameter pack.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fns</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">...</span> <span class="special">&gt;</span>
<span class="identifier">wait_first_value_het</span><span class="special">(</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Use unbounded_channel&lt;boost::variant&lt;T1, T2, ...&gt;&gt;; see remarks above.</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fns</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">...</span> <span class="special">&gt;</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">channel_t</span><span class="special">;</span>
    <span class="keyword">auto</span> <span class="identifier">channelp</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">channel_t</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="comment">// launch all the relevant fibers</span>
    <span class="identifier">wait_first_value_impl</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;(</span> <span class="identifier">channelp</span><span class="special">,</span>
                                       <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="comment">// retrieve the first value</span>
    <span class="identifier">return_t</span> <span class="identifier">value</span><span class="special">(</span> <span class="identifier">channelp</span><span class="special">-&gt;</span><span class="identifier">value_pop</span><span class="special">()</span> <span class="special">);</span>
    <span class="comment">// close the channel: no subsequent push() has to succeed</span>
    <span class="identifier">channelp</span><span class="special">-&gt;</span><span class="identifier">close</span><span class="special">();</span>
    <span class="keyword">return</span> <span class="identifier">value</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                It might be called like this:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">double</span><span class="special">,</span> <span class="keyword">int</span> <span class="special">&gt;</span> <span class="identifier">result</span> <span class="special">=</span>
    <span class="identifier">wait_first_value_het</span><span class="special">(</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wfvh_third"</span><span class="special">,</span>  <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="number">3.14</span><span class="special">,</span>          <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="number">17</span><span class="special">,</span>             <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_first_value_het() =&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get</span><span class="special">&lt;</span> <span class="keyword">int</span> <span class="special">&gt;(</span> <span class="identifier">result</span><span class="special">)</span> <span class="special">==</span> <span class="number">17</span><span class="special">);</span>
</pre>
<p>
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__a_dubious_alternative"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_any.when_any__a_dubious_alternative" title="when_any, a dubious alternative">when_any,
              a dubious alternative</a>
</h6></div></div></div>
<p>
                Certain topics in C++ can arouse strong passions, and exceptions
                are no exception. We cannot resist mentioning &#8212; for purely informational
                purposes &#8212; that when you need only the <span class="emphasis"><em>first</em></span> result
                from some number of concurrently-running fibers, it would be possible
                to pass a <code class="computeroutput">shared_ptr&lt; <a class="link" href="pooled_fixedsize.html#class_promise"> <code class="computeroutput">promise&lt;&gt;</code></a>&gt;</code> to the participating
                fibers, then cause the initiating fiber to call <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a> on
                its <a class="link" href="pooled_fixedsize.html#class_future"> <code class="computeroutput">future&lt;&gt;</code></a>. The first fiber to call <a class="link" href="pooled_fixedsize.html#promise_set_value"> <code class="computeroutput">promise::set_value()</code></a> on
                that shared <code class="computeroutput"><span class="identifier">promise</span></code>
                will succeed; subsequent <code class="computeroutput"><span class="identifier">set_value</span><span class="special">()</span></code> calls on the same <code class="computeroutput"><span class="identifier">promise</span></code> instance will throw <code class="computeroutput"><span class="identifier">future_error</span></code>.
              </p>
<p>
                Use this information at your own discretion. Beware the dark side.
              </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality" title="when_all functionality">when_all
            functionality</a>
</h6></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__simple_completion">when_all,
              simple completion</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values">when_all,
              return values</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all_until_first_exception">when_all
              until first exception</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.wait_all__collecting_all_exceptions">wait_all,
              collecting all exceptions</a></span></dt>
<dt><span class="section"><a href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__heterogeneous_types">when_all,
              heterogeneous types</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__simple_completion"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__simple_completion" title="when_all, simple completion">when_all,
              simple completion</a>
</h6></div></div></div>
<p>
                For the case in which we must wait for <span class="emphasis"><em>all</em></span> task
                functions to complete &#8212; but we don't need results (or expect exceptions)
                from any of them &#8212; we can write <code class="computeroutput"><span class="identifier">wait_all_simple</span><span class="special">()</span></code> that looks remarkably like <a class="link" href="pooled_fixedsize.html#wait_first_simple"><code class="computeroutput"><span class="identifier">wait_first_simple</span><span class="special">()</span></code></a>. The difference is that
                instead of our <a class="link" href="pooled_fixedsize.html#wait_done"><code class="computeroutput"><span class="identifier">Done</span></code></a>
                class, we instantiate a <a class="link" href="pooled_fixedsize.html#class_barrier"> <code class="computeroutput">barrier</code></a> and call its <a class="link" href="pooled_fixedsize.html#barrier_wait"> <code class="computeroutput">barrier::wait()</code></a>.
              </p>
<p>
                We initialize the <code class="computeroutput"><span class="identifier">barrier</span></code>
                with <code class="computeroutput"><span class="special">(</span><span class="identifier">count</span><span class="special">+</span><span class="number">1</span><span class="special">)</span></code> because we are launching <code class="computeroutput"><span class="identifier">count</span></code> fibers, plus the <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
                call within <code class="computeroutput"><span class="identifier">wait_all_simple</span><span class="special">()</span></code> itself.
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_all_simple</span><span class="special">(</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">count</span><span class="special">(</span> <span class="keyword">sizeof</span> <span class="special">...</span> <span class="special">(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">);</span>
    <span class="comment">// Initialize a barrier(count+1) because we'll immediately wait on it. We</span>
    <span class="comment">// don't want to wake up until 'count' more fibers wait on it. Even though</span>
    <span class="comment">// we'll stick around until the last of them completes, use shared_ptr</span>
    <span class="comment">// anyway because it's easier to be confident about lifespan issues.</span>
    <span class="keyword">auto</span> <span class="identifier">barrier</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">barrier</span> <span class="special">&gt;(</span> <span class="identifier">count</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">);</span>
    <span class="identifier">wait_all_simple_impl</span><span class="special">(</span> <span class="identifier">barrier</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="identifier">barrier</span><span class="special">-&gt;</span><span class="identifier">wait</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                As stated above, the only difference between <code class="computeroutput"><span class="identifier">wait_all_simple_impl</span><span class="special">()</span></code> and <a class="link" href="pooled_fixedsize.html#wait_first_simple_impl"><code class="computeroutput"><span class="identifier">wait_first_simple_impl</span><span class="special">()</span></code></a>
                is that the former calls <code class="computeroutput"><span class="identifier">barrier</span><span class="special">::</span><span class="identifier">wait</span><span class="special">()</span></code> rather than <code class="computeroutput"><span class="identifier">Done</span><span class="special">::</span><span class="identifier">notify</span><span class="special">()</span></code>:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_all_simple_impl</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">barrier</span> <span class="special">&gt;</span> <span class="identifier">barrier</span><span class="special">,</span>
                           <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">(</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span>
                <span class="special">[](</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">barrier</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">barrier</span><span class="special">,</span>
                    <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">decay</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&amp;</span> <span class="identifier">function</span><span class="special">)</span> <span class="keyword">mutable</span> <span class="special">{</span>
                        <span class="identifier">function</span><span class="special">();</span>
                        <span class="identifier">barrier</span><span class="special">-&gt;</span><span class="identifier">wait</span><span class="special">();</span>
                <span class="special">},</span>
                <span class="identifier">barrier</span><span class="special">,</span>
                <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">)</span>
            <span class="special">)).</span><span class="identifier">detach</span><span class="special">();</span>
    <span class="identifier">wait_all_simple_impl</span><span class="special">(</span> <span class="identifier">barrier</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                You might call it like this:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">wait_all_simple</span><span class="special">(</span>
        <span class="special">[](){</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"was_long"</span><span class="special">,</span>   <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"was_medium"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"was_short"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
</pre>
<p>
              </p>
<p>
                Control will not return from the <code class="computeroutput"><span class="identifier">wait_all_simple</span><span class="special">()</span></code> call until the last of its task
                functions has completed.
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values" title="when_all, return values">when_all,
              return values</a>
</h6></div></div></div>
<p>
                As soon as we want to collect return values from all the task functions,
                we can see right away how to reuse <a class="link" href="pooled_fixedsize.html#wait_first_value"><code class="computeroutput"><span class="identifier">wait_first_value</span><span class="special">()</span></code></a>'s
                channel&lt;T&gt; for the purpose. All we have to do is avoid closing
                it after the first value!
              </p>
<p>
                But in fact, collecting multiple values raises an interesting question:
                do we <span class="emphasis"><em>really</em></span> want to wait until the slowest
                of them has arrived? Wouldn't we rather process each result as soon
                as it becomes available?
              </p>
<p>
                Fortunately we can present both APIs. Let's define <code class="computeroutput"><span class="identifier">wait_all_values_source</span><span class="special">()</span></code>
                to return <code class="computeroutput"><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;</span></code>.<sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values.f0" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values.f0" class="footnote">7</a>]</sup>
              </p>
<p>
                <a name="wait_all_values"></a>Given <code class="computeroutput"><span class="identifier">wait_all_values_source</span><span class="special">()</span></code>, it's straightforward to implement
                <code class="computeroutput"><span class="identifier">wait_all_values</span><span class="special">()</span></code>:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span>
<span class="identifier">wait_all_values</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">count</span><span class="special">(</span> <span class="number">1</span> <span class="special">+</span> <span class="keyword">sizeof</span> <span class="special">...</span> <span class="special">(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">);</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">vector_t</span><span class="special">;</span>
    <span class="identifier">vector_t</span> <span class="identifier">results</span><span class="special">;</span>
    <span class="identifier">results</span><span class="special">.</span><span class="identifier">reserve</span><span class="special">(</span> <span class="identifier">count</span><span class="special">);</span>

    <span class="comment">// get channel</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">channel</span> <span class="special">=</span>
        <span class="identifier">wait_all_values_source</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">),</span>
                                <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="comment">// fill results vector</span>
    <span class="identifier">return_t</span> <span class="identifier">value</span><span class="special">;</span>
    <span class="keyword">while</span> <span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span><span class="special">::</span><span class="identifier">success</span> <span class="special">==</span> <span class="identifier">channel</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">(</span><span class="identifier">value</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">results</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">value</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="comment">// return vector to caller</span>
    <span class="keyword">return</span> <span class="identifier">results</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                It might be called like this:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">values</span> <span class="special">=</span>
    <span class="identifier">wait_all_values</span><span class="special">(</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wav_late"</span><span class="special">,</span>   <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wav_middle"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wav_early"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
</pre>
<p>
              </p>
<p>
                As you can see from the loop in <code class="computeroutput"><span class="identifier">wait_all_values</span><span class="special">()</span></code>, instead of requiring its caller
                to count values, we define <code class="computeroutput"><span class="identifier">wait_all_values_source</span><span class="special">()</span></code> to <a class="link" href="pooled_fixedsize.html#unbounded_channel_close"> <code class="computeroutput">unbounded_channel::close()</code></a> the
                channel when done. But how do we do that? Each producer fiber is
                independent. It has no idea whether it is the last one to <a class="link" href="pooled_fixedsize.html#unbounded_channel_push"> <code class="computeroutput">unbounded_channel::push()</code></a> a
                value.
              </p>
<p>
                <a name="wait_nchannel"></a>We can address that problem with a counting
                fa&#231;ade for the <code class="computeroutput"><span class="identifier">unbounded_channel</span><span class="special">&lt;&gt;</span></code>. In fact, our fa&#231;ade need
                only support the producer end of the channel.
              </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Introduce a channel facade that closes the channel once a specific number</span>
<span class="comment">// of items has been pushed. This allows an arbitrary consumer to read until</span>
<span class="comment">// 'closed' without itself having to count items.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">nchannel</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">nchannel</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">cp</span><span class="special">,</span>
              <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">lm</span><span class="special">):</span>
        <span class="identifier">channel_</span><span class="special">(</span> <span class="identifier">cp</span><span class="special">),</span>
        <span class="identifier">limit_</span><span class="special">(</span> <span class="identifier">lm</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">assert</span><span class="special">(</span><span class="identifier">channel_</span><span class="special">);</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="number">0</span> <span class="special">==</span> <span class="identifier">limit_</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">channel_</span><span class="special">-&gt;</span><span class="identifier">close</span><span class="special">();</span>
        <span class="special">}</span>
    <span class="special">}</span>

    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span> <span class="identifier">push</span><span class="special">(</span> <span class="identifier">T</span> <span class="special">&amp;&amp;</span> <span class="identifier">va</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span> <span class="identifier">ok</span> <span class="special">=</span>
            <span class="identifier">channel_</span><span class="special">-&gt;</span><span class="identifier">push</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;(</span> <span class="identifier">va</span><span class="special">)</span> <span class="special">);</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">ok</span> <span class="special">==</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span><span class="special">::</span><span class="identifier">success</span> <span class="special">&amp;&amp;</span>
             <span class="special">--</span><span class="identifier">limit_</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="special">{</span>
            <span class="comment">// after the 'limit_'th successful push, close the channel</span>
            <span class="identifier">channel_</span><span class="special">-&gt;</span><span class="identifier">close</span><span class="special">();</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="identifier">ok</span><span class="special">;</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span> <span class="special">&gt;</span>    <span class="identifier">channel_</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span>                                                 <span class="identifier">limit_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
              </p>
<p>
                <a name="wait_all_values_source"></a>Armed with <code class="computeroutput"><span class="identifier">nchannel</span><span class="special">&lt;&gt;</span></code>, we can implement <code class="computeroutput"><span class="identifier">wait_all_values_source</span><span class="special">()</span></code>.
                It starts just like <a class="link" href="pooled_fixedsize.html#wait_first_value"><code class="computeroutput"><span class="identifier">wait_first_value</span><span class="special">()</span></code></a>.
                The difference is that we wrap the <code class="computeroutput"><span class="identifier">unbounded_channel</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> with an <code class="computeroutput"><span class="identifier">nchannel</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> to pass to the producer fibers.
              </p>
<p>
                Then, of course, instead of popping the first value, closing the
                channel and returning it, we simply return the <code class="computeroutput"><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;</span></code>.
              </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Return a shared_ptr&lt;unbounded_channel&lt;T&gt;&gt; from which the caller can</span>
<span class="comment">// retrieve each new result as it arrives, until 'closed'.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="identifier">wait_all_values_source</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">count</span><span class="special">(</span> <span class="number">1</span> <span class="special">+</span> <span class="keyword">sizeof</span> <span class="special">...</span> <span class="special">(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">);</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">channel_t</span><span class="special">;</span>
    <span class="comment">// make the channel</span>
    <span class="keyword">auto</span> <span class="identifier">channelp</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">channel_t</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="comment">// and make an nchannel facade to close it after 'count' items</span>
    <span class="keyword">auto</span> <span class="identifier">ncp</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">nchannel</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="special">&gt;(</span> <span class="identifier">channelp</span><span class="special">,</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">);</span>
    <span class="comment">// pass that nchannel facade to all the relevant fibers</span>
    <span class="identifier">wait_all_values_impl</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;(</span> <span class="identifier">ncp</span><span class="special">,</span>
                                      <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">),</span>
                                      <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="comment">// then return the channel for consumer</span>
    <span class="keyword">return</span> <span class="identifier">channelp</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                For example:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">channel</span> <span class="special">=</span>
    <span class="identifier">wait_all_values_source</span><span class="special">(</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wavs_third"</span><span class="special">,</span>  <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wavs_second"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wavs_first"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">value</span><span class="special">;</span>
<span class="keyword">while</span> <span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span><span class="special">::</span><span class="identifier">success</span> <span class="special">==</span> <span class="identifier">channel</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">(</span><span class="identifier">value</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_all_values_source() =&gt; '"</span> <span class="special">&lt;&lt;</span> <span class="identifier">value</span>
              <span class="special">&lt;&lt;</span> <span class="string">"'"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                <a name="wait_all_values_impl"></a><code class="computeroutput"><span class="identifier">wait_all_values_impl</span><span class="special">()</span></code> really is just like <a class="link" href="pooled_fixedsize.html#wait_first_value_impl"><code class="computeroutput"><span class="identifier">wait_first_value_impl</span><span class="special">()</span></code></a>
                except for the use of <code class="computeroutput"><span class="identifier">nchannel</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> rather than <code class="computeroutput"><span class="identifier">unbounded_channel</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Fn</span> <span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">wait_all_values_impl</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">nchannel</span><span class="special">&lt;</span> <span class="identifier">T</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">channel</span><span class="special">,</span>
                           <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span><span class="special">(</span> <span class="special">[</span><span class="identifier">channel</span><span class="special">,</span> <span class="identifier">function</span><span class="special">](){</span>
                              <span class="identifier">channel</span><span class="special">-&gt;</span><span class="identifier">push</span><span class="special">(</span><span class="identifier">function</span><span class="special">());</span>
                          <span class="special">}).</span><span class="identifier">detach</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all_until_first_exception"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all_until_first_exception" title="when_all until first exception">when_all
              until first exception</a>
</h6></div></div></div>
<p>
                Naturally, just as with <a class="link" href="pooled_fixedsize.html#wait_first_outcome"><code class="computeroutput"><span class="identifier">wait_first_outcome</span><span class="special">()</span></code></a>,
                we can elaborate <a class="link" href="pooled_fixedsize.html#wait_all_values"><code class="computeroutput"><span class="identifier">wait_all_values</span><span class="special">()</span></code></a> and <a class="link" href="pooled_fixedsize.html#wait_all_values_source"><code class="computeroutput"><span class="identifier">wait_all_values_source</span><span class="special">()</span></code></a>
                by passing <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">T</span>
                <span class="special">&gt;</span></code> instead of plain <code class="computeroutput"><span class="identifier">T</span></code>.
              </p>
<p>
                <a name="wait_all_until_error"></a><code class="computeroutput"><span class="identifier">wait_all_until_error</span><span class="special">()</span></code> pops that <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">T</span>
                <span class="special">&gt;</span></code> and calls its <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a>:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span>
<span class="identifier">wait_all_until_error</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">count</span><span class="special">(</span> <span class="number">1</span> <span class="special">+</span> <span class="keyword">sizeof</span> <span class="special">...</span> <span class="special">(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">);</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">future_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">vector_t</span><span class="special">;</span>
    <span class="identifier">vector_t</span> <span class="identifier">results</span><span class="special">;</span>
    <span class="identifier">results</span><span class="special">.</span><span class="identifier">reserve</span><span class="special">(</span> <span class="identifier">count</span><span class="special">);</span>

    <span class="comment">// get channel</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">future_t</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">channel</span><span class="special">(</span>
            <span class="identifier">wait_all_until_error_source</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">),</span>
                                         <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">)</span> <span class="special">);</span>
    <span class="comment">// fill results vector</span>
    <span class="identifier">future_t</span> <span class="identifier">future</span><span class="special">;</span>
    <span class="keyword">while</span> <span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span><span class="special">::</span><span class="identifier">success</span> <span class="special">==</span> <span class="identifier">channel</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">(</span> <span class="identifier">future</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">results</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="special">}</span>
    <span class="comment">// return vector to caller</span>
    <span class="keyword">return</span> <span class="identifier">results</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                For example:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">thrown</span><span class="special">;</span>
<span class="keyword">try</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">values</span> <span class="special">=</span> <span class="identifier">wait_all_until_error</span><span class="special">(</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"waue_late"</span><span class="special">,</span>   <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"waue_middle"</span><span class="special">,</span> <span class="number">100</span><span class="special">,</span> <span class="keyword">true</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"waue_early"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
<span class="special">}</span> <span class="keyword">catch</span> <span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">e</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">thrown</span> <span class="special">=</span> <span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">();</span>
<span class="special">}</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_all_until_error(fail) threw '"</span> <span class="special">&lt;&lt;</span> <span class="identifier">thrown</span>
          <span class="special">&lt;&lt;</span> <span class="string">"'"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
              </p>
<p>
                <a name="wait_all_until_error_source"></a>Naturally this complicates
                the API for <code class="computeroutput"><span class="identifier">wait_all_until_error_source</span><span class="special">()</span></code>. The caller must both retrieve
                a <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;</span>
                <span class="identifier">T</span> <span class="special">&gt;</span></code>
                and call its <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code> method. It would, of course, be
                possible to return a fa&#231;ade over the consumer end of the channel
                that would implicitly perform the <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code> and return a simple <code class="computeroutput"><span class="identifier">T</span></code> (or throw).
              </p>
<p>
                The implementation is just as you would expect. Notice, however,
                that we can reuse <a class="link" href="pooled_fixedsize.html#wait_first_outcome_impl"><code class="computeroutput"><span class="identifier">wait_first_outcome_impl</span><span class="special">()</span></code></a>,
                passing the <code class="computeroutput"><span class="identifier">nchannel</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> rather than <code class="computeroutput"><span class="identifier">unbounded_channel</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>.
              </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Return a shared_ptr&lt;unbounded_channel&lt;future&lt;T&gt;&gt;&gt; from which the caller can</span>
<span class="comment">// get() each new result as it arrives, until 'closed'.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span>
            <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="identifier">wait_all_until_error_source</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">count</span><span class="special">(</span> <span class="number">1</span> <span class="special">+</span> <span class="keyword">sizeof</span> <span class="special">...</span> <span class="special">(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">);</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">future_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">future_t</span> <span class="special">&gt;</span> <span class="identifier">channel_t</span><span class="special">;</span>
    <span class="comment">// make the channel</span>
    <span class="keyword">auto</span> <span class="identifier">channelp</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">channel_t</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="comment">// and make an nchannel facade to close it after 'count' items</span>
    <span class="keyword">auto</span> <span class="identifier">ncp</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_shared</span><span class="special">&lt;</span> <span class="identifier">nchannel</span><span class="special">&lt;</span> <span class="identifier">future_t</span> <span class="special">&gt;</span> <span class="special">&gt;(</span> <span class="identifier">channelp</span><span class="special">,</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">);</span>
    <span class="comment">// pass that nchannel facade to all the relevant fibers</span>
    <span class="identifier">wait_first_outcome_impl</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;(</span> <span class="identifier">ncp</span><span class="special">,</span>
                                         <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">),</span>
                                         <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
    <span class="comment">// then return the channel for consumer</span>
    <span class="keyword">return</span> <span class="identifier">channelp</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                For example:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="identifier">future_t</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">future_t</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">channel</span> <span class="special">=</span>
    <span class="identifier">wait_all_until_error_source</span><span class="special">(</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wauess_third"</span><span class="special">,</span>  <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wauess_second"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
            <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wauess_first"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
<span class="identifier">future_t</span> <span class="identifier">future</span><span class="special">;</span>
<span class="keyword">while</span> <span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span><span class="special">::</span><span class="identifier">success</span> <span class="special">==</span> <span class="identifier">channel</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">(</span> <span class="identifier">future</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">value</span><span class="special">(</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_all_until_error_source(success) =&gt; '"</span> <span class="special">&lt;&lt;</span> <span class="identifier">value</span>
              <span class="special">&lt;&lt;</span> <span class="string">"'"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.wait_all__collecting_all_exceptions"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.wait_all__collecting_all_exceptions" title="wait_all, collecting all exceptions">wait_all,
              collecting all exceptions</a>
</h6></div></div></div>
<p>
                <a name="wait_all_collect_errors"></a>Given <a class="link" href="pooled_fixedsize.html#wait_all_until_error_source"><code class="computeroutput"><span class="identifier">wait_all_until_error_source</span><span class="special">()</span></code></a>,
                it might be more reasonable to make a <code class="computeroutput"><span class="identifier">wait_all_</span><span class="special">...()</span></code> that collects <span class="emphasis"><em>all</em></span>
                errors instead of presenting only the first:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="special">&gt;</span>
<span class="identifier">wait_all_collect_errors</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">function</span><span class="special">,</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">count</span><span class="special">(</span> <span class="number">1</span> <span class="special">+</span> <span class="keyword">sizeof</span> <span class="special">...</span> <span class="special">(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">);</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span><span class="special">&lt;</span> <span class="identifier">Fn</span><span class="special">()</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">return_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">future_t</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">return_t</span> <span class="special">&gt;</span> <span class="identifier">vector_t</span><span class="special">;</span>
    <span class="identifier">vector_t</span> <span class="identifier">results</span><span class="special">;</span>
    <span class="identifier">results</span><span class="special">.</span><span class="identifier">reserve</span><span class="special">(</span> <span class="identifier">count</span><span class="special">);</span>
    <span class="identifier">exception_list</span> <span class="identifier">exceptions</span><span class="special">(</span><span class="string">"wait_all_collect_errors() exceptions"</span><span class="special">);</span>

    <span class="comment">// get channel</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">unbounded_channel</span><span class="special">&lt;</span> <span class="identifier">future_t</span> <span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">channel</span><span class="special">(</span>
            <span class="identifier">wait_all_until_error_source</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fn</span> <span class="special">&gt;(</span> <span class="identifier">function</span><span class="special">),</span>
                                         <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">...</span> <span class="special">)</span> <span class="special">);</span>
    <span class="comment">// fill results and/or exceptions vectors</span>
    <span class="identifier">future_t</span> <span class="identifier">future</span><span class="special">;</span>
    <span class="keyword">while</span> <span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">channel_op_status</span><span class="special">::</span><span class="identifier">success</span> <span class="special">==</span> <span class="identifier">channel</span><span class="special">-&gt;</span><span class="identifier">pop</span><span class="special">(</span> <span class="identifier">future</span><span class="special">)</span> <span class="special">)</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">exp</span> <span class="special">=</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get_exception_ptr</span><span class="special">();</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">exp</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">results</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span> <span class="identifier">future</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">);</span>
        <span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span>
            <span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">add</span><span class="special">(</span> <span class="identifier">exp</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">}</span>
    <span class="comment">// if there were any exceptions, throw</span>
    <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">exceptions</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
        <span class="keyword">throw</span> <span class="identifier">exceptions</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="comment">// no exceptions: return vector to caller</span>
    <span class="keyword">return</span> <span class="identifier">results</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                The implementation is a simple variation on <a class="link" href="pooled_fixedsize.html#wait_first_success"><code class="computeroutput"><span class="identifier">wait_first_success</span><span class="special">()</span></code></a>,
                using the same <a class="link" href="pooled_fixedsize.html#exception_list"><code class="computeroutput"><span class="identifier">exception_list</span></code></a>
                exception class.
              </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__heterogeneous_types"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__heterogeneous_types" title="when_all, heterogeneous types">when_all,
              heterogeneous types</a>
</h6></div></div></div>
<p>
                But what about the case when we must wait for all results of different
                types?
              </p>
<p>
                We can present an API that is frankly quite cool. Consider a sample
                struct:
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">Data</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">;</span>
    <span class="keyword">double</span>      <span class="identifier">inexact</span><span class="special">;</span>
    <span class="keyword">int</span>         <span class="identifier">exact</span><span class="special">;</span>

    <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">&lt;&lt;(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">out</span><span class="special">,</span> <span class="identifier">Data</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">);</span>
    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
              </p>
<p>
                Let's fill its members from task functions all running concurrently:
              </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">Data</span> <span class="identifier">data</span> <span class="special">=</span> <span class="identifier">wait_all_members</span><span class="special">&lt;</span> <span class="identifier">Data</span> <span class="special">&gt;(</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wams_left"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="number">3.14</span><span class="special">,</span>        <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="number">17</span><span class="special">,</span>          <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_all_members&lt;Data&gt;(success) =&gt; "</span> <span class="special">&lt;&lt;</span> <span class="identifier">data</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
              </p>
<p>
                Note that for this case, we abandon the notion of capturing the earliest
                result first, and so on: we must fill exactly the passed struct in
                left-to-right order.
              </p>
<p>
                That permits a beautifully simple implementation:
              </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Explicitly pass Result. This can be any type capable of being initialized</span>
<span class="comment">// from the results of the passed functions, such as a struct.</span>
<span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Result</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Fns</span> <span class="special">&gt;</span>
<span class="identifier">Result</span> <span class="identifier">wait_all_members</span><span class="special">(</span> <span class="identifier">Fns</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Run each of the passed functions on a separate fiber, passing all their</span>
    <span class="comment">// futures to helper function for processing.</span>
    <span class="keyword">return</span> <span class="identifier">wait_all_members_get</span><span class="special">&lt;</span> <span class="identifier">Result</span> <span class="special">&gt;(</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span> <span class="identifier">Fns</span> <span class="special">&gt;(</span> <span class="identifier">functions</span><span class="special">)</span> <span class="special">)</span> <span class="special">...</span> <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Result</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Futures</span> <span class="special">&gt;</span>
<span class="identifier">Result</span> <span class="identifier">wait_all_members_get</span><span class="special">(</span> <span class="identifier">Futures</span> <span class="special">&amp;&amp;</span> <span class="special">...</span> <span class="identifier">futures</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// Fetch the results from the passed futures into Result's initializer</span>
    <span class="comment">// list. It's true that the get() calls here will block the implicit</span>
    <span class="comment">// iteration over futures -- but that doesn't matter because we won't be</span>
    <span class="comment">// done until the slowest of them finishes anyway. As results are</span>
    <span class="comment">// processed in argument-list order rather than order of completion, the</span>
    <span class="comment">// leftmost get() to throw an exception will cause that exception to</span>
    <span class="comment">// propagate to the caller.</span>
    <span class="keyword">return</span> <span class="identifier">Result</span><span class="special">{</span> <span class="identifier">futures</span><span class="special">.</span><span class="identifier">get</span><span class="special">()</span> <span class="special">...</span> <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
              </p>
<p>
                It is tempting to try to implement <code class="computeroutput"><span class="identifier">wait_all_members</span><span class="special">()</span></code> as a one-liner like this:
              </p>
<pre class="programlisting"><span class="keyword">return</span> <span class="identifier">Result</span><span class="special">{</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span><span class="identifier">functions</span><span class="special">).</span><span class="identifier">get</span><span class="special">()...</span> <span class="special">};</span>
</pre>
<p>
                The trouble with this tactic is that it would serialize all the task
                functions. The runtime makes a single pass through <code class="computeroutput"><span class="identifier">functions</span></code>, calling <a class="link" href="pooled_fixedsize.html#fibers_async"> <code class="computeroutput">fibers::async()</code></a> for
                each and then immediately calling <a class="link" href="pooled_fixedsize.html#future_get"> <code class="computeroutput">future::get()</code></a> on its returned
                <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>.
                That blocks the implicit loop. The above is almost equivalent to
                writing:
              </p>
<pre class="programlisting"><span class="keyword">return</span> <span class="identifier">Result</span><span class="special">{</span> <span class="identifier">functions</span><span class="special">()...</span> <span class="special">};</span>
</pre>
<p>
                in which, of course, there is no concurrency at all.
              </p>
<p>
                Passing the argument pack through a function-call boundary (<code class="computeroutput"><span class="identifier">wait_all_members_get</span><span class="special">()</span></code>)
                forces the runtime to make <span class="emphasis"><em>two</em></span> passes: one in
                <code class="computeroutput"><span class="identifier">wait_all_members</span><span class="special">()</span></code> to collect the <code class="computeroutput"><span class="identifier">future</span><span class="special">&lt;&gt;</span></code>s from all the <code class="computeroutput"><span class="identifier">async</span><span class="special">()</span></code>
                calls, the second in <code class="computeroutput"><span class="identifier">wait_all_members_get</span><span class="special">()</span></code> to fetch each of the results.
              </p>
<p>
                As noted in comments, within the <code class="computeroutput"><span class="identifier">wait_all_members_get</span><span class="special">()</span></code> parameter pack expansion pass,
                the blocking behavior of <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code> becomes irrelevant. Along the way,
                we will hit the <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code> for the slowest task function;
                after that every subsequent <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code> will complete in trivial time.
              </p>
<p>
                By the way, we could also use this same API to fill a vector or other
                collection:
              </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// If we don't care about obtaining results as soon as they arrive, and we</span>
<span class="comment">// prefer a result vector in passed argument order rather than completion</span>
<span class="comment">// order, wait_all_members() is another possible implementation of</span>
<span class="comment">// wait_all_until_error().</span>
<span class="keyword">auto</span> <span class="identifier">strings</span> <span class="special">=</span> <span class="identifier">wait_all_members</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&gt;</span> <span class="special">&gt;(</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wamv_left"</span><span class="special">,</span>   <span class="number">150</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wamv_middle"</span><span class="special">,</span> <span class="number">100</span><span class="special">);</span> <span class="special">},</span>
        <span class="special">[](){</span> <span class="keyword">return</span> <span class="identifier">sleeper</span><span class="special">(</span><span class="string">"wamv_right"</span><span class="special">,</span>   <span class="number">50</span><span class="special">);</span> <span class="special">});</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"wait_all_members&lt;vector&gt;() =&gt;"</span><span class="special">;</span>
<span class="keyword">for</span> <span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">str</span> <span class="special">:</span> <span class="identifier">strings</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" '"</span> <span class="special">&lt;&lt;</span> <span class="identifier">str</span> <span class="special">&lt;&lt;</span> <span class="string">"'"</span><span class="special">;</span>
<span class="special">}</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
              </p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.integration"></a><a name="integration"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.integration" title="Sharing a Thread with Another Main Loop">Sharing
          a Thread with Another Main Loop</a>
</h5></div></div></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.integration.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.integration.overview"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.integration.overview">Overview</a>
          </h6>
<p>
            As always with cooperative concurrency, it is important not to let any
            one fiber monopolize the processor too long: that could <span class="quote">&#8220;<span class="quote">starve</span>&#8221;</span>
            other ready fibers. This section discusses a couple of solutions.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.integration.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.integration.event_driven_program"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.integration.event_driven_program">Event-Driven
            Program</a>
          </h6>
<p>
            Consider a classic event-driven program, organized around a main loop
            that fetches and dispatches incoming I/O events. You are introducing
            <span class="bold"><strong>Boost.Fiber</strong></span> because certain asynchronous
            I/O sequences are logically sequential, and for those you want to write
            and maintain code that looks and acts sequential.
          </p>
<p>
            You are launching fibers on the application's main thread because certain
            of their actions will affect its user interface, and the application's
            UI framework permits UI operations only on the main thread. Or perhaps
            those fibers need access to main-thread data, and it would be too expensive
            in runtime (or development time) to robustly defend every such data item
            with thread synchronization primitives.
          </p>
<p>
            You must ensure that the application's main loop <span class="emphasis"><em>itself</em></span>
            doesn't monopolize the processor: that the fibers it launches will get
            the CPU cycles they need.
          </p>
<p>
            The solution is the same as for any fiber that might claim the CPU for
            an extended time: introduce calls to <a class="link" href="../../fiber_mgmt/this_fiber.html#this_fiber_yield"> <code class="computeroutput">this_fiber::yield()</code></a>.
            The most straightforward approach is to call <code class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></code> on every iteration of your existing
            main loop. In effect, this unifies the application's main loop with
            <span class="bold"><strong>Boost.Fiber</strong></span>'s internal main loop. <code class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></code>
            allows the fiber manager to run any fibers that have become ready since
            the previous iteration of the application's main loop. When these fibers
            have had a turn, control passes to the thread's main fiber, which returns
            from <code class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></code>
            and resumes the application's main loop.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.integration.h2"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.integration.integrating_with__ulink_url__http___www_boost_org_doc_libs_release_libs_asio_index_html__boost_asio__ulink_"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.integration.integrating_with__ulink_url__http___www_boost_org_doc_libs_release_libs_asio_index_html__boost_asio__ulink_">Integrating
            with <a href="http://www.boost.org/doc/libs/release/libs/asio/index.html" target="_top">Boost.Asio</a></a>
          </h6>
<p>
            More challenging is when the application's main loop is embedded in some
            other library or framework. Such an application will typically, after
            performing all necessary setup, pass control to some form of <code class="computeroutput"><span class="identifier">run</span><span class="special">()</span></code>
            function from which control does not return until application shutdown.
          </p>
<p>
            A <a href="http://www.boost.org/doc/libs/release/libs/asio/index.html" target="_top">Boost.Asio</a>
            program might call <a href="http://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/io_service/run.html" target="_top"><code class="computeroutput"><span class="identifier">io_service</span><span class="special">::</span><span class="identifier">run</span><span class="special">()</span></code></a>
            in this way.
          </p>
<p>
            The trick here is to arrange to pass control to <a class="link" href="../../fiber_mgmt/this_fiber.html#this_fiber_yield"> <code class="computeroutput">this_fiber::yield()</code></a> frequently.
            You can use an <a href="http://www.boost.org/doc/libs/1_59_0/doc/html/boost_asio/reference/high_resolution_timer.html" target="_top">Asio
            timer</a> for this purpose. Instantiate the timer, arranging to call
            a handler function when the timer expires:
          </p>
<p>
            [run_service]
          </p>
<p>
            The handler function calls <code class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></code>, then resets the timer and arranges
            to wake up again on expiration:
          </p>
<p>
            [timer_handler]
          </p>
<p>
            Then instead of directly calling <code class="computeroutput"><span class="identifier">io_service</span><span class="special">::</span><span class="identifier">run</span><span class="special">()</span></code>, your application would call the above
            <code class="computeroutput"><span class="identifier">run_service</span><span class="special">(</span><span class="identifier">io_service</span><span class="special">&amp;)</span></code>
            wrapper.
          </p>
<p>
            Since, in this example, we always pass control to the fiber manager via
            <code class="computeroutput"><span class="identifier">yield</span><span class="special">()</span></code>,
            the calling fiber is never blocked. Therefore there is always at least
            one ready fiber. Therefore the fiber manager never sleeps.
          </p>
<p>
            Using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">seconds</span><span class="special">(</span><span class="number">0</span><span class="special">)</span></code> for
            <span class="emphasis"><em>every</em></span> keepalive timer interval would be unfriendly
            to other threads. When all I/O is pending and all fibers are blocked,
            the io_service and the fiber manager would simply spin the CPU, passing
            control back and forth to each other. Resetting the timer for <code class="computeroutput"><span class="identifier">keepalive_iterval</span></code> allows tuning the
            responsiveness of this thread relative to others in the same way as when
            <span class="bold"><strong>Boost.Fiber</strong></span> is running without <a href="http://www.boost.org/doc/libs/release/libs/asio/index.html" target="_top">Boost.Asio</a>.
          </p>
<p>
            The source code above is found in <a href="../../../../../examples/asio/round_robin.hpp" target="_top">round_robin.hpp</a>.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.performance" title="Performance">Performance</a>
</h5></div></div></div>
<p>
            Performance measurements were taken using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">highresolution_clock</span></code>,
            with overhead corrections. The code was compiled using the build options:
            variant = release, optimization = speed <sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.f0" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.performance.f0" class="footnote">8</a>]</sup>.
          </p>
<p>
            The columns labeled <span class="bold"><strong>fiber (atomics)</strong></span>
            were compiled with default fiber synchronization, capable of synchronizing
            fibers running on different threads. The columns labeled <span class="bold"><strong>fiber
            (raw)</strong></span> were compiled with <a class="link" href="../../overview.html#cross_thread_sync"><code class="computeroutput"><span class="identifier">BOOST_FIBERS_NO_ATOMICS</span></code></a>.
          </p>
<div class="table">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.overhead_of_join__contains_fiber_context_destruction__fiber_stack_deallocation_"></a><p class="title"><b>Table&#160;1.1.&#160;Overhead of join (contains fiber-context destruction, fiber-stack
            deallocation)</b></p>
<div class="table-contents"><table class="table" summary="Overhead of join (contains fiber-context destruction, fiber-stack
            deallocation)">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      thread
                    </p>
                  </th>
<th>
                    <p>
                      fiber (atomics)
                    </p>
                  </th>
<th>
                    <p>
                      fiber (raw)
                    </p>
                  </th>
<th>
                    <p>
                      tbb
                    </p>
                  </th>
<th>
                    <p>
                      qthread
                    </p>
                  </th>
</tr></thead>
<tbody><tr>
<td>
                    <p>
                      18 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      950 ns
                    </p>
                  </td>
<td>
                    <p>
                      900 ns
                    </p>
                  </td>
<td>
                    <p>
                      570 ns
                    </p>
                  </td>
<td>
                    <p>
                      620 ns
                    </p>
                  </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
            (from <a href="../../../../../performance/fiber/overhead_join.cpp" target="_top">overhead_join.cpp</a>)
          </p>
<div class="table">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.overhead_of_detach"></a><p class="title"><b>Table&#160;1.2.&#160;Overhead of detach</b></p>
<div class="table-contents"><table class="table" summary="Overhead of detach">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      thread
                    </p>
                  </th>
<th>
                    <p>
                      fiber (atomics)
                    </p>
                  </th>
<th>
                    <p>
                      fiber (raw)
                    </p>
                  </th>
</tr></thead>
<tbody><tr>
<td>
                    <p>
                      126 ns
                    </p>
                  </td>
<td>
                    <p>
                      21 ns
                    </p>
                  </td>
<td>
                    <p>
                      20 ns
                    </p>
                  </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
            (from <a href="../../../../../performance/fiber/overhead_detach.cpp" target="_top">overhead_detach.cpp</a>)
          </p>
<div class="table">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.overhead_of_yield"></a><p class="title"><b>Table&#160;1.3.&#160;Overhead of yield</b></p>
<div class="table-contents"><table class="table" summary="Overhead of yield">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      thread
                    </p>
                  </th>
<th>
                    <p>
                      fiber (atomics)
                    </p>
                  </th>
<th>
                    <p>
                      fiber (raw)
                    </p>
                  </th>
</tr></thead>
<tbody><tr>
<td>
                    <p>
                      1.5 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      310 ns
                    </p>
                  </td>
<td>
                    <p>
                      330 ns
                    </p>
                  </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
            (from <a href="../../../../../performance/fiber/overhead_yield.cpp" target="_top">overhead_yield.cpp</a>)
          </p>
<div class="table">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.overhead_of_waiting_on_a_future"></a><p class="title"><b>Table&#160;1.4.&#160;Overhead of waiting on a future</b></p>
<div class="table-contents"><table class="table" summary="Overhead of waiting on a future">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      thread
                    </p>
                  </th>
<th>
                    <p>
                      fiber (atomics)
                    </p>
                  </th>
<th>
                    <p>
                      fiber (raw)
                    </p>
                  </th>
</tr></thead>
<tbody><tr>
<td>
                    <p>
                      16 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.40 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.38 &#181;s
                    </p>
                  </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
            (from <a href="../../../../../performance/fiber/overhead_future.cpp" target="_top">overhead_future.cpp</a>)
          </p>
<div class="table">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.overhead_of_fiber_creation__contains_fiber_stack_allocation_and_preparation__fiber_context_construction__scheduler_handling_"></a><p class="title"><b>Table&#160;1.5.&#160;Overhead of fiber creation (contains fiber-stack allocation and
            preparation, fiber-context construction, scheduler handling)</b></p>
<div class="table-contents"><table class="table" summary="Overhead of fiber creation (contains fiber-stack allocation and
            preparation, fiber-context construction, scheduler handling)">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      thread
                    </p>
                  </th>
<th>
                    <p>
                      fiber (atomics)
                    </p>
                  </th>
<th>
                    <p>
                      fiber (raw)
                    </p>
                  </th>
</tr></thead>
<tbody><tr>
<td>
                    <p>
                      18 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      450 ns
                    </p>
                  </td>
<td>
                    <p>
                      445 ns
                    </p>
                  </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
            (from <a href="../../../../../performance/fiber/overhead_create.cpp" target="_top">overhead_create.cpp</a>)
          </p>
<div class="table">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.scaling_of_creating_and_joining"></a><p class="title"><b>Table&#160;1.6.&#160;Scaling of creating and joining</b></p>
<div class="table-contents"><table class="table" summary="Scaling of creating and joining">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      average of
                    </p>
                  </th>
<th>
                    <p>
                      thread
                    </p>
                  </th>
<th>
                    <p>
                      fiber (atomics)
                    </p>
                  </th>
<th>
                    <p>
                      fiber (raw)
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      10
                    </p>
                  </td>
<td>
                    <p>
                      8.21 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.96 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.85 &#181;s
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      50
                    </p>
                  </td>
<td>
                    <p>
                      6.67 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.40 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.27 &#181;s
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      100
                    </p>
                  </td>
<td>
                    <p>
                      6.79 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.84 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.81 &#181;s
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      500
                    </p>
                  </td>
<td>
                    <p>
                      8.25 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.13 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.10 &#181;s
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      1000
                    </p>
                  </td>
<td>
                    <p>
                      7.71 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.46 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.26 &#181;s
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      5000
                    </p>
                  </td>
<td>
                    <p>
                      5.67 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      2.11 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.90 &#181;s
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      10000
                    </p>
                  </td>
<td>
                    <p>
                      5.25 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      2.36 &#181;s
                    </p>
                  </td>
<td>
                    <p>
                      1.89 &#181;s
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
            (from <a href="../../../../../performance/fiber/scale_join.cpp" target="_top">scale_join.cpp</a>)
          </p>
<p>
            Numbers of the <a href="https://github.com/atemerev/skynet" target="_top">microbenchmark
            <span class="emphasis"><em>syknet</em></span></a> from Alexander Temerev <sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.f1" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.performance.f1" class="footnote">9</a>]</sup>:
          </p>
<div class="table">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.performance.performance_of_n_100000_actors_goroutines_fibers"></a><p class="title"><b>Table&#160;1.7.&#160;performance of N=100000 actors/goroutines/fibers</b></p>
<div class="table-contents"><table class="table" summary="performance of N=100000 actors/goroutines/fibers">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Haskell | stack-1.0.4
                    </p>
                  </th>
<th>
                    <p>
                      fiber (single threaded/raw) | gcc-5.2.1
                    </p>
                  </th>
<th>
                    <p>
                      fiber (single threaded/atomics) | gcc-5.2.1
                    </p>
                  </th>
<th>
                    <p>
                      Erlang | erts-7.0
                    </p>
                  </th>
<th>
                    <p>
                      Go | go1.4.2
                    </p>
                  </th>
</tr></thead>
<tbody><tr>
<td>
                    <p>
                      58ms - 108ms
                    </p>
                  </td>
<td>
                    <p>
                      205ms - 263ms
                    </p>
                  </td>
<td>
                    <p>
                      221ms - 278ms
                    </p>
                  </td>
<td>
                    <p>
                      237ms- 470ms
                    </p>
                  </td>
<td>
                    <p>
                      614ms - 883ms
                    </p>
                  </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom"></a><a name="custom"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom" title="Customization">Customization</a>
</h5></div></div></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.overview"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.overview">Overview</a>
          </h6>
<p>
            As noted in the <a class="link" href="../../scheduling.html#scheduling">Scheduling</a> section,
            by default <span class="bold"><strong>Boost.Fiber</strong></span> uses its own
            <a class="link" href="../../scheduling.html#class_round_robin"> <code class="computeroutput">round_robin</code></a> scheduler for each thread. To control the
            way <span class="bold"><strong>Boost.Fiber</strong></span> schedules ready fibers
            on a particular thread, in general you must follow several steps. This
            section discusses those steps, whereas <a class="link" href="../../scheduling.html#scheduling">Scheduling</a>
            serves as a reference for the classes involved.
          </p>
<p>
            The library's fiber manager keeps track of suspended (blocked) fibers.
            Only when a fiber becomes ready to run is it passed to the scheduler.
            Of course, if there are fewer than two ready fibers, the scheduler's
            job is trivial. Only when there are two or more ready fibers does the
            particular scheduler implementation start to influence the overall sequence
            of fiber execution.
          </p>
<p>
            In this section we illustrate a simple custom scheduler that honors an
            integer fiber priority. We will implement it such that a fiber with higher
            priority is preferred over a fiber with lower priority. Any fibers with
            equal priority values are serviced on a round-robin basis.
          </p>
<p>
            The full source code for the examples below is found in <a href="../../../../../examples/priority.cpp" target="_top">priority.cpp</a>.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.custom_property_class"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.custom_property_class">Custom
            Property Class</a>
          </h6>
<p>
            The first essential point is that we must associate an integer priority
            with each fiber.<sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.f0" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.custom.f0" class="footnote">10</a>]</sup>
          </p>
<p>
            One might suggest deriving a custom <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> subclass to store
            such properties. There are a couple of reasons for the present mechanism.
          </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
                <span class="bold"><strong>Boost.Fiber</strong></span> provides a number of
                different ways to launch a fiber. (Consider <a class="link" href="pooled_fixedsize.html#fibers_async"> <code class="computeroutput">fibers::async()</code></a>.)
                Higher-level libraries might introduce additional such wrapper functions.
                A custom scheduler must associate its custom properties with <span class="emphasis"><em>every</em></span>
                fiber in the thread, not only the ones explicitly launched by instantiating
                a custom <code class="computeroutput"><span class="identifier">fiber</span></code> subclass.
              </li>
<li class="listitem">
                Consider a large existing program that launches fibers in many different
                places in the code. We discover a need to introduce a custom scheduler
                for a particular thread. If supporting that scheduler's custom properties
                required a particular <code class="computeroutput"><span class="identifier">fiber</span></code>
                subclass, we would have to hunt down and modify every place that
                launches a fiber on that thread.
              </li>
<li class="listitem">
                The <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> class is actually just a handle to internal <a class="link" href="../../scheduling.html#class_context"> <code class="computeroutput">context</code></a> data.
                A subclass of <code class="computeroutput"><span class="identifier">fiber</span></code>
                would not add data to <code class="computeroutput"><span class="identifier">context</span></code>.
              </li>
</ol></div>
<p>
            The present mechanism allows you to <span class="quote">&#8220;<span class="quote">drop in</span>&#8221;</span> a custom scheduler
            with its attendant custom properties <span class="emphasis"><em>without</em></span> altering
            the rest of your application.
          </p>
<p>
            Instead of deriving a custom scheduler fiber properties subclass from
            <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a>, you must instead derive it from <a class="link" href="../../scheduling.html#class_fiber_properties"> <code class="computeroutput">fiber_properties</code></a>.
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">priority_props</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber_properties</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">priority_props</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">*</span> <span class="identifier">ctx</span><span class="special">):</span>
        <span class="identifier">fiber_properties</span><span class="special">(</span> <span class="identifier">ctx</span><span class="special">),</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c0" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c1"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a>
        <span class="identifier">priority_</span><span class="special">(</span> <span class="number">0</span><span class="special">)</span> <span class="special">{</span>
    <span class="special">}</span>

    <span class="keyword">int</span> <span class="identifier">get_priority</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">priority_</span><span class="special">;</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c2" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c3"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a>
    <span class="special">}</span>

    <span class="comment">// Call this method to alter priority, because we must notify</span>
    <span class="comment">// priority_scheduler of any change.</span>
    <span class="keyword">void</span> <span class="identifier">set_priority</span><span class="special">(</span> <span class="keyword">int</span> <span class="identifier">p</span><span class="special">)</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c4" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c5"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a>
        <span class="comment">// Of course, it's only worth reshuffling the queue and all if we're</span>
        <span class="comment">// actually changing the priority.</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">p</span> <span class="special">!=</span> <span class="identifier">priority_</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">priority_</span> <span class="special">=</span> <span class="identifier">p</span><span class="special">;</span>
            <span class="identifier">notify</span><span class="special">();</span>
        <span class="special">}</span>
    <span class="special">}</span>

    <span class="comment">// The fiber name of course is solely for purposes of this example</span>
    <span class="comment">// program; it has nothing to do with implementing scheduler priority.</span>
    <span class="comment">// This is a public data member -- not requiring set/get access methods --</span>
    <span class="comment">// because we need not inform the scheduler of any change.</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">name</span><span class="special">;</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c6" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c7"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">priority_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c1"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c0"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Your subclass constructor must accept a <code class="literal"> <a class="link" href="../../scheduling.html#class_context"> <code class="computeroutput">context</code></a>*</code>
                and pass it to the <code class="computeroutput"><span class="identifier">fiber_properties</span></code>
                constructor.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c3"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c2"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Provide read access methods at your own discretion.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c5"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c4"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                It's important to call <code class="computeroutput"><span class="identifier">notify</span><span class="special">()</span></code> on any change in a property that
                can affect the scheduler's behavior. Therefore, such modifications
                should only be performed through an access method.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c7"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c6"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                A property that does not affect the scheduler does not need access
                methods.
              </p></td>
</tr>
</table></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.h2"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.custom_scheduler_class"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.custom_scheduler_class">Custom
            Scheduler Class</a>
          </h6>
<p>
            Now we can derive a custom scheduler from <a class="link" href="../../scheduling.html#class_sched_algorithm_with_properties"> <code class="computeroutput">sched_algorithm_with_properties&lt;&gt;</code></a>,
            specifying our custom property class <code class="computeroutput"><span class="identifier">priority_props</span></code>
            as the template parameter.
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">priority_scheduler</span> <span class="special">:</span>
    <span class="keyword">public</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">sched_algorithm_with_properties</span><span class="special">&lt;</span> <span class="identifier">priority_props</span> <span class="special">&gt;</span> <span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">scheduler</span><span class="special">::</span><span class="identifier">ready_queue_t</span><a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c8" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c9"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a>   <span class="identifier">rqueue_t</span><span class="special">;</span>

    <span class="identifier">rqueue_t</span>                                <span class="identifier">rqueue_</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">mutex</span>                  <span class="identifier">mtx_</span><span class="special">{};</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">condition_variable</span>     <span class="identifier">cnd_</span><span class="special">{};</span>
    <span class="keyword">bool</span>                        <span class="identifier">flag_</span><span class="special">{</span> <span class="keyword">false</span> <span class="special">};</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">priority_scheduler</span><span class="special">()</span> <span class="special">:</span>
        <span class="identifier">rqueue_</span><span class="special">()</span> <span class="special">{</span>
    <span class="special">}</span>

    <span class="comment">// For a subclass of sched_algorithm_with_properties&lt;&gt;, it's important to</span>
    <span class="comment">// override the correct awakened() overload.</span>
    <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c10" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c11"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">awakened</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">*</span> <span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">priority_props</span> <span class="special">&amp;</span> <span class="identifier">props</span><span class="special">)</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="keyword">int</span> <span class="identifier">ctx_priority</span> <span class="special">=</span> <span class="identifier">props</span><span class="special">.</span><span class="identifier">get_priority</span><span class="special">();</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c12" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c13"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a>
        <span class="comment">// With this scheduler, fibers with higher priority values are</span>
        <span class="comment">// preferred over fibers with lower priority values. But fibers with</span>
        <span class="comment">// equal priority values are processed in round-robin fashion. So when</span>
        <span class="comment">// we're handed a new context*, put it at the end of the fibers</span>
        <span class="comment">// with that same priority. In other words: search for the first fiber</span>
        <span class="comment">// in the queue with LOWER priority, and insert before that one.</span>
        <span class="identifier">rqueue_t</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">i</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">find_if</span><span class="special">(</span> <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
            <span class="special">[</span><span class="identifier">ctx_priority</span><span class="special">,</span><span class="keyword">this</span><span class="special">](</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">&amp;</span> <span class="identifier">c</span><span class="special">)</span>
            <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">properties</span><span class="special">(</span> <span class="special">&amp;</span><span class="identifier">c</span> <span class="special">).</span><span class="identifier">get_priority</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">ctx_priority</span><span class="special">;</span> <span class="special">}));</span>
        <span class="comment">// Now, whether or not we found a fiber with lower priority,</span>
        <span class="comment">// insert this new fiber here.</span>
        <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span> <span class="identifier">i</span><span class="special">,</span> <span class="special">*</span> <span class="identifier">ctx</span><span class="special">);</span>
    <span class="special">}</span>

    <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c14" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c15"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a><span class="keyword">virtual</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">*</span> <span class="identifier">pick_next</span><span class="special">()</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="comment">// if ready queue is empty, just tell caller</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">empty</span><span class="special">()</span> <span class="special">)</span> <span class="special">{</span>
            <span class="keyword">return</span> <span class="keyword">nullptr</span><span class="special">;</span>
        <span class="special">}</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">*</span> <span class="identifier">ctx</span><span class="special">(</span> <span class="special">&amp;</span> <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">front</span><span class="special">()</span> <span class="special">);</span>
        <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">pop_front</span><span class="special">();</span>
        <span class="keyword">return</span> <span class="identifier">ctx</span><span class="special">;</span>
    <span class="special">}</span>

    <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c16" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c17"><img src="../../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="identifier">has_ready_fibers</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="special">!</span> <span class="identifier">rqueue_</span><span class="special">.</span><span class="identifier">empty</span><span class="special">();</span>
    <span class="special">}</span>

    <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c18" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c19"><img src="../../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">property_change</span><span class="special">(</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">context</span> <span class="special">*</span> <span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">priority_props</span> <span class="special">&amp;</span> <span class="identifier">props</span><span class="special">)</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="comment">// Although our priority_props class defines multiple properties, only</span>
        <span class="comment">// one of them (priority) actually calls notify() when changed. The</span>
        <span class="comment">// point of a property_change() override is to reshuffle the ready</span>
        <span class="comment">// queue according to the updated priority value.</span>

        <span class="comment">// 'ctx' might not be in our queue at all, if caller is changing the</span>
        <span class="comment">// priority of (say) the running fiber. If it's not there, no need to</span>
        <span class="comment">// move it: we'll handle it next time it hits awakened().</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span> <span class="identifier">ctx</span><span class="special">-&gt;</span><span class="identifier">ready_is_linked</span><span class="special">())</span> <span class="special">{</span> <a class="co" name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c20" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c21"><img src="../../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a>
            <span class="keyword">return</span><span class="special">;</span>
        <span class="special">}</span>

        <span class="comment">// Found ctx: unlink it</span>
        <span class="identifier">ctx</span><span class="special">-&gt;</span><span class="identifier">ready_unlink</span><span class="special">();</span>

        <span class="comment">// Here we know that ctx was in our ready queue, but we've unlinked</span>
        <span class="comment">// it. We happen to have a method that will (re-)add a context* to the</span>
        <span class="comment">// right place in the ready queue.</span>
        <span class="identifier">awakened</span><span class="special">(</span> <span class="identifier">ctx</span><span class="special">,</span> <span class="identifier">props</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">suspend_until</span><span class="special">(</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">time_point</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">time_point</span><span class="special">)</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">chrono</span><span class="special">::</span><span class="identifier">steady_clock</span><span class="special">::</span><span class="identifier">time_point</span><span class="special">::</span><span class="identifier">max</span><span class="special">)()</span> <span class="special">==</span> <span class="identifier">time_point</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx_</span><span class="special">);</span>
            <span class="identifier">cnd_</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="special">[</span><span class="keyword">this</span><span class="special">](){</span> <span class="keyword">return</span> <span class="identifier">flag_</span><span class="special">;</span> <span class="special">});</span>
            <span class="identifier">flag_</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
        <span class="special">}</span> <span class="keyword">else</span> <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx_</span><span class="special">);</span>
            <span class="identifier">cnd_</span><span class="special">.</span><span class="identifier">wait_until</span><span class="special">(</span> <span class="identifier">lk</span><span class="special">,</span> <span class="identifier">time_point</span><span class="special">,</span> <span class="special">[</span><span class="keyword">this</span><span class="special">](){</span> <span class="keyword">return</span> <span class="identifier">flag_</span><span class="special">;</span> <span class="special">});</span>
            <span class="identifier">flag_</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
        <span class="special">}</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">notify</span><span class="special">()</span> <span class="keyword">noexcept</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">mutex</span> <span class="special">&gt;</span> <span class="identifier">lk</span><span class="special">(</span> <span class="identifier">mtx_</span><span class="special">);</span>
        <span class="identifier">flag_</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
        <span class="identifier">lk</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">();</span>
        <span class="identifier">cnd_</span><span class="special">.</span><span class="identifier">notify_all</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          </p>
<div class="calloutlist"><table border="0" summary="Callout list">
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c9"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c8"><img src="../../../../../../../doc/src/images/callouts/1.png" alt="1" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                See <a class="link" href="../../scheduling.html#ready_queue_t">ready_queue_t</a>.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c11"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c10"><img src="../../../../../../../doc/src/images/callouts/2.png" alt="2" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                You must override the <a class="link" href="../../scheduling.html#sched_algorithm_with_properties_awakened"> <code class="computeroutput">sched_algorithm_with_properties::awakened()</code></a>
         method.
                This is how your scheduler receives notification of a fiber that
                has become ready to run.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c13"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c12"><img src="../../../../../../../doc/src/images/callouts/3.png" alt="3" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                <code class="computeroutput"><span class="identifier">props</span></code> is the instance
                of priority_props associated with the passed fiber <code class="computeroutput"><span class="identifier">ctx</span></code>.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c15"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c14"><img src="../../../../../../../doc/src/images/callouts/4.png" alt="4" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                You must override the <a class="link" href="../../scheduling.html#sched_algorithm_with_properties_pick_next"> <code class="computeroutput">sched_algorithm_with_properties::pick_next()</code></a>
         method.
                This is how your scheduler actually advises the fiber manager of
                the next fiber to run.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c17"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c16"><img src="../../../../../../../doc/src/images/callouts/5.png" alt="5" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                You must override <a class="link" href="../../scheduling.html#sched_algorithm_with_properties_has_ready_fibers"> <code class="computeroutput">sched_algorithm_with_properties::has_ready_fibers()</code></a>
      to
                inform the fiber manager of the state of your ready queue.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c19"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c18"><img src="../../../../../../../doc/src/images/callouts/6.png" alt="6" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Overriding <a class="link" href="../../scheduling.html#sched_algorithm_with_properties_property_change"> <code class="computeroutput">sched_algorithm_with_properties::property_change()</code></a>
         is
                optional. This override handles the case in which the running fiber
                changes the priority of another ready fiber: a fiber already in our
                queue. In that case, move the updated fiber within the queue.
              </p></td>
</tr>
<tr>
<td width="5%" valign="top" align="left"><p><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c21"></a><a href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.c20"><img src="../../../../../../../doc/src/images/callouts/7.png" alt="7" border="0"></a> </p></td>
<td valign="top" align="left"><p>
                Your <code class="computeroutput"><span class="identifier">property_change</span><span class="special">()</span></code> override must be able to handle
                the case in which the passed <code class="computeroutput"><span class="identifier">ctx</span></code>
                is not in your ready queue. It might be running, or it might be blocked.
              </p></td>
</tr>
</table></div>
<p>
            Our example <code class="computeroutput"><span class="identifier">priority_scheduler</span></code>
            doesn't override <a class="link" href="../../scheduling.html#sched_algorithm_with_properties_new_properties"> <code class="computeroutput">sched_algorithm_with_properties::new_properties()</code></a>:
            we're content with allocating <code class="computeroutput"><span class="identifier">priority_props</span></code>
            instances on the heap.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.h3"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.replace_default_scheduler"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.replace_default_scheduler">Replace
            Default Scheduler</a>
          </h6>
<p>
            You must call <a class="link" href="../../fiber_mgmt/fiber.html#use_scheduling_algorithm"> <code class="computeroutput">use_scheduling_algorithm()</code></a> at the
            start of each thread on which you want <span class="bold"><strong>Boost.Fiber</strong></span>
            to use your custom scheduler rather than its own default <a class="link" href="../../scheduling.html#class_round_robin"> <code class="computeroutput">round_robin</code></a>.
            Specifically, you must call <code class="computeroutput"><span class="identifier">use_scheduling_algorithm</span><span class="special">()</span></code> before performing any other <span class="bold"><strong>Boost.Fiber</strong></span> operations on that thread.
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">main</span><span class="special">(</span> <span class="keyword">int</span> <span class="identifier">argc</span><span class="special">,</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">argv</span><span class="special">[])</span> <span class="special">{</span>
    <span class="comment">// make sure we use our priority_scheduler rather than default round_robin</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">use_scheduling_algorithm</span><span class="special">&lt;</span> <span class="identifier">priority_scheduler</span> <span class="special">&gt;();</span>
    <span class="special">...</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.h4"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.custom.use_properties"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.use_properties">Use
            Properties</a>
          </h6>
<p>
            The running fiber can access its own <a class="link" href="../../scheduling.html#class_fiber_properties"> <code class="computeroutput">fiber_properties</code></a> subclass
            instance by calling <a class="link" href="../../fiber_mgmt/this_fiber.html#this_fiber_properties"> <code class="computeroutput">this_fiber::properties()</code></a>. Although
            <code class="computeroutput"><span class="identifier">properties</span><span class="special">&lt;&gt;()</span></code>
            is a nullary function, you must pass, as a template parameter, the <code class="computeroutput"><span class="identifier">fiber_properties</span></code> subclass.
          </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">properties</span><span class="special">&lt;</span> <span class="identifier">priority_props</span> <span class="special">&gt;().</span><span class="identifier">name</span> <span class="special">=</span> <span class="string">"main"</span><span class="special">;</span>
</pre>
<p>
          </p>
<p>
            Given a <a class="link" href="../../fiber_mgmt/fiber.html#class_fiber"> <code class="computeroutput">fiber</code></a> instance still connected with a running fiber
            (that is, not <a class="link" href="../../fiber_mgmt/fiber.html#fiber_detach"> <code class="computeroutput">fiber::detach()</code></a>ed), you may access that fiber's
            properties using <a class="link" href="../../fiber_mgmt/fiber.html#fiber_properties"> <code class="computeroutput">fiber::properties()</code></a>. As with <code class="computeroutput"><span class="identifier">this_fiber</span><span class="special">::</span><span class="identifier">properties</span><span class="special">&lt;&gt;()</span></code>,
            you must pass your <code class="computeroutput"><span class="identifier">fiber_properties</span></code>
            subclass as the template parameter.
          </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span> <span class="keyword">typename</span> <span class="identifier">Fn</span> <span class="special">&gt;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span> <span class="identifier">launch</span><span class="special">(</span> <span class="identifier">Fn</span> <span class="special">&amp;&amp;</span> <span class="identifier">func</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">priority</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">fibers</span><span class="special">::</span><span class="identifier">fiber</span> <span class="identifier">fiber</span><span class="special">(</span> <span class="identifier">func</span><span class="special">);</span>
    <span class="identifier">priority_props</span> <span class="special">&amp;</span> <span class="identifier">props</span><span class="special">(</span> <span class="identifier">fiber</span><span class="special">.</span><span class="identifier">properties</span><span class="special">&lt;</span> <span class="identifier">priority_props</span> <span class="special">&gt;()</span> <span class="special">);</span>
    <span class="identifier">props</span><span class="special">.</span><span class="identifier">name</span> <span class="special">=</span> <span class="identifier">name</span><span class="special">;</span>
    <span class="identifier">props</span><span class="special">.</span><span class="identifier">set_priority</span><span class="special">(</span> <span class="identifier">priority</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">fiber</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
            Launching a new fiber schedules that fiber as ready, but does <span class="emphasis"><em>not</em></span>
            immediately enter its <span class="emphasis"><em>fiber-function</em></span>. The current
            fiber retains control until it blocks (or yields, or terminates) for
            some other reason. As shown in the <code class="computeroutput"><span class="identifier">launch</span><span class="special">()</span></code> function above, it is reasonable to
            launch a fiber and immediately set relevant properties -- such as, for
            instance, its priority. Your custom scheduler can then make use of this
            information next time the fiber manager calls <a class="link" href="../../scheduling.html#sched_algorithm_with_properties_pick_next"> <code class="computeroutput">sched_algorithm_with_properties::pick_next()</code></a>.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale" title="Rationale">Rationale</a>
</h5></div></div></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.distinction_between_coroutines_and_fibers"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.distinction_between_coroutines_and_fibers">distinction
            between coroutines and fibers</a>
          </h6>
<p>
            The fiber library extends the coroutine library by adding a scheduler
            and synchronization mechanisms.
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                a coroutine yields
              </li>
<li class="listitem">
                a fiber blocks
              </li>
</ul></div>
<p>
            When a coroutine yields, it passes control directly to its caller (or,
            in the case of symmetric coroutines, a designated other coroutine). When
            a fiber blocks, it implicitly passes control to the fiber scheduler.
            Coroutines have no scheduler because they need no scheduler.<sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.f0" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.f0" class="footnote">11</a>]</sup>.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.what_about_transactional_memory"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.what_about_transactional_memory">what
            about transactional memory</a>
          </h6>
<p>
            GCC supports transactional memory since version 4.7. Unfortunately tests
            show that transactional memory is slower (ca. 4x) than spinlocks using
            atomics. Once transactional memory is improved (supporting hybrid tm),
            spinlocks will be replaced by __transaction_atomic{} statements surrounding
            the critical sections.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.h2"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.synchronization_between_fibers_running_in_different_threads"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.synchronization_between_fibers_running_in_different_threads">synchronization
            between fibers running in different threads</a>
          </h6>
<p>
            Synchronization classes from <a href="http://www.boost.org/doc/libs/release/libs/thread/index.html" target="_top">Boost.Thread</a>
            block the entire thread. In contrast, the synchronization classes from
            <span class="bold"><strong>Boost.Fiber</strong></span> block only specific fibers,
            so that the scheduler can still keep the thread busy running other fibers
            in the meantime. The synchronization classes from <span class="bold"><strong>Boost.Fiber</strong></span>
            are designed to be thread-safe, i.e. it is possible to synchronize fibers
            running in different threads as well as fibers running in the same thread.
            (However, there is a build option to disable cross-thread fiber synchronization
            support; see <a class="link" href="../../overview.html#cross_thread_sync">this description</a>.)
          </p>
<a name="spurious_wakeup"></a><h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.h3"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.spurious_wakeup"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.spurious_wakeup">spurious
            wakeup</a>
          </h6>
<p>
            Spurious wakeup can happen when using <a href="http://en.cppreference.com/w/cpp/thread/condition_variable" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">condition_variable</span></code></a>: the condition
            variable appears to be have been signaled while the awaited condition
            may still be false. Spurious wakeup can happen repeatedly and is caused
            on some multiprocessor systems where making <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">condition_variable</span></code>
            wakeup completely predictable would slow down all <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">condition_variable</span></code>
            operations.<sup>[<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.f1" href="#ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.f1" class="footnote">12</a>]</sup>
          </p>
<p>
            <a class="link" href="pooled_fixedsize.html#class_condition_variable"> <code class="computeroutput">condition_variable</code></a> is not subject to spurious
            wakeup. Nonetheless it is prudent to test the business-logic condition
            in a <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
            loop &#8212; or, equivalently, use one of the <code class="computeroutput"><span class="identifier">wait</span><span class="special">(</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate</span>
            <span class="special">)</span></code> overloads.
          </p>
<p>
            See also <a class="link" href="pooled_fixedsize.html#condition_variable_spurious_wakeups">No Spurious
            Wakeups</a>.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.h4"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.migrating_fibers_between_threads"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.migrating_fibers_between_threads">migrating
            fibers between threads</a>
          </h6>
<p>
            Support for migrating fibers between threads has been integrated. The
            user-defined scheduler must call <a class="link" href="../../scheduling.html#context_migrate"> <code class="computeroutput">context::migrate()</code></a> on
            a fiber-context on the destination thread, passing <code class="computeroutput"><span class="identifier">migrate</span><span class="special">()</span></code> the fiber-context to migrate. (For
            more information about custom schedulers, see <a class="link" href="pooled_fixedsize.html#custom">Customization</a>.)
            Examples <code class="computeroutput"><span class="identifier">work_sharing</span></code>
            and <code class="computeroutput"><span class="identifier">work_stealing</span></code> in
            directory <code class="computeroutput"><span class="identifier">examples</span></code> might
            be used as a blueprint.
          </p>
<p>
            See also <a class="link" href="pooled_fixedsize.html#migration">Migrating fibers between threads</a>.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.h5"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.support_for_boost_asio"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.support_for_boost_asio">support
            for Boost.Asio</a>
          </h6>
<p>
            Support for <a href="http://www.boost.org/doc/libs/release/libs/asio/index.html" target="_top">Boost.Asio</a>'s
            <span class="emphasis"><em>async-result</em></span> is not part of the official API. However,
            to integrate with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">io_service</span></code>,
            see <a class="link" href="pooled_fixedsize.html#integration">Sharing a Thread with Another Main Loop</a>.
            To interface smoothly with an arbitrary Asio async I/O operation, see
            <a class="link" href="pooled_fixedsize.html#callbacks_asio">Then There's <a href="http://www.boost.org/doc/libs/release/libs/asio/index.html" target="_top">Boost.Asio</a></a>.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.h6"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.tested_compilers"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.tested_compilers">tested
            compilers</a>
          </h6>
<p>
            The library was tested with GCC-5.1.1, Clang-3.6.0 and MSVC-14.0 in c++11-mode.
          </p>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.h7"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.supported_architectures"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.supported_architectures">supported
            architectures</a>
          </h6>
<p>
            <span class="bold"><strong>Boost.Fiber</strong></span> depends on <a href="http://www.boost.org/doc/libs/release/libs/context/index.html" target="_top">Boost.Context</a>
            - the list of supported architectures can be found <a href="http://www.boost.org/doc/libs/release/libs/context/doc/html/context/architectures.html" target="_top">here</a>.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.acknowledgements"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.acknowledgements" title="Acknowledgments">Acknowledgments</a>
</h5></div></div></div>
<p>
            I'd like to thank Agust&#237;n Berg&#233;, Eugene Yakubovich, Giovanni Piero
            Deretta and especially Nat Goodspeed.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.installing"></a><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.installing" title="Appendix: Installing and Running Tests">Appendix:
          Installing and Running Tests</a>
</h5></div></div></div>
<h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.installing.h0"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.installing.installing_the_fiber_library"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.installing.installing_the_fiber_library">Installing
            the Fiber library</a>
          </h6>
<p>
            As Fiber is not yet officially part of Boost, it is necessary to embed
            it in an existing <a href="http://www.boost.org/users/download/" target="_top">Boost
            source tree</a>.
          </p>
<p>
            The <a href="https://github.com/olk/boost-fiber/archive/master.zip" target="_top">downloaded
            Fiber library</a> can be placed into an existing Boost source tree
            by moving the top-level Fiber directory to <code class="computeroutput"><span class="identifier">libs</span><span class="special">/</span><span class="identifier">fiber</span></code>
            under the top-level Boost directory, then further moving <code class="computeroutput"><span class="identifier">libs</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span></code> (in other words, the Fiber library's
            <code class="computeroutput"><span class="identifier">include</span><span class="special">/</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span></code> directory) to <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span></code>
            under the top-level Boost directory.
          </p>
<p>
            On a Posix system such as Linux or OS X, you may use symlinks instead.
          </p>
<p>
            Create a symlink from the Boost directory's <code class="computeroutput"><span class="identifier">libs</span><span class="special">/</span><span class="identifier">fiber</span></code>
            to the top-level Fiber directory, e.g.:
          </p>
<pre class="programlisting"><span class="identifier">cd</span> <span class="special">~/</span><span class="identifier">boost_1_61_0</span>
<span class="identifier">ln</span> <span class="special">-</span><span class="identifier">s</span> <span class="special">~/</span><span class="identifier">boost</span><span class="special">-</span><span class="identifier">fiber</span><span class="special">-</span><span class="identifier">master</span> <span class="identifier">libs</span><span class="special">/</span><span class="identifier">fiber</span>
</pre>
<p>
            Then create a symlink from the Boost directory's <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span></code>
            to the Fiber library's <code class="computeroutput"><span class="identifier">include</span><span class="special">/</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span></code>
            directory:
          </p>
<pre class="programlisting"><span class="identifier">cd</span> <span class="identifier">boost</span>
<span class="identifier">ln</span> <span class="special">-</span><span class="identifier">s</span> <span class="special">../</span><span class="identifier">libs</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">include</span><span class="special">/</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span> <span class="identifier">fiber</span>
</pre>
<p>
            For some versions of the Boost.Build system, it was important to use
            a relative symlink of that form for <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">fiber</span></code>.
          </p>
<a name="tests"></a><h6>
<a name="fiber.stack.protected_fixedsize.pooled_fixedsize.installing.h1"></a>
            <span><a name="fiber.stack.protected_fixedsize.pooled_fixedsize.installing.running_tests"></a></span><a class="link" href="pooled_fixedsize.html#fiber.stack.protected_fixedsize.pooled_fixedsize.installing.running_tests">Running
            Tests</a>
          </h6>
<p>
            Once the Fiber library has been overlaid (or symlinked) into the Boost
            source tree this way, the Boost.Build system can build it like any other
            Boost library. In particular:
          </p>
<pre class="programlisting"><span class="identifier">cd</span> <span class="special">~/</span><span class="identifier">boost_1_61_0</span>
<span class="special">./</span><span class="identifier">bootstrap</span><span class="special">.</span><span class="identifier">sh</span>
<span class="special">./</span><span class="identifier">b2</span> <span class="identifier">libs</span><span class="special">/</span><span class="identifier">fiber</span><span class="special">/</span><span class="identifier">test</span>
</pre>
<p>
            On Windows, the commands would look more like:
          </p>
<pre class="programlisting"><span class="identifier">cd</span> <span class="special">/</span><span class="identifier">D</span> <span class="special">%</span><span class="identifier">HOMEDRIVE</span><span class="special">%%</span><span class="identifier">HOMEPATH</span><span class="special">%\</span><span class="identifier">boost_1_61_0</span>
<span class="identifier">bootstrap</span>
<span class="identifier">b2</span> <span class="identifier">libs</span><span class="special">\</span><span class="identifier">fiber</span><span class="special">\</span><span class="identifier">test</span>
</pre>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers.f0" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.synchronization.barriers.f0" class="para">2</a>] </sup>
                  The current implementation wakes fibers in FIFO order: the first
                  to call <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code>
                  wakes first, and so forth. But it is perilous to rely on the order
                  in which the various fibers will reach the <code class="computeroutput"><span class="identifier">wait</span><span class="special">()</span></code> call.
                </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.migration.f0" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.f0" class="para">3</a>] </sup>
              The <span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> fiber on each thread, that is, the fiber on
              which the thread is launched, cannot migrate to any other thread. Also
              <span class="bold"><strong>Boost.Fiber</strong></span> implicitly creates a dispatcher
              fiber for each thread &#8212; this cannot migrate either.
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.migration.f1" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.migration.f1" class="para">4</a>] </sup>
              Of course it would be problematic to migrate a fiber that relies on
              <a class="link" href="../../overview.html#thread_local_storage">thread-local storage</a>.
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.f0" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.f0" class="para">5</a>] </sup>
              This mechanism has been proposed as a conventional way to allow the
              caller of an async function to specify completion handling: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4045.pdf" target="_top">N4045</a>.
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.f1" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.callbacks.f1" class="para">6</a>] </sup>
              per <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4045.pdf" target="_top">N4045</a>
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values.f0" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.when_any.when_all_functionality.when_all__return_values.f0" class="para">7</a>] </sup>
                  We could have used either <a class="link" href="pooled_fixedsize.html#class_bounded_channel"> <code class="computeroutput">bounded_channel&lt;&gt;</code></a> or
                  <a class="link" href="pooled_fixedsize.html#class_unbounded_channel"> <code class="computeroutput">unbounded_channel&lt;&gt;</code></a>. We chose <code class="computeroutput"><span class="identifier">unbounded_channel</span><span class="special">&lt;&gt;</span></code>
                  on the assumption that its simpler semantics imply a cheaper implementation.
                </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.performance.f0" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.performance.f0" class="para">8</a>] </sup>
              Intel Core2 Q6700, x86_64, 3GHz
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.performance.f1" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.performance.f1" class="para">9</a>] </sup>
              Intel Core2 Q6700, x86_64, 3GHz
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.custom.f0" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.custom.f0" class="para">10</a>] </sup>
              A previous version of the Fiber library implicitly tracked an int priority
              for each fiber, even though the default scheduler ignored it. This
              has been dropped, since the library now supports arbitrary scheduler-specific
              fiber properties.
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.f0" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.f0" class="para">11</a>] </sup>
              <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4024.pdf" target="_top">'N4024:
              Distinguishing coroutines and fibers'</a>
            </p></div>
<div class="footnote"><p><sup>[<a name="ftn.fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.f1" href="#fiber.stack.protected_fixedsize.pooled_fixedsize.rationale.f1" class="para">12</a>] </sup>
              David R. Butenhof <span class="quote">&#8220;<span class="quote">Programming with POSIX Threads</span>&#8221;</span>
            </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013 Oliver Kowalke<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../protected_fixedsize.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../protected_fixedsize.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a>
</div>
</body>
</html>
